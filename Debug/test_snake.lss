
test_snake.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000064e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d8  00800060  000064e2  00006576  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000632  00800138  00800138  0000664e  2**0
                  ALLOC
  3 .stab         00007b30  00000000  00000000  00006650  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000037e1  00000000  00000000  0000e180  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00011961  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00011ac1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  00011c50  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00013c95  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  00014d96  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00015d18  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00015e98  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  0001615a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000169e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 4b 26 	jmp	0x4c96	; 0x4c96 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ee       	ldi	r30, 0xE2	; 226
      68:	f4 e6       	ldi	r31, 0x64	; 100
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 33       	cpi	r26, 0x38	; 56
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 e3       	ldi	r26, 0x38	; 56
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 36       	cpi	r26, 0x6A	; 106
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 75 13 	call	0x26ea	; 0x26ea <main>
      8a:	0c 94 6f 32 	jmp	0x64de	; 0x64de <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 19 32 	jmp	0x6432	; 0x6432 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ad eb       	ldi	r26, 0xBD	; 189
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 35 32 	jmp	0x646a	; 0x646a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 25 32 	jmp	0x644a	; 0x644a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 41 32 	jmp	0x6482	; 0x6482 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 25 32 	jmp	0x644a	; 0x644a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 41 32 	jmp	0x6482	; 0x6482 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 19 32 	jmp	0x6432	; 0x6432 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8d eb       	ldi	r24, 0xBD	; 189
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 35 32 	jmp	0x646a	; 0x646a <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 21 32 	jmp	0x6442	; 0x6442 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6d eb       	ldi	r22, 0xBD	; 189
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 3d 32 	jmp	0x647a	; 0x647a <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 25 32 	jmp	0x644a	; 0x644a <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 41 32 	jmp	0x6482	; 0x6482 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 25 32 	jmp	0x644a	; 0x644a <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 41 32 	jmp	0x6482	; 0x6482 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 25 32 	jmp	0x644a	; 0x644a <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 41 32 	jmp	0x6482	; 0x6482 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 29 32 	jmp	0x6452	; 0x6452 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 45 32 	jmp	0x648a	; 0x648a <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <HKPD_u8GetKey>:
u8 HKPD_Au8ColPort[4]={HKPD_u8_C0_PORT,HKPD_u8_C1_PORT,HKPD_u8_C2_PORT,HKPD_u8_C3_PORT};

u8 HKPD_Au8Keys[4][4]=HKPD_KEYS;

u8 HKPD_u8GetKey(u8* Copy_Pu8_RetKey)
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62
     ca6:	a3 97       	sbiw	r28, 0x23	; 35
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	9b a3       	std	Y+35, r25	; 0x23
     cb4:	8a a3       	std	Y+34, r24	; 0x22
	u8 Local_u8ErrorState=STD_TYPES_OK;
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	88 a3       	std	Y+32, r24	; 0x20
	u8 Local_u8RowCounter;
	u8 Local_u8ColCounter;
	u8 Local_u8RetPinValue,Local_u8Flag=0;
     cba:	1d 8e       	std	Y+29, r1	; 0x1d
	if(Copy_Pu8_RetKey!=STD_TYPES_NULL)
     cbc:	8a a1       	ldd	r24, Y+34	; 0x22
     cbe:	9b a1       	ldd	r25, Y+35	; 0x23
     cc0:	00 97       	sbiw	r24, 0x00	; 0
     cc2:	09 f4       	brne	.+2      	; 0xcc6 <HKPD_u8GetKey+0x28>
     cc4:	6f c1       	rjmp	.+734    	; 0xfa4 <HKPD_u8GetKey+0x306>
	{
		*Copy_Pu8_RetKey=HKPD_u8_NO_KEY_PRESSED;
     cc6:	ea a1       	ldd	r30, Y+34	; 0x22
     cc8:	fb a1       	ldd	r31, Y+35	; 0x23
     cca:	8f ef       	ldi	r24, 0xFF	; 255
     ccc:	80 83       	st	Z, r24
		/*Activate Each Row*/
		for(Local_u8RowCounter=0;Local_u8RowCounter<4;Local_u8RowCounter++)
     cce:	1f 8e       	std	Y+31, r1	; 0x1f
     cd0:	64 c1       	rjmp	.+712    	; 0xf9a <HKPD_u8GetKey+0x2fc>
		{
			/*Activate Row*/
			MDIO_u8SetPinValue(HKPD_Au8RowPort[Local_u8RowCounter],HKPD_Au8RowPins[Local_u8RowCounter],
     cd2:	8f 8d       	ldd	r24, Y+31	; 0x1f
     cd4:	88 2f       	mov	r24, r24
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	fc 01       	movw	r30, r24
     cda:	e8 5c       	subi	r30, 0xC8	; 200
     cdc:	fe 4f       	sbci	r31, 0xFE	; 254
     cde:	20 81       	ld	r18, Z
     ce0:	8f 8d       	ldd	r24, Y+31	; 0x1f
     ce2:	88 2f       	mov	r24, r24
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	fc 01       	movw	r30, r24
     ce8:	eb 53       	subi	r30, 0x3B	; 59
     cea:	ff 4f       	sbci	r31, 0xFF	; 255
     cec:	90 81       	ld	r25, Z
     cee:	82 2f       	mov	r24, r18
     cf0:	69 2f       	mov	r22, r25
     cf2:	40 e0       	ldi	r20, 0x00	; 0
     cf4:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
					MDIO_u8_LOW);
			/*Check columns*/
			for(Local_u8ColCounter=0;Local_u8ColCounter<4;Local_u8ColCounter++)
     cf8:	1e 8e       	std	Y+30, r1	; 0x1e
     cfa:	32 c1       	rjmp	.+612    	; 0xf60 <HKPD_u8GetKey+0x2c2>
			{
				MDIO_u8GetPinValue(HKPD_Au8ColPort[Local_u8ColCounter],HKPD_Au8ColPins[Local_u8ColCounter],
     cfc:	8e 8d       	ldd	r24, Y+30	; 0x1e
     cfe:	88 2f       	mov	r24, r24
     d00:	90 e0       	ldi	r25, 0x00	; 0
     d02:	fc 01       	movw	r30, r24
     d04:	e4 5c       	subi	r30, 0xC4	; 196
     d06:	fe 4f       	sbci	r31, 0xFE	; 254
     d08:	40 81       	ld	r20, Z
     d0a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d0c:	88 2f       	mov	r24, r24
     d0e:	90 e0       	ldi	r25, 0x00	; 0
     d10:	fc 01       	movw	r30, r24
     d12:	e7 53       	subi	r30, 0x37	; 55
     d14:	ff 4f       	sbci	r31, 0xFF	; 255
     d16:	90 81       	ld	r25, Z
     d18:	9e 01       	movw	r18, r28
     d1a:	2f 5d       	subi	r18, 0xDF	; 223
     d1c:	3f 4f       	sbci	r19, 0xFF	; 255
     d1e:	84 2f       	mov	r24, r20
     d20:	69 2f       	mov	r22, r25
     d22:	a9 01       	movw	r20, r18
     d24:	0e 94 71 11 	call	0x22e2	; 0x22e2 <MDIO_u8GetPinValue>
								&Local_u8RetPinValue);
				if(Local_u8RetPinValue==MDIO_u8_LOW){
     d28:	89 a1       	ldd	r24, Y+33	; 0x21
     d2a:	88 23       	and	r24, r24
     d2c:	09 f0       	breq	.+2      	; 0xd30 <HKPD_u8GetKey+0x92>
     d2e:	15 c1       	rjmp	.+554    	; 0xf5a <HKPD_u8GetKey+0x2bc>
     d30:	80 e0       	ldi	r24, 0x00	; 0
     d32:	90 e0       	ldi	r25, 0x00	; 0
     d34:	a0 ea       	ldi	r26, 0xA0	; 160
     d36:	b1 e4       	ldi	r27, 0x41	; 65
     d38:	89 8f       	std	Y+25, r24	; 0x19
     d3a:	9a 8f       	std	Y+26, r25	; 0x1a
     d3c:	ab 8f       	std	Y+27, r26	; 0x1b
     d3e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     d40:	69 8d       	ldd	r22, Y+25	; 0x19
     d42:	7a 8d       	ldd	r23, Y+26	; 0x1a
     d44:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d46:	9c 8d       	ldd	r25, Y+28	; 0x1c
     d48:	20 e0       	ldi	r18, 0x00	; 0
     d4a:	30 e0       	ldi	r19, 0x00	; 0
     d4c:	4a ef       	ldi	r20, 0xFA	; 250
     d4e:	54 e4       	ldi	r21, 0x44	; 68
     d50:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d54:	dc 01       	movw	r26, r24
     d56:	cb 01       	movw	r24, r22
     d58:	8d 8b       	std	Y+21, r24	; 0x15
     d5a:	9e 8b       	std	Y+22, r25	; 0x16
     d5c:	af 8b       	std	Y+23, r26	; 0x17
     d5e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     d60:	6d 89       	ldd	r22, Y+21	; 0x15
     d62:	7e 89       	ldd	r23, Y+22	; 0x16
     d64:	8f 89       	ldd	r24, Y+23	; 0x17
     d66:	98 8d       	ldd	r25, Y+24	; 0x18
     d68:	20 e0       	ldi	r18, 0x00	; 0
     d6a:	30 e0       	ldi	r19, 0x00	; 0
     d6c:	40 e8       	ldi	r20, 0x80	; 128
     d6e:	5f e3       	ldi	r21, 0x3F	; 63
     d70:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
     d74:	88 23       	and	r24, r24
     d76:	2c f4       	brge	.+10     	; 0xd82 <HKPD_u8GetKey+0xe4>
		__ticks = 1;
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	9c 8b       	std	Y+20, r25	; 0x14
     d7e:	8b 8b       	std	Y+19, r24	; 0x13
     d80:	3f c0       	rjmp	.+126    	; 0xe00 <HKPD_u8GetKey+0x162>
	else if (__tmp > 65535)
     d82:	6d 89       	ldd	r22, Y+21	; 0x15
     d84:	7e 89       	ldd	r23, Y+22	; 0x16
     d86:	8f 89       	ldd	r24, Y+23	; 0x17
     d88:	98 8d       	ldd	r25, Y+24	; 0x18
     d8a:	20 e0       	ldi	r18, 0x00	; 0
     d8c:	3f ef       	ldi	r19, 0xFF	; 255
     d8e:	4f e7       	ldi	r20, 0x7F	; 127
     d90:	57 e4       	ldi	r21, 0x47	; 71
     d92:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
     d96:	18 16       	cp	r1, r24
     d98:	4c f5       	brge	.+82     	; 0xdec <HKPD_u8GetKey+0x14e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d9a:	69 8d       	ldd	r22, Y+25	; 0x19
     d9c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     d9e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     da0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     da2:	20 e0       	ldi	r18, 0x00	; 0
     da4:	30 e0       	ldi	r19, 0x00	; 0
     da6:	40 e2       	ldi	r20, 0x20	; 32
     da8:	51 e4       	ldi	r21, 0x41	; 65
     daa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     dae:	dc 01       	movw	r26, r24
     db0:	cb 01       	movw	r24, r22
     db2:	bc 01       	movw	r22, r24
     db4:	cd 01       	movw	r24, r26
     db6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     dba:	dc 01       	movw	r26, r24
     dbc:	cb 01       	movw	r24, r22
     dbe:	9c 8b       	std	Y+20, r25	; 0x14
     dc0:	8b 8b       	std	Y+19, r24	; 0x13
     dc2:	0f c0       	rjmp	.+30     	; 0xde2 <HKPD_u8GetKey+0x144>
     dc4:	88 ec       	ldi	r24, 0xC8	; 200
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	9a 8b       	std	Y+18, r25	; 0x12
     dca:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     dcc:	89 89       	ldd	r24, Y+17	; 0x11
     dce:	9a 89       	ldd	r25, Y+18	; 0x12
     dd0:	01 97       	sbiw	r24, 0x01	; 1
     dd2:	f1 f7       	brne	.-4      	; 0xdd0 <HKPD_u8GetKey+0x132>
     dd4:	9a 8b       	std	Y+18, r25	; 0x12
     dd6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     dd8:	8b 89       	ldd	r24, Y+19	; 0x13
     dda:	9c 89       	ldd	r25, Y+20	; 0x14
     ddc:	01 97       	sbiw	r24, 0x01	; 1
     dde:	9c 8b       	std	Y+20, r25	; 0x14
     de0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     de2:	8b 89       	ldd	r24, Y+19	; 0x13
     de4:	9c 89       	ldd	r25, Y+20	; 0x14
     de6:	00 97       	sbiw	r24, 0x00	; 0
     de8:	69 f7       	brne	.-38     	; 0xdc4 <HKPD_u8GetKey+0x126>
     dea:	2b c0       	rjmp	.+86     	; 0xe42 <HKPD_u8GetKey+0x1a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     dec:	6d 89       	ldd	r22, Y+21	; 0x15
     dee:	7e 89       	ldd	r23, Y+22	; 0x16
     df0:	8f 89       	ldd	r24, Y+23	; 0x17
     df2:	98 8d       	ldd	r25, Y+24	; 0x18
     df4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     df8:	dc 01       	movw	r26, r24
     dfa:	cb 01       	movw	r24, r22
     dfc:	9c 8b       	std	Y+20, r25	; 0x14
     dfe:	8b 8b       	std	Y+19, r24	; 0x13
     e00:	8b 89       	ldd	r24, Y+19	; 0x13
     e02:	9c 89       	ldd	r25, Y+20	; 0x14
     e04:	98 8b       	std	Y+16, r25	; 0x10
     e06:	8f 87       	std	Y+15, r24	; 0x0f
     e08:	8f 85       	ldd	r24, Y+15	; 0x0f
     e0a:	98 89       	ldd	r25, Y+16	; 0x10
     e0c:	01 97       	sbiw	r24, 0x01	; 1
     e0e:	f1 f7       	brne	.-4      	; 0xe0c <HKPD_u8GetKey+0x16e>
     e10:	98 8b       	std	Y+16, r25	; 0x10
     e12:	8f 87       	std	Y+15, r24	; 0x0f
     e14:	16 c0       	rjmp	.+44     	; 0xe42 <HKPD_u8GetKey+0x1a4>
					/*wait for debouncing*/
					_delay_ms(20);
					while(Local_u8RetPinValue==MDIO_u8_LOW)
					{
					  MDIO_u8GetPinValue(HKPD_Au8ColPort[Local_u8ColCounter],HKPD_Au8ColPins[Local_u8ColCounter],
     e16:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e18:	88 2f       	mov	r24, r24
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	fc 01       	movw	r30, r24
     e1e:	e4 5c       	subi	r30, 0xC4	; 196
     e20:	fe 4f       	sbci	r31, 0xFE	; 254
     e22:	40 81       	ld	r20, Z
     e24:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e26:	88 2f       	mov	r24, r24
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	fc 01       	movw	r30, r24
     e2c:	e7 53       	subi	r30, 0x37	; 55
     e2e:	ff 4f       	sbci	r31, 0xFF	; 255
     e30:	90 81       	ld	r25, Z
     e32:	9e 01       	movw	r18, r28
     e34:	2f 5d       	subi	r18, 0xDF	; 223
     e36:	3f 4f       	sbci	r19, 0xFF	; 255
     e38:	84 2f       	mov	r24, r20
     e3a:	69 2f       	mov	r22, r25
     e3c:	a9 01       	movw	r20, r18
     e3e:	0e 94 71 11 	call	0x22e2	; 0x22e2 <MDIO_u8GetPinValue>
				MDIO_u8GetPinValue(HKPD_Au8ColPort[Local_u8ColCounter],HKPD_Au8ColPins[Local_u8ColCounter],
								&Local_u8RetPinValue);
				if(Local_u8RetPinValue==MDIO_u8_LOW){
					/*wait for debouncing*/
					_delay_ms(20);
					while(Local_u8RetPinValue==MDIO_u8_LOW)
     e42:	89 a1       	ldd	r24, Y+33	; 0x21
     e44:	88 23       	and	r24, r24
     e46:	39 f3       	breq	.-50     	; 0xe16 <HKPD_u8GetKey+0x178>
     e48:	80 e0       	ldi	r24, 0x00	; 0
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	a0 ea       	ldi	r26, 0xA0	; 160
     e4e:	b1 e4       	ldi	r27, 0x41	; 65
     e50:	8b 87       	std	Y+11, r24	; 0x0b
     e52:	9c 87       	std	Y+12, r25	; 0x0c
     e54:	ad 87       	std	Y+13, r26	; 0x0d
     e56:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e58:	6b 85       	ldd	r22, Y+11	; 0x0b
     e5a:	7c 85       	ldd	r23, Y+12	; 0x0c
     e5c:	8d 85       	ldd	r24, Y+13	; 0x0d
     e5e:	9e 85       	ldd	r25, Y+14	; 0x0e
     e60:	20 e0       	ldi	r18, 0x00	; 0
     e62:	30 e0       	ldi	r19, 0x00	; 0
     e64:	4a ef       	ldi	r20, 0xFA	; 250
     e66:	54 e4       	ldi	r21, 0x44	; 68
     e68:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e6c:	dc 01       	movw	r26, r24
     e6e:	cb 01       	movw	r24, r22
     e70:	8f 83       	std	Y+7, r24	; 0x07
     e72:	98 87       	std	Y+8, r25	; 0x08
     e74:	a9 87       	std	Y+9, r26	; 0x09
     e76:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     e78:	6f 81       	ldd	r22, Y+7	; 0x07
     e7a:	78 85       	ldd	r23, Y+8	; 0x08
     e7c:	89 85       	ldd	r24, Y+9	; 0x09
     e7e:	9a 85       	ldd	r25, Y+10	; 0x0a
     e80:	20 e0       	ldi	r18, 0x00	; 0
     e82:	30 e0       	ldi	r19, 0x00	; 0
     e84:	40 e8       	ldi	r20, 0x80	; 128
     e86:	5f e3       	ldi	r21, 0x3F	; 63
     e88:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
     e8c:	88 23       	and	r24, r24
     e8e:	2c f4       	brge	.+10     	; 0xe9a <HKPD_u8GetKey+0x1fc>
		__ticks = 1;
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	9e 83       	std	Y+6, r25	; 0x06
     e96:	8d 83       	std	Y+5, r24	; 0x05
     e98:	3f c0       	rjmp	.+126    	; 0xf18 <HKPD_u8GetKey+0x27a>
	else if (__tmp > 65535)
     e9a:	6f 81       	ldd	r22, Y+7	; 0x07
     e9c:	78 85       	ldd	r23, Y+8	; 0x08
     e9e:	89 85       	ldd	r24, Y+9	; 0x09
     ea0:	9a 85       	ldd	r25, Y+10	; 0x0a
     ea2:	20 e0       	ldi	r18, 0x00	; 0
     ea4:	3f ef       	ldi	r19, 0xFF	; 255
     ea6:	4f e7       	ldi	r20, 0x7F	; 127
     ea8:	57 e4       	ldi	r21, 0x47	; 71
     eaa:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
     eae:	18 16       	cp	r1, r24
     eb0:	4c f5       	brge	.+82     	; 0xf04 <HKPD_u8GetKey+0x266>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     eb2:	6b 85       	ldd	r22, Y+11	; 0x0b
     eb4:	7c 85       	ldd	r23, Y+12	; 0x0c
     eb6:	8d 85       	ldd	r24, Y+13	; 0x0d
     eb8:	9e 85       	ldd	r25, Y+14	; 0x0e
     eba:	20 e0       	ldi	r18, 0x00	; 0
     ebc:	30 e0       	ldi	r19, 0x00	; 0
     ebe:	40 e2       	ldi	r20, 0x20	; 32
     ec0:	51 e4       	ldi	r21, 0x41	; 65
     ec2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ec6:	dc 01       	movw	r26, r24
     ec8:	cb 01       	movw	r24, r22
     eca:	bc 01       	movw	r22, r24
     ecc:	cd 01       	movw	r24, r26
     ece:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     ed2:	dc 01       	movw	r26, r24
     ed4:	cb 01       	movw	r24, r22
     ed6:	9e 83       	std	Y+6, r25	; 0x06
     ed8:	8d 83       	std	Y+5, r24	; 0x05
     eda:	0f c0       	rjmp	.+30     	; 0xefa <HKPD_u8GetKey+0x25c>
     edc:	88 ec       	ldi	r24, 0xC8	; 200
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	9c 83       	std	Y+4, r25	; 0x04
     ee2:	8b 83       	std	Y+3, r24	; 0x03
     ee4:	8b 81       	ldd	r24, Y+3	; 0x03
     ee6:	9c 81       	ldd	r25, Y+4	; 0x04
     ee8:	01 97       	sbiw	r24, 0x01	; 1
     eea:	f1 f7       	brne	.-4      	; 0xee8 <HKPD_u8GetKey+0x24a>
     eec:	9c 83       	std	Y+4, r25	; 0x04
     eee:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ef0:	8d 81       	ldd	r24, Y+5	; 0x05
     ef2:	9e 81       	ldd	r25, Y+6	; 0x06
     ef4:	01 97       	sbiw	r24, 0x01	; 1
     ef6:	9e 83       	std	Y+6, r25	; 0x06
     ef8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     efa:	8d 81       	ldd	r24, Y+5	; 0x05
     efc:	9e 81       	ldd	r25, Y+6	; 0x06
     efe:	00 97       	sbiw	r24, 0x00	; 0
     f00:	69 f7       	brne	.-38     	; 0xedc <HKPD_u8GetKey+0x23e>
     f02:	14 c0       	rjmp	.+40     	; 0xf2c <HKPD_u8GetKey+0x28e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f04:	6f 81       	ldd	r22, Y+7	; 0x07
     f06:	78 85       	ldd	r23, Y+8	; 0x08
     f08:	89 85       	ldd	r24, Y+9	; 0x09
     f0a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f0c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f10:	dc 01       	movw	r26, r24
     f12:	cb 01       	movw	r24, r22
     f14:	9e 83       	std	Y+6, r25	; 0x06
     f16:	8d 83       	std	Y+5, r24	; 0x05
     f18:	8d 81       	ldd	r24, Y+5	; 0x05
     f1a:	9e 81       	ldd	r25, Y+6	; 0x06
     f1c:	9a 83       	std	Y+2, r25	; 0x02
     f1e:	89 83       	std	Y+1, r24	; 0x01
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	9a 81       	ldd	r25, Y+2	; 0x02
     f24:	01 97       	sbiw	r24, 0x01	; 1
     f26:	f1 f7       	brne	.-4      	; 0xf24 <HKPD_u8GetKey+0x286>
     f28:	9a 83       	std	Y+2, r25	; 0x02
     f2a:	89 83       	std	Y+1, r24	; 0x01
					  MDIO_u8GetPinValue(HKPD_Au8ColPort[Local_u8ColCounter],HKPD_Au8ColPins[Local_u8ColCounter],
										&Local_u8RetPinValue);
					}
					_delay_ms(20);
					/*return value*/
					*Copy_Pu8_RetKey=HKPD_Au8Keys[Local_u8RowCounter][Local_u8ColCounter];
     f2c:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f2e:	48 2f       	mov	r20, r24
     f30:	50 e0       	ldi	r21, 0x00	; 0
     f32:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f34:	28 2f       	mov	r18, r24
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	ca 01       	movw	r24, r20
     f3a:	88 0f       	add	r24, r24
     f3c:	99 1f       	adc	r25, r25
     f3e:	88 0f       	add	r24, r24
     f40:	99 1f       	adc	r25, r25
     f42:	82 0f       	add	r24, r18
     f44:	93 1f       	adc	r25, r19
     f46:	fc 01       	movw	r30, r24
     f48:	e3 53       	subi	r30, 0x33	; 51
     f4a:	ff 4f       	sbci	r31, 0xFF	; 255
     f4c:	80 81       	ld	r24, Z
     f4e:	ea a1       	ldd	r30, Y+34	; 0x22
     f50:	fb a1       	ldd	r31, Y+35	; 0x23
     f52:	80 83       	st	Z, r24
					Local_u8Flag=1;
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	8d 8f       	std	Y+29, r24	; 0x1d
     f58:	07 c0       	rjmp	.+14     	; 0xf68 <HKPD_u8GetKey+0x2ca>
		{
			/*Activate Row*/
			MDIO_u8SetPinValue(HKPD_Au8RowPort[Local_u8RowCounter],HKPD_Au8RowPins[Local_u8RowCounter],
					MDIO_u8_LOW);
			/*Check columns*/
			for(Local_u8ColCounter=0;Local_u8ColCounter<4;Local_u8ColCounter++)
     f5a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f5c:	8f 5f       	subi	r24, 0xFF	; 255
     f5e:	8e 8f       	std	Y+30, r24	; 0x1e
     f60:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f62:	84 30       	cpi	r24, 0x04	; 4
     f64:	08 f4       	brcc	.+2      	; 0xf68 <HKPD_u8GetKey+0x2ca>
     f66:	ca ce       	rjmp	.-620    	; 0xcfc <HKPD_u8GetKey+0x5e>
					Local_u8Flag=1;
					break;
				}
			}
			/*Dectivate row*/
			MDIO_u8SetPinValue(HKPD_Au8RowPort[Local_u8RowCounter],HKPD_Au8RowPins[Local_u8RowCounter],
     f68:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f6a:	88 2f       	mov	r24, r24
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	fc 01       	movw	r30, r24
     f70:	e8 5c       	subi	r30, 0xC8	; 200
     f72:	fe 4f       	sbci	r31, 0xFE	; 254
     f74:	20 81       	ld	r18, Z
     f76:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f78:	88 2f       	mov	r24, r24
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	fc 01       	movw	r30, r24
     f7e:	eb 53       	subi	r30, 0x3B	; 59
     f80:	ff 4f       	sbci	r31, 0xFF	; 255
     f82:	90 81       	ld	r25, Z
     f84:	82 2f       	mov	r24, r18
     f86:	69 2f       	mov	r22, r25
     f88:	41 e0       	ldi	r20, 0x01	; 1
     f8a:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
					MDIO_u8_HIGH);
			if(Local_u8Flag)
     f8e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f90:	88 23       	and	r24, r24
     f92:	49 f4       	brne	.+18     	; 0xfa6 <HKPD_u8GetKey+0x308>
	u8 Local_u8RetPinValue,Local_u8Flag=0;
	if(Copy_Pu8_RetKey!=STD_TYPES_NULL)
	{
		*Copy_Pu8_RetKey=HKPD_u8_NO_KEY_PRESSED;
		/*Activate Each Row*/
		for(Local_u8RowCounter=0;Local_u8RowCounter<4;Local_u8RowCounter++)
     f94:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f96:	8f 5f       	subi	r24, 0xFF	; 255
     f98:	8f 8f       	std	Y+31, r24	; 0x1f
     f9a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f9c:	84 30       	cpi	r24, 0x04	; 4
     f9e:	08 f4       	brcc	.+2      	; 0xfa2 <HKPD_u8GetKey+0x304>
     fa0:	98 ce       	rjmp	.-720    	; 0xcd2 <HKPD_u8GetKey+0x34>
     fa2:	01 c0       	rjmp	.+2      	; 0xfa6 <HKPD_u8GetKey+0x308>
			if(Local_u8Flag)
				break;
		}
	}
	else
		Local_u8ErrorState=STD_TYPES_NOK;
     fa4:	18 a2       	std	Y+32, r1	; 0x20

	return Local_u8ErrorState;
     fa6:	88 a1       	ldd	r24, Y+32	; 0x20
}
     fa8:	a3 96       	adiw	r28, 0x23	; 35
     faa:	0f b6       	in	r0, 0x3f	; 63
     fac:	f8 94       	cli
     fae:	de bf       	out	0x3e, r29	; 62
     fb0:	0f be       	out	0x3f, r0	; 63
     fb2:	cd bf       	out	0x3d, r28	; 61
     fb4:	cf 91       	pop	r28
     fb6:	df 91       	pop	r29
     fb8:	08 95       	ret

00000fba <HLCD_voidINIT>:
#include"HLCD_config.h"
#define F_CPU 8000000UL
#include<avr/delay.h>

void HLCD_voidINIT(void)
{
     fba:	0f 93       	push	r16
     fbc:	1f 93       	push	r17
     fbe:	df 93       	push	r29
     fc0:	cf 93       	push	r28
     fc2:	cd b7       	in	r28, 0x3d	; 61
     fc4:	de b7       	in	r29, 0x3e	; 62
     fc6:	c6 55       	subi	r28, 0x56	; 86
     fc8:	d0 40       	sbci	r29, 0x00	; 0
     fca:	0f b6       	in	r0, 0x3f	; 63
     fcc:	f8 94       	cli
     fce:	de bf       	out	0x3e, r29	; 62
     fd0:	0f be       	out	0x3f, r0	; 63
     fd2:	cd bf       	out	0x3d, r28	; 61
     fd4:	fe 01       	movw	r30, r28
     fd6:	ed 5a       	subi	r30, 0xAD	; 173
     fd8:	ff 4f       	sbci	r31, 0xFF	; 255
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	a8 ef       	ldi	r26, 0xF8	; 248
     fe0:	b1 e4       	ldi	r27, 0x41	; 65
     fe2:	80 83       	st	Z, r24
     fe4:	91 83       	std	Z+1, r25	; 0x01
     fe6:	a2 83       	std	Z+2, r26	; 0x02
     fe8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
     fea:	8e 01       	movw	r16, r28
     fec:	01 5b       	subi	r16, 0xB1	; 177
     fee:	1f 4f       	sbci	r17, 0xFF	; 255
     ff0:	fe 01       	movw	r30, r28
     ff2:	ed 5a       	subi	r30, 0xAD	; 173
     ff4:	ff 4f       	sbci	r31, 0xFF	; 255
     ff6:	60 81       	ld	r22, Z
     ff8:	71 81       	ldd	r23, Z+1	; 0x01
     ffa:	82 81       	ldd	r24, Z+2	; 0x02
     ffc:	93 81       	ldd	r25, Z+3	; 0x03
     ffe:	2b ea       	ldi	r18, 0xAB	; 171
    1000:	3a ea       	ldi	r19, 0xAA	; 170
    1002:	4a e2       	ldi	r20, 0x2A	; 42
    1004:	50 e4       	ldi	r21, 0x40	; 64
    1006:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    100a:	dc 01       	movw	r26, r24
    100c:	cb 01       	movw	r24, r22
    100e:	f8 01       	movw	r30, r16
    1010:	80 83       	st	Z, r24
    1012:	91 83       	std	Z+1, r25	; 0x01
    1014:	a2 83       	std	Z+2, r26	; 0x02
    1016:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1018:	fe 01       	movw	r30, r28
    101a:	e1 5b       	subi	r30, 0xB1	; 177
    101c:	ff 4f       	sbci	r31, 0xFF	; 255
    101e:	60 81       	ld	r22, Z
    1020:	71 81       	ldd	r23, Z+1	; 0x01
    1022:	82 81       	ldd	r24, Z+2	; 0x02
    1024:	93 81       	ldd	r25, Z+3	; 0x03
    1026:	20 e0       	ldi	r18, 0x00	; 0
    1028:	30 e0       	ldi	r19, 0x00	; 0
    102a:	40 e8       	ldi	r20, 0x80	; 128
    102c:	5f e3       	ldi	r21, 0x3F	; 63
    102e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1032:	88 23       	and	r24, r24
    1034:	34 f4       	brge	.+12     	; 0x1042 <HLCD_voidINIT+0x88>
		__ticks = 1;
    1036:	fe 01       	movw	r30, r28
    1038:	e2 5b       	subi	r30, 0xB2	; 178
    103a:	ff 4f       	sbci	r31, 0xFF	; 255
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	80 83       	st	Z, r24
    1040:	e0 c0       	rjmp	.+448    	; 0x1202 <HLCD_voidINIT+0x248>
	else if (__tmp > 255)
    1042:	fe 01       	movw	r30, r28
    1044:	e1 5b       	subi	r30, 0xB1	; 177
    1046:	ff 4f       	sbci	r31, 0xFF	; 255
    1048:	60 81       	ld	r22, Z
    104a:	71 81       	ldd	r23, Z+1	; 0x01
    104c:	82 81       	ldd	r24, Z+2	; 0x02
    104e:	93 81       	ldd	r25, Z+3	; 0x03
    1050:	20 e0       	ldi	r18, 0x00	; 0
    1052:	30 e0       	ldi	r19, 0x00	; 0
    1054:	4f e7       	ldi	r20, 0x7F	; 127
    1056:	53 e4       	ldi	r21, 0x43	; 67
    1058:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    105c:	18 16       	cp	r1, r24
    105e:	0c f0       	brlt	.+2      	; 0x1062 <HLCD_voidINIT+0xa8>
    1060:	c0 c0       	rjmp	.+384    	; 0x11e2 <HLCD_voidINIT+0x228>
	{
		_delay_ms(__us / 1000.0);
    1062:	fe 01       	movw	r30, r28
    1064:	ed 5a       	subi	r30, 0xAD	; 173
    1066:	ff 4f       	sbci	r31, 0xFF	; 255
    1068:	60 81       	ld	r22, Z
    106a:	71 81       	ldd	r23, Z+1	; 0x01
    106c:	82 81       	ldd	r24, Z+2	; 0x02
    106e:	93 81       	ldd	r25, Z+3	; 0x03
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	4a e7       	ldi	r20, 0x7A	; 122
    1076:	54 e4       	ldi	r21, 0x44	; 68
    1078:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    107c:	dc 01       	movw	r26, r24
    107e:	cb 01       	movw	r24, r22
    1080:	fe 01       	movw	r30, r28
    1082:	e6 5b       	subi	r30, 0xB6	; 182
    1084:	ff 4f       	sbci	r31, 0xFF	; 255
    1086:	80 83       	st	Z, r24
    1088:	91 83       	std	Z+1, r25	; 0x01
    108a:	a2 83       	std	Z+2, r26	; 0x02
    108c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    108e:	8e 01       	movw	r16, r28
    1090:	0a 5b       	subi	r16, 0xBA	; 186
    1092:	1f 4f       	sbci	r17, 0xFF	; 255
    1094:	fe 01       	movw	r30, r28
    1096:	e6 5b       	subi	r30, 0xB6	; 182
    1098:	ff 4f       	sbci	r31, 0xFF	; 255
    109a:	60 81       	ld	r22, Z
    109c:	71 81       	ldd	r23, Z+1	; 0x01
    109e:	82 81       	ldd	r24, Z+2	; 0x02
    10a0:	93 81       	ldd	r25, Z+3	; 0x03
    10a2:	20 e0       	ldi	r18, 0x00	; 0
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	4a ef       	ldi	r20, 0xFA	; 250
    10a8:	54 e4       	ldi	r21, 0x44	; 68
    10aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10ae:	dc 01       	movw	r26, r24
    10b0:	cb 01       	movw	r24, r22
    10b2:	f8 01       	movw	r30, r16
    10b4:	80 83       	st	Z, r24
    10b6:	91 83       	std	Z+1, r25	; 0x01
    10b8:	a2 83       	std	Z+2, r26	; 0x02
    10ba:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    10bc:	fe 01       	movw	r30, r28
    10be:	ea 5b       	subi	r30, 0xBA	; 186
    10c0:	ff 4f       	sbci	r31, 0xFF	; 255
    10c2:	60 81       	ld	r22, Z
    10c4:	71 81       	ldd	r23, Z+1	; 0x01
    10c6:	82 81       	ldd	r24, Z+2	; 0x02
    10c8:	93 81       	ldd	r25, Z+3	; 0x03
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	40 e8       	ldi	r20, 0x80	; 128
    10d0:	5f e3       	ldi	r21, 0x3F	; 63
    10d2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    10d6:	88 23       	and	r24, r24
    10d8:	44 f4       	brge	.+16     	; 0x10ea <HLCD_voidINIT+0x130>
		__ticks = 1;
    10da:	fe 01       	movw	r30, r28
    10dc:	ec 5b       	subi	r30, 0xBC	; 188
    10de:	ff 4f       	sbci	r31, 0xFF	; 255
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	91 83       	std	Z+1, r25	; 0x01
    10e6:	80 83       	st	Z, r24
    10e8:	64 c0       	rjmp	.+200    	; 0x11b2 <HLCD_voidINIT+0x1f8>
	else if (__tmp > 65535)
    10ea:	fe 01       	movw	r30, r28
    10ec:	ea 5b       	subi	r30, 0xBA	; 186
    10ee:	ff 4f       	sbci	r31, 0xFF	; 255
    10f0:	60 81       	ld	r22, Z
    10f2:	71 81       	ldd	r23, Z+1	; 0x01
    10f4:	82 81       	ldd	r24, Z+2	; 0x02
    10f6:	93 81       	ldd	r25, Z+3	; 0x03
    10f8:	20 e0       	ldi	r18, 0x00	; 0
    10fa:	3f ef       	ldi	r19, 0xFF	; 255
    10fc:	4f e7       	ldi	r20, 0x7F	; 127
    10fe:	57 e4       	ldi	r21, 0x47	; 71
    1100:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1104:	18 16       	cp	r1, r24
    1106:	0c f0       	brlt	.+2      	; 0x110a <HLCD_voidINIT+0x150>
    1108:	43 c0       	rjmp	.+134    	; 0x1190 <HLCD_voidINIT+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    110a:	fe 01       	movw	r30, r28
    110c:	e6 5b       	subi	r30, 0xB6	; 182
    110e:	ff 4f       	sbci	r31, 0xFF	; 255
    1110:	60 81       	ld	r22, Z
    1112:	71 81       	ldd	r23, Z+1	; 0x01
    1114:	82 81       	ldd	r24, Z+2	; 0x02
    1116:	93 81       	ldd	r25, Z+3	; 0x03
    1118:	20 e0       	ldi	r18, 0x00	; 0
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	40 e2       	ldi	r20, 0x20	; 32
    111e:	51 e4       	ldi	r21, 0x41	; 65
    1120:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1124:	dc 01       	movw	r26, r24
    1126:	cb 01       	movw	r24, r22
    1128:	8e 01       	movw	r16, r28
    112a:	0c 5b       	subi	r16, 0xBC	; 188
    112c:	1f 4f       	sbci	r17, 0xFF	; 255
    112e:	bc 01       	movw	r22, r24
    1130:	cd 01       	movw	r24, r26
    1132:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1136:	dc 01       	movw	r26, r24
    1138:	cb 01       	movw	r24, r22
    113a:	f8 01       	movw	r30, r16
    113c:	91 83       	std	Z+1, r25	; 0x01
    113e:	80 83       	st	Z, r24
    1140:	1f c0       	rjmp	.+62     	; 0x1180 <HLCD_voidINIT+0x1c6>
    1142:	fe 01       	movw	r30, r28
    1144:	ee 5b       	subi	r30, 0xBE	; 190
    1146:	ff 4f       	sbci	r31, 0xFF	; 255
    1148:	88 ec       	ldi	r24, 0xC8	; 200
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	91 83       	std	Z+1, r25	; 0x01
    114e:	80 83       	st	Z, r24
    1150:	fe 01       	movw	r30, r28
    1152:	ee 5b       	subi	r30, 0xBE	; 190
    1154:	ff 4f       	sbci	r31, 0xFF	; 255
    1156:	80 81       	ld	r24, Z
    1158:	91 81       	ldd	r25, Z+1	; 0x01
    115a:	01 97       	sbiw	r24, 0x01	; 1
    115c:	f1 f7       	brne	.-4      	; 0x115a <HLCD_voidINIT+0x1a0>
    115e:	fe 01       	movw	r30, r28
    1160:	ee 5b       	subi	r30, 0xBE	; 190
    1162:	ff 4f       	sbci	r31, 0xFF	; 255
    1164:	91 83       	std	Z+1, r25	; 0x01
    1166:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1168:	de 01       	movw	r26, r28
    116a:	ac 5b       	subi	r26, 0xBC	; 188
    116c:	bf 4f       	sbci	r27, 0xFF	; 255
    116e:	fe 01       	movw	r30, r28
    1170:	ec 5b       	subi	r30, 0xBC	; 188
    1172:	ff 4f       	sbci	r31, 0xFF	; 255
    1174:	80 81       	ld	r24, Z
    1176:	91 81       	ldd	r25, Z+1	; 0x01
    1178:	01 97       	sbiw	r24, 0x01	; 1
    117a:	11 96       	adiw	r26, 0x01	; 1
    117c:	9c 93       	st	X, r25
    117e:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1180:	fe 01       	movw	r30, r28
    1182:	ec 5b       	subi	r30, 0xBC	; 188
    1184:	ff 4f       	sbci	r31, 0xFF	; 255
    1186:	80 81       	ld	r24, Z
    1188:	91 81       	ldd	r25, Z+1	; 0x01
    118a:	00 97       	sbiw	r24, 0x00	; 0
    118c:	d1 f6       	brne	.-76     	; 0x1142 <HLCD_voidINIT+0x188>
    118e:	42 c0       	rjmp	.+132    	; 0x1214 <HLCD_voidINIT+0x25a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1190:	8e 01       	movw	r16, r28
    1192:	0c 5b       	subi	r16, 0xBC	; 188
    1194:	1f 4f       	sbci	r17, 0xFF	; 255
    1196:	fe 01       	movw	r30, r28
    1198:	ea 5b       	subi	r30, 0xBA	; 186
    119a:	ff 4f       	sbci	r31, 0xFF	; 255
    119c:	60 81       	ld	r22, Z
    119e:	71 81       	ldd	r23, Z+1	; 0x01
    11a0:	82 81       	ldd	r24, Z+2	; 0x02
    11a2:	93 81       	ldd	r25, Z+3	; 0x03
    11a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11a8:	dc 01       	movw	r26, r24
    11aa:	cb 01       	movw	r24, r22
    11ac:	f8 01       	movw	r30, r16
    11ae:	91 83       	std	Z+1, r25	; 0x01
    11b0:	80 83       	st	Z, r24
    11b2:	de 01       	movw	r26, r28
    11b4:	a0 5c       	subi	r26, 0xC0	; 192
    11b6:	bf 4f       	sbci	r27, 0xFF	; 255
    11b8:	fe 01       	movw	r30, r28
    11ba:	ec 5b       	subi	r30, 0xBC	; 188
    11bc:	ff 4f       	sbci	r31, 0xFF	; 255
    11be:	80 81       	ld	r24, Z
    11c0:	91 81       	ldd	r25, Z+1	; 0x01
    11c2:	11 96       	adiw	r26, 0x01	; 1
    11c4:	9c 93       	st	X, r25
    11c6:	8e 93       	st	-X, r24
    11c8:	fe 01       	movw	r30, r28
    11ca:	e0 5c       	subi	r30, 0xC0	; 192
    11cc:	ff 4f       	sbci	r31, 0xFF	; 255
    11ce:	80 81       	ld	r24, Z
    11d0:	91 81       	ldd	r25, Z+1	; 0x01
    11d2:	01 97       	sbiw	r24, 0x01	; 1
    11d4:	f1 f7       	brne	.-4      	; 0x11d2 <HLCD_voidINIT+0x218>
    11d6:	fe 01       	movw	r30, r28
    11d8:	e0 5c       	subi	r30, 0xC0	; 192
    11da:	ff 4f       	sbci	r31, 0xFF	; 255
    11dc:	91 83       	std	Z+1, r25	; 0x01
    11de:	80 83       	st	Z, r24
    11e0:	19 c0       	rjmp	.+50     	; 0x1214 <HLCD_voidINIT+0x25a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    11e2:	8e 01       	movw	r16, r28
    11e4:	02 5b       	subi	r16, 0xB2	; 178
    11e6:	1f 4f       	sbci	r17, 0xFF	; 255
    11e8:	fe 01       	movw	r30, r28
    11ea:	e1 5b       	subi	r30, 0xB1	; 177
    11ec:	ff 4f       	sbci	r31, 0xFF	; 255
    11ee:	60 81       	ld	r22, Z
    11f0:	71 81       	ldd	r23, Z+1	; 0x01
    11f2:	82 81       	ldd	r24, Z+2	; 0x02
    11f4:	93 81       	ldd	r25, Z+3	; 0x03
    11f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11fa:	dc 01       	movw	r26, r24
    11fc:	cb 01       	movw	r24, r22
    11fe:	f8 01       	movw	r30, r16
    1200:	80 83       	st	Z, r24
    1202:	fe 01       	movw	r30, r28
    1204:	e2 5b       	subi	r30, 0xB2	; 178
    1206:	ff 4f       	sbci	r31, 0xFF	; 255
    1208:	80 81       	ld	r24, Z
    120a:	8f af       	std	Y+63, r24	; 0x3f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    120c:	8f ad       	ldd	r24, Y+63	; 0x3f
    120e:	8a 95       	dec	r24
    1210:	f1 f7       	brne	.-4      	; 0x120e <HLCD_voidINIT+0x254>
    1212:	8f af       	std	Y+63, r24	; 0x3f
	_delay_us(31);
	/*Function set command*/
	HLCD_u8SendCmnd(FunctionSet);
    1214:	88 e3       	ldi	r24, 0x38	; 56
    1216:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
    121a:	80 e0       	ldi	r24, 0x00	; 0
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	a0 e2       	ldi	r26, 0x20	; 32
    1220:	b2 e4       	ldi	r27, 0x42	; 66
    1222:	8b af       	std	Y+59, r24	; 0x3b
    1224:	9c af       	std	Y+60, r25	; 0x3c
    1226:	ad af       	std	Y+61, r26	; 0x3d
    1228:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    122a:	6b ad       	ldd	r22, Y+59	; 0x3b
    122c:	7c ad       	ldd	r23, Y+60	; 0x3c
    122e:	8d ad       	ldd	r24, Y+61	; 0x3d
    1230:	9e ad       	ldd	r25, Y+62	; 0x3e
    1232:	2b ea       	ldi	r18, 0xAB	; 171
    1234:	3a ea       	ldi	r19, 0xAA	; 170
    1236:	4a e2       	ldi	r20, 0x2A	; 42
    1238:	50 e4       	ldi	r21, 0x40	; 64
    123a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    123e:	dc 01       	movw	r26, r24
    1240:	cb 01       	movw	r24, r22
    1242:	8f ab       	std	Y+55, r24	; 0x37
    1244:	98 af       	std	Y+56, r25	; 0x38
    1246:	a9 af       	std	Y+57, r26	; 0x39
    1248:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    124a:	6f a9       	ldd	r22, Y+55	; 0x37
    124c:	78 ad       	ldd	r23, Y+56	; 0x38
    124e:	89 ad       	ldd	r24, Y+57	; 0x39
    1250:	9a ad       	ldd	r25, Y+58	; 0x3a
    1252:	20 e0       	ldi	r18, 0x00	; 0
    1254:	30 e0       	ldi	r19, 0x00	; 0
    1256:	40 e8       	ldi	r20, 0x80	; 128
    1258:	5f e3       	ldi	r21, 0x3F	; 63
    125a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    125e:	88 23       	and	r24, r24
    1260:	1c f4       	brge	.+6      	; 0x1268 <HLCD_voidINIT+0x2ae>
		__ticks = 1;
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	8e ab       	std	Y+54, r24	; 0x36
    1266:	91 c0       	rjmp	.+290    	; 0x138a <HLCD_voidINIT+0x3d0>
	else if (__tmp > 255)
    1268:	6f a9       	ldd	r22, Y+55	; 0x37
    126a:	78 ad       	ldd	r23, Y+56	; 0x38
    126c:	89 ad       	ldd	r24, Y+57	; 0x39
    126e:	9a ad       	ldd	r25, Y+58	; 0x3a
    1270:	20 e0       	ldi	r18, 0x00	; 0
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	4f e7       	ldi	r20, 0x7F	; 127
    1276:	53 e4       	ldi	r21, 0x43	; 67
    1278:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    127c:	18 16       	cp	r1, r24
    127e:	0c f0       	brlt	.+2      	; 0x1282 <HLCD_voidINIT+0x2c8>
    1280:	7b c0       	rjmp	.+246    	; 0x1378 <HLCD_voidINIT+0x3be>
	{
		_delay_ms(__us / 1000.0);
    1282:	6b ad       	ldd	r22, Y+59	; 0x3b
    1284:	7c ad       	ldd	r23, Y+60	; 0x3c
    1286:	8d ad       	ldd	r24, Y+61	; 0x3d
    1288:	9e ad       	ldd	r25, Y+62	; 0x3e
    128a:	20 e0       	ldi	r18, 0x00	; 0
    128c:	30 e0       	ldi	r19, 0x00	; 0
    128e:	4a e7       	ldi	r20, 0x7A	; 122
    1290:	54 e4       	ldi	r21, 0x44	; 68
    1292:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1296:	dc 01       	movw	r26, r24
    1298:	cb 01       	movw	r24, r22
    129a:	8a ab       	std	Y+50, r24	; 0x32
    129c:	9b ab       	std	Y+51, r25	; 0x33
    129e:	ac ab       	std	Y+52, r26	; 0x34
    12a0:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    12a2:	6a a9       	ldd	r22, Y+50	; 0x32
    12a4:	7b a9       	ldd	r23, Y+51	; 0x33
    12a6:	8c a9       	ldd	r24, Y+52	; 0x34
    12a8:	9d a9       	ldd	r25, Y+53	; 0x35
    12aa:	20 e0       	ldi	r18, 0x00	; 0
    12ac:	30 e0       	ldi	r19, 0x00	; 0
    12ae:	4a ef       	ldi	r20, 0xFA	; 250
    12b0:	54 e4       	ldi	r21, 0x44	; 68
    12b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12b6:	dc 01       	movw	r26, r24
    12b8:	cb 01       	movw	r24, r22
    12ba:	8e a7       	std	Y+46, r24	; 0x2e
    12bc:	9f a7       	std	Y+47, r25	; 0x2f
    12be:	a8 ab       	std	Y+48, r26	; 0x30
    12c0:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    12c2:	6e a5       	ldd	r22, Y+46	; 0x2e
    12c4:	7f a5       	ldd	r23, Y+47	; 0x2f
    12c6:	88 a9       	ldd	r24, Y+48	; 0x30
    12c8:	99 a9       	ldd	r25, Y+49	; 0x31
    12ca:	20 e0       	ldi	r18, 0x00	; 0
    12cc:	30 e0       	ldi	r19, 0x00	; 0
    12ce:	40 e8       	ldi	r20, 0x80	; 128
    12d0:	5f e3       	ldi	r21, 0x3F	; 63
    12d2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    12d6:	88 23       	and	r24, r24
    12d8:	2c f4       	brge	.+10     	; 0x12e4 <HLCD_voidINIT+0x32a>
		__ticks = 1;
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	9d a7       	std	Y+45, r25	; 0x2d
    12e0:	8c a7       	std	Y+44, r24	; 0x2c
    12e2:	3f c0       	rjmp	.+126    	; 0x1362 <HLCD_voidINIT+0x3a8>
	else if (__tmp > 65535)
    12e4:	6e a5       	ldd	r22, Y+46	; 0x2e
    12e6:	7f a5       	ldd	r23, Y+47	; 0x2f
    12e8:	88 a9       	ldd	r24, Y+48	; 0x30
    12ea:	99 a9       	ldd	r25, Y+49	; 0x31
    12ec:	20 e0       	ldi	r18, 0x00	; 0
    12ee:	3f ef       	ldi	r19, 0xFF	; 255
    12f0:	4f e7       	ldi	r20, 0x7F	; 127
    12f2:	57 e4       	ldi	r21, 0x47	; 71
    12f4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    12f8:	18 16       	cp	r1, r24
    12fa:	4c f5       	brge	.+82     	; 0x134e <HLCD_voidINIT+0x394>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    12fc:	6a a9       	ldd	r22, Y+50	; 0x32
    12fe:	7b a9       	ldd	r23, Y+51	; 0x33
    1300:	8c a9       	ldd	r24, Y+52	; 0x34
    1302:	9d a9       	ldd	r25, Y+53	; 0x35
    1304:	20 e0       	ldi	r18, 0x00	; 0
    1306:	30 e0       	ldi	r19, 0x00	; 0
    1308:	40 e2       	ldi	r20, 0x20	; 32
    130a:	51 e4       	ldi	r21, 0x41	; 65
    130c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1310:	dc 01       	movw	r26, r24
    1312:	cb 01       	movw	r24, r22
    1314:	bc 01       	movw	r22, r24
    1316:	cd 01       	movw	r24, r26
    1318:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    131c:	dc 01       	movw	r26, r24
    131e:	cb 01       	movw	r24, r22
    1320:	9d a7       	std	Y+45, r25	; 0x2d
    1322:	8c a7       	std	Y+44, r24	; 0x2c
    1324:	0f c0       	rjmp	.+30     	; 0x1344 <HLCD_voidINIT+0x38a>
    1326:	88 ec       	ldi	r24, 0xC8	; 200
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	9b a7       	std	Y+43, r25	; 0x2b
    132c:	8a a7       	std	Y+42, r24	; 0x2a
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    132e:	8a a5       	ldd	r24, Y+42	; 0x2a
    1330:	9b a5       	ldd	r25, Y+43	; 0x2b
    1332:	01 97       	sbiw	r24, 0x01	; 1
    1334:	f1 f7       	brne	.-4      	; 0x1332 <HLCD_voidINIT+0x378>
    1336:	9b a7       	std	Y+43, r25	; 0x2b
    1338:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    133a:	8c a5       	ldd	r24, Y+44	; 0x2c
    133c:	9d a5       	ldd	r25, Y+45	; 0x2d
    133e:	01 97       	sbiw	r24, 0x01	; 1
    1340:	9d a7       	std	Y+45, r25	; 0x2d
    1342:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1344:	8c a5       	ldd	r24, Y+44	; 0x2c
    1346:	9d a5       	ldd	r25, Y+45	; 0x2d
    1348:	00 97       	sbiw	r24, 0x00	; 0
    134a:	69 f7       	brne	.-38     	; 0x1326 <HLCD_voidINIT+0x36c>
    134c:	24 c0       	rjmp	.+72     	; 0x1396 <HLCD_voidINIT+0x3dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    134e:	6e a5       	ldd	r22, Y+46	; 0x2e
    1350:	7f a5       	ldd	r23, Y+47	; 0x2f
    1352:	88 a9       	ldd	r24, Y+48	; 0x30
    1354:	99 a9       	ldd	r25, Y+49	; 0x31
    1356:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    135a:	dc 01       	movw	r26, r24
    135c:	cb 01       	movw	r24, r22
    135e:	9d a7       	std	Y+45, r25	; 0x2d
    1360:	8c a7       	std	Y+44, r24	; 0x2c
    1362:	8c a5       	ldd	r24, Y+44	; 0x2c
    1364:	9d a5       	ldd	r25, Y+45	; 0x2d
    1366:	99 a7       	std	Y+41, r25	; 0x29
    1368:	88 a7       	std	Y+40, r24	; 0x28
    136a:	88 a5       	ldd	r24, Y+40	; 0x28
    136c:	99 a5       	ldd	r25, Y+41	; 0x29
    136e:	01 97       	sbiw	r24, 0x01	; 1
    1370:	f1 f7       	brne	.-4      	; 0x136e <HLCD_voidINIT+0x3b4>
    1372:	99 a7       	std	Y+41, r25	; 0x29
    1374:	88 a7       	std	Y+40, r24	; 0x28
    1376:	0f c0       	rjmp	.+30     	; 0x1396 <HLCD_voidINIT+0x3dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1378:	6f a9       	ldd	r22, Y+55	; 0x37
    137a:	78 ad       	ldd	r23, Y+56	; 0x38
    137c:	89 ad       	ldd	r24, Y+57	; 0x39
    137e:	9a ad       	ldd	r25, Y+58	; 0x3a
    1380:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1384:	dc 01       	movw	r26, r24
    1386:	cb 01       	movw	r24, r22
    1388:	8e ab       	std	Y+54, r24	; 0x36
    138a:	8e a9       	ldd	r24, Y+54	; 0x36
    138c:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    138e:	8f a1       	ldd	r24, Y+39	; 0x27
    1390:	8a 95       	dec	r24
    1392:	f1 f7       	brne	.-4      	; 0x1390 <HLCD_voidINIT+0x3d6>
    1394:	8f a3       	std	Y+39, r24	; 0x27
	_delay_us(40);
	/*Display on/off Control*/
	HLCD_u8SendCmnd(DisplayControl);
    1396:	8c e0       	ldi	r24, 0x0C	; 12
    1398:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
    139c:	80 e0       	ldi	r24, 0x00	; 0
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	a0 e2       	ldi	r26, 0x20	; 32
    13a2:	b2 e4       	ldi	r27, 0x42	; 66
    13a4:	8b a3       	std	Y+35, r24	; 0x23
    13a6:	9c a3       	std	Y+36, r25	; 0x24
    13a8:	ad a3       	std	Y+37, r26	; 0x25
    13aa:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    13ac:	6b a1       	ldd	r22, Y+35	; 0x23
    13ae:	7c a1       	ldd	r23, Y+36	; 0x24
    13b0:	8d a1       	ldd	r24, Y+37	; 0x25
    13b2:	9e a1       	ldd	r25, Y+38	; 0x26
    13b4:	2b ea       	ldi	r18, 0xAB	; 171
    13b6:	3a ea       	ldi	r19, 0xAA	; 170
    13b8:	4a e2       	ldi	r20, 0x2A	; 42
    13ba:	50 e4       	ldi	r21, 0x40	; 64
    13bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    13c0:	dc 01       	movw	r26, r24
    13c2:	cb 01       	movw	r24, r22
    13c4:	8f 8f       	std	Y+31, r24	; 0x1f
    13c6:	98 a3       	std	Y+32, r25	; 0x20
    13c8:	a9 a3       	std	Y+33, r26	; 0x21
    13ca:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    13cc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    13ce:	78 a1       	ldd	r23, Y+32	; 0x20
    13d0:	89 a1       	ldd	r24, Y+33	; 0x21
    13d2:	9a a1       	ldd	r25, Y+34	; 0x22
    13d4:	20 e0       	ldi	r18, 0x00	; 0
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	40 e8       	ldi	r20, 0x80	; 128
    13da:	5f e3       	ldi	r21, 0x3F	; 63
    13dc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    13e0:	88 23       	and	r24, r24
    13e2:	1c f4       	brge	.+6      	; 0x13ea <HLCD_voidINIT+0x430>
		__ticks = 1;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	8e 8f       	std	Y+30, r24	; 0x1e
    13e8:	91 c0       	rjmp	.+290    	; 0x150c <HLCD_voidINIT+0x552>
	else if (__tmp > 255)
    13ea:	6f 8d       	ldd	r22, Y+31	; 0x1f
    13ec:	78 a1       	ldd	r23, Y+32	; 0x20
    13ee:	89 a1       	ldd	r24, Y+33	; 0x21
    13f0:	9a a1       	ldd	r25, Y+34	; 0x22
    13f2:	20 e0       	ldi	r18, 0x00	; 0
    13f4:	30 e0       	ldi	r19, 0x00	; 0
    13f6:	4f e7       	ldi	r20, 0x7F	; 127
    13f8:	53 e4       	ldi	r21, 0x43	; 67
    13fa:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    13fe:	18 16       	cp	r1, r24
    1400:	0c f0       	brlt	.+2      	; 0x1404 <HLCD_voidINIT+0x44a>
    1402:	7b c0       	rjmp	.+246    	; 0x14fa <HLCD_voidINIT+0x540>
	{
		_delay_ms(__us / 1000.0);
    1404:	6b a1       	ldd	r22, Y+35	; 0x23
    1406:	7c a1       	ldd	r23, Y+36	; 0x24
    1408:	8d a1       	ldd	r24, Y+37	; 0x25
    140a:	9e a1       	ldd	r25, Y+38	; 0x26
    140c:	20 e0       	ldi	r18, 0x00	; 0
    140e:	30 e0       	ldi	r19, 0x00	; 0
    1410:	4a e7       	ldi	r20, 0x7A	; 122
    1412:	54 e4       	ldi	r21, 0x44	; 68
    1414:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1418:	dc 01       	movw	r26, r24
    141a:	cb 01       	movw	r24, r22
    141c:	8a 8f       	std	Y+26, r24	; 0x1a
    141e:	9b 8f       	std	Y+27, r25	; 0x1b
    1420:	ac 8f       	std	Y+28, r26	; 0x1c
    1422:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1424:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1426:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1428:	8c 8d       	ldd	r24, Y+28	; 0x1c
    142a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    142c:	20 e0       	ldi	r18, 0x00	; 0
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	4a ef       	ldi	r20, 0xFA	; 250
    1432:	54 e4       	ldi	r21, 0x44	; 68
    1434:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1438:	dc 01       	movw	r26, r24
    143a:	cb 01       	movw	r24, r22
    143c:	8e 8b       	std	Y+22, r24	; 0x16
    143e:	9f 8b       	std	Y+23, r25	; 0x17
    1440:	a8 8f       	std	Y+24, r26	; 0x18
    1442:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    1444:	6e 89       	ldd	r22, Y+22	; 0x16
    1446:	7f 89       	ldd	r23, Y+23	; 0x17
    1448:	88 8d       	ldd	r24, Y+24	; 0x18
    144a:	99 8d       	ldd	r25, Y+25	; 0x19
    144c:	20 e0       	ldi	r18, 0x00	; 0
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	40 e8       	ldi	r20, 0x80	; 128
    1452:	5f e3       	ldi	r21, 0x3F	; 63
    1454:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1458:	88 23       	and	r24, r24
    145a:	2c f4       	brge	.+10     	; 0x1466 <HLCD_voidINIT+0x4ac>
		__ticks = 1;
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	9d 8b       	std	Y+21, r25	; 0x15
    1462:	8c 8b       	std	Y+20, r24	; 0x14
    1464:	3f c0       	rjmp	.+126    	; 0x14e4 <HLCD_voidINIT+0x52a>
	else if (__tmp > 65535)
    1466:	6e 89       	ldd	r22, Y+22	; 0x16
    1468:	7f 89       	ldd	r23, Y+23	; 0x17
    146a:	88 8d       	ldd	r24, Y+24	; 0x18
    146c:	99 8d       	ldd	r25, Y+25	; 0x19
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	3f ef       	ldi	r19, 0xFF	; 255
    1472:	4f e7       	ldi	r20, 0x7F	; 127
    1474:	57 e4       	ldi	r21, 0x47	; 71
    1476:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    147a:	18 16       	cp	r1, r24
    147c:	4c f5       	brge	.+82     	; 0x14d0 <HLCD_voidINIT+0x516>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    147e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1480:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1482:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1484:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1486:	20 e0       	ldi	r18, 0x00	; 0
    1488:	30 e0       	ldi	r19, 0x00	; 0
    148a:	40 e2       	ldi	r20, 0x20	; 32
    148c:	51 e4       	ldi	r21, 0x41	; 65
    148e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1492:	dc 01       	movw	r26, r24
    1494:	cb 01       	movw	r24, r22
    1496:	bc 01       	movw	r22, r24
    1498:	cd 01       	movw	r24, r26
    149a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    149e:	dc 01       	movw	r26, r24
    14a0:	cb 01       	movw	r24, r22
    14a2:	9d 8b       	std	Y+21, r25	; 0x15
    14a4:	8c 8b       	std	Y+20, r24	; 0x14
    14a6:	0f c0       	rjmp	.+30     	; 0x14c6 <HLCD_voidINIT+0x50c>
    14a8:	88 ec       	ldi	r24, 0xC8	; 200
    14aa:	90 e0       	ldi	r25, 0x00	; 0
    14ac:	9b 8b       	std	Y+19, r25	; 0x13
    14ae:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    14b0:	8a 89       	ldd	r24, Y+18	; 0x12
    14b2:	9b 89       	ldd	r25, Y+19	; 0x13
    14b4:	01 97       	sbiw	r24, 0x01	; 1
    14b6:	f1 f7       	brne	.-4      	; 0x14b4 <HLCD_voidINIT+0x4fa>
    14b8:	9b 8b       	std	Y+19, r25	; 0x13
    14ba:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14bc:	8c 89       	ldd	r24, Y+20	; 0x14
    14be:	9d 89       	ldd	r25, Y+21	; 0x15
    14c0:	01 97       	sbiw	r24, 0x01	; 1
    14c2:	9d 8b       	std	Y+21, r25	; 0x15
    14c4:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14c6:	8c 89       	ldd	r24, Y+20	; 0x14
    14c8:	9d 89       	ldd	r25, Y+21	; 0x15
    14ca:	00 97       	sbiw	r24, 0x00	; 0
    14cc:	69 f7       	brne	.-38     	; 0x14a8 <HLCD_voidINIT+0x4ee>
    14ce:	24 c0       	rjmp	.+72     	; 0x1518 <HLCD_voidINIT+0x55e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14d0:	6e 89       	ldd	r22, Y+22	; 0x16
    14d2:	7f 89       	ldd	r23, Y+23	; 0x17
    14d4:	88 8d       	ldd	r24, Y+24	; 0x18
    14d6:	99 8d       	ldd	r25, Y+25	; 0x19
    14d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14dc:	dc 01       	movw	r26, r24
    14de:	cb 01       	movw	r24, r22
    14e0:	9d 8b       	std	Y+21, r25	; 0x15
    14e2:	8c 8b       	std	Y+20, r24	; 0x14
    14e4:	8c 89       	ldd	r24, Y+20	; 0x14
    14e6:	9d 89       	ldd	r25, Y+21	; 0x15
    14e8:	99 8b       	std	Y+17, r25	; 0x11
    14ea:	88 8b       	std	Y+16, r24	; 0x10
    14ec:	88 89       	ldd	r24, Y+16	; 0x10
    14ee:	99 89       	ldd	r25, Y+17	; 0x11
    14f0:	01 97       	sbiw	r24, 0x01	; 1
    14f2:	f1 f7       	brne	.-4      	; 0x14f0 <HLCD_voidINIT+0x536>
    14f4:	99 8b       	std	Y+17, r25	; 0x11
    14f6:	88 8b       	std	Y+16, r24	; 0x10
    14f8:	0f c0       	rjmp	.+30     	; 0x1518 <HLCD_voidINIT+0x55e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    14fa:	6f 8d       	ldd	r22, Y+31	; 0x1f
    14fc:	78 a1       	ldd	r23, Y+32	; 0x20
    14fe:	89 a1       	ldd	r24, Y+33	; 0x21
    1500:	9a a1       	ldd	r25, Y+34	; 0x22
    1502:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1506:	dc 01       	movw	r26, r24
    1508:	cb 01       	movw	r24, r22
    150a:	8e 8f       	std	Y+30, r24	; 0x1e
    150c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    150e:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1510:	8f 85       	ldd	r24, Y+15	; 0x0f
    1512:	8a 95       	dec	r24
    1514:	f1 f7       	brne	.-4      	; 0x1512 <HLCD_voidINIT+0x558>
    1516:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_us(40);
	/*Display Clear*/
	HLCD_u8SendCmnd(DisplayClear);
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
    151e:	80 e0       	ldi	r24, 0x00	; 0
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	a0 e0       	ldi	r26, 0x00	; 0
    1524:	b0 e4       	ldi	r27, 0x40	; 64
    1526:	8b 87       	std	Y+11, r24	; 0x0b
    1528:	9c 87       	std	Y+12, r25	; 0x0c
    152a:	ad 87       	std	Y+13, r26	; 0x0d
    152c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    152e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1530:	7c 85       	ldd	r23, Y+12	; 0x0c
    1532:	8d 85       	ldd	r24, Y+13	; 0x0d
    1534:	9e 85       	ldd	r25, Y+14	; 0x0e
    1536:	20 e0       	ldi	r18, 0x00	; 0
    1538:	30 e0       	ldi	r19, 0x00	; 0
    153a:	4a ef       	ldi	r20, 0xFA	; 250
    153c:	54 e4       	ldi	r21, 0x44	; 68
    153e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1542:	dc 01       	movw	r26, r24
    1544:	cb 01       	movw	r24, r22
    1546:	8f 83       	std	Y+7, r24	; 0x07
    1548:	98 87       	std	Y+8, r25	; 0x08
    154a:	a9 87       	std	Y+9, r26	; 0x09
    154c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    154e:	6f 81       	ldd	r22, Y+7	; 0x07
    1550:	78 85       	ldd	r23, Y+8	; 0x08
    1552:	89 85       	ldd	r24, Y+9	; 0x09
    1554:	9a 85       	ldd	r25, Y+10	; 0x0a
    1556:	20 e0       	ldi	r18, 0x00	; 0
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	40 e8       	ldi	r20, 0x80	; 128
    155c:	5f e3       	ldi	r21, 0x3F	; 63
    155e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1562:	88 23       	and	r24, r24
    1564:	2c f4       	brge	.+10     	; 0x1570 <HLCD_voidINIT+0x5b6>
		__ticks = 1;
    1566:	81 e0       	ldi	r24, 0x01	; 1
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	9e 83       	std	Y+6, r25	; 0x06
    156c:	8d 83       	std	Y+5, r24	; 0x05
    156e:	3f c0       	rjmp	.+126    	; 0x15ee <HLCD_voidINIT+0x634>
	else if (__tmp > 65535)
    1570:	6f 81       	ldd	r22, Y+7	; 0x07
    1572:	78 85       	ldd	r23, Y+8	; 0x08
    1574:	89 85       	ldd	r24, Y+9	; 0x09
    1576:	9a 85       	ldd	r25, Y+10	; 0x0a
    1578:	20 e0       	ldi	r18, 0x00	; 0
    157a:	3f ef       	ldi	r19, 0xFF	; 255
    157c:	4f e7       	ldi	r20, 0x7F	; 127
    157e:	57 e4       	ldi	r21, 0x47	; 71
    1580:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1584:	18 16       	cp	r1, r24
    1586:	4c f5       	brge	.+82     	; 0x15da <HLCD_voidINIT+0x620>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1588:	6b 85       	ldd	r22, Y+11	; 0x0b
    158a:	7c 85       	ldd	r23, Y+12	; 0x0c
    158c:	8d 85       	ldd	r24, Y+13	; 0x0d
    158e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1590:	20 e0       	ldi	r18, 0x00	; 0
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	40 e2       	ldi	r20, 0x20	; 32
    1596:	51 e4       	ldi	r21, 0x41	; 65
    1598:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    159c:	dc 01       	movw	r26, r24
    159e:	cb 01       	movw	r24, r22
    15a0:	bc 01       	movw	r22, r24
    15a2:	cd 01       	movw	r24, r26
    15a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15a8:	dc 01       	movw	r26, r24
    15aa:	cb 01       	movw	r24, r22
    15ac:	9e 83       	std	Y+6, r25	; 0x06
    15ae:	8d 83       	std	Y+5, r24	; 0x05
    15b0:	0f c0       	rjmp	.+30     	; 0x15d0 <HLCD_voidINIT+0x616>
    15b2:	88 ec       	ldi	r24, 0xC8	; 200
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	9c 83       	std	Y+4, r25	; 0x04
    15b8:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    15ba:	8b 81       	ldd	r24, Y+3	; 0x03
    15bc:	9c 81       	ldd	r25, Y+4	; 0x04
    15be:	01 97       	sbiw	r24, 0x01	; 1
    15c0:	f1 f7       	brne	.-4      	; 0x15be <HLCD_voidINIT+0x604>
    15c2:	9c 83       	std	Y+4, r25	; 0x04
    15c4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15c6:	8d 81       	ldd	r24, Y+5	; 0x05
    15c8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ca:	01 97       	sbiw	r24, 0x01	; 1
    15cc:	9e 83       	std	Y+6, r25	; 0x06
    15ce:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15d0:	8d 81       	ldd	r24, Y+5	; 0x05
    15d2:	9e 81       	ldd	r25, Y+6	; 0x06
    15d4:	00 97       	sbiw	r24, 0x00	; 0
    15d6:	69 f7       	brne	.-38     	; 0x15b2 <HLCD_voidINIT+0x5f8>
    15d8:	14 c0       	rjmp	.+40     	; 0x1602 <HLCD_voidINIT+0x648>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15da:	6f 81       	ldd	r22, Y+7	; 0x07
    15dc:	78 85       	ldd	r23, Y+8	; 0x08
    15de:	89 85       	ldd	r24, Y+9	; 0x09
    15e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    15e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15e6:	dc 01       	movw	r26, r24
    15e8:	cb 01       	movw	r24, r22
    15ea:	9e 83       	std	Y+6, r25	; 0x06
    15ec:	8d 83       	std	Y+5, r24	; 0x05
    15ee:	8d 81       	ldd	r24, Y+5	; 0x05
    15f0:	9e 81       	ldd	r25, Y+6	; 0x06
    15f2:	9a 83       	std	Y+2, r25	; 0x02
    15f4:	89 83       	std	Y+1, r24	; 0x01
    15f6:	89 81       	ldd	r24, Y+1	; 0x01
    15f8:	9a 81       	ldd	r25, Y+2	; 0x02
    15fa:	01 97       	sbiw	r24, 0x01	; 1
    15fc:	f1 f7       	brne	.-4      	; 0x15fa <HLCD_voidINIT+0x640>
    15fe:	9a 83       	std	Y+2, r25	; 0x02
    1600:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*Entry Mode Set*/
	HLCD_u8SendCmnd(EntryMode);
    1602:	86 e0       	ldi	r24, 0x06	; 6
    1604:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
}
    1608:	ca 5a       	subi	r28, 0xAA	; 170
    160a:	df 4f       	sbci	r29, 0xFF	; 255
    160c:	0f b6       	in	r0, 0x3f	; 63
    160e:	f8 94       	cli
    1610:	de bf       	out	0x3e, r29	; 62
    1612:	0f be       	out	0x3f, r0	; 63
    1614:	cd bf       	out	0x3d, r28	; 61
    1616:	cf 91       	pop	r28
    1618:	df 91       	pop	r29
    161a:	1f 91       	pop	r17
    161c:	0f 91       	pop	r16
    161e:	08 95       	ret

00001620 <HLCD_u8SendCmnd>:

u8 HLCD_u8SendCmnd(u8 Copy_u8Cmnd)
{
    1620:	df 93       	push	r29
    1622:	cf 93       	push	r28
    1624:	cd b7       	in	r28, 0x3d	; 61
    1626:	de b7       	in	r29, 0x3e	; 62
    1628:	6a 97       	sbiw	r28, 0x1a	; 26
    162a:	0f b6       	in	r0, 0x3f	; 63
    162c:	f8 94       	cli
    162e:	de bf       	out	0x3e, r29	; 62
    1630:	0f be       	out	0x3f, r0	; 63
    1632:	cd bf       	out	0x3d, r28	; 61
    1634:	8a 8f       	std	Y+26, r24	; 0x1a
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1636:	81 e0       	ldi	r24, 0x01	; 1
    1638:	89 8f       	std	Y+25, r24	; 0x19
	/*1- set Rs pin=> Low (command)*/
	MDIO_u8SetPinValue(HLCD_u8_RS_PORT,HLCD_u8_RS_PIN,MDIO_u8_LOW);
    163a:	82 e0       	ldi	r24, 0x02	; 2
    163c:	60 e0       	ldi	r22, 0x00	; 0
    163e:	40 e0       	ldi	r20, 0x00	; 0
    1640:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
	/*2- set Rw pin=>low (write)*/
	MDIO_u8SetPinValue(HLCD_u8_RW_PORT,HLCD_u8_RW_PIN,MDIO_u8_LOW);
    1644:	82 e0       	ldi	r24, 0x02	; 2
    1646:	61 e0       	ldi	r22, 0x01	; 1
    1648:	40 e0       	ldi	r20, 0x00	; 0
    164a:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
	/*3- send command to LCD on data Pins*/
	MDIO_u8SetPortValue(HCLD_u8_DATA_PORT,Copy_u8Cmnd);
    164e:	83 e0       	ldi	r24, 0x03	; 3
    1650:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1652:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <MDIO_u8SetPortValue>
	/*4- set Enable pulse*/
	MDIO_u8SetPinValue(HLCD_u8_EN_PORT,HLCD_u8_EN_PIN,MDIO_u8_HIGH);
    1656:	82 e0       	ldi	r24, 0x02	; 2
    1658:	62 e0       	ldi	r22, 0x02	; 2
    165a:	41 e0       	ldi	r20, 0x01	; 1
    165c:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
    1660:	80 e0       	ldi	r24, 0x00	; 0
    1662:	90 e0       	ldi	r25, 0x00	; 0
    1664:	a0 e8       	ldi	r26, 0x80	; 128
    1666:	bf e3       	ldi	r27, 0x3F	; 63
    1668:	8d 8b       	std	Y+21, r24	; 0x15
    166a:	9e 8b       	std	Y+22, r25	; 0x16
    166c:	af 8b       	std	Y+23, r26	; 0x17
    166e:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1670:	6d 89       	ldd	r22, Y+21	; 0x15
    1672:	7e 89       	ldd	r23, Y+22	; 0x16
    1674:	8f 89       	ldd	r24, Y+23	; 0x17
    1676:	98 8d       	ldd	r25, Y+24	; 0x18
    1678:	2b ea       	ldi	r18, 0xAB	; 171
    167a:	3a ea       	ldi	r19, 0xAA	; 170
    167c:	4a e2       	ldi	r20, 0x2A	; 42
    167e:	50 e4       	ldi	r21, 0x40	; 64
    1680:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1684:	dc 01       	movw	r26, r24
    1686:	cb 01       	movw	r24, r22
    1688:	89 8b       	std	Y+17, r24	; 0x11
    168a:	9a 8b       	std	Y+18, r25	; 0x12
    168c:	ab 8b       	std	Y+19, r26	; 0x13
    168e:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1690:	69 89       	ldd	r22, Y+17	; 0x11
    1692:	7a 89       	ldd	r23, Y+18	; 0x12
    1694:	8b 89       	ldd	r24, Y+19	; 0x13
    1696:	9c 89       	ldd	r25, Y+20	; 0x14
    1698:	20 e0       	ldi	r18, 0x00	; 0
    169a:	30 e0       	ldi	r19, 0x00	; 0
    169c:	40 e8       	ldi	r20, 0x80	; 128
    169e:	5f e3       	ldi	r21, 0x3F	; 63
    16a0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    16a4:	88 23       	and	r24, r24
    16a6:	1c f4       	brge	.+6      	; 0x16ae <HLCD_u8SendCmnd+0x8e>
		__ticks = 1;
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	88 8b       	std	Y+16, r24	; 0x10
    16ac:	91 c0       	rjmp	.+290    	; 0x17d0 <HLCD_u8SendCmnd+0x1b0>
	else if (__tmp > 255)
    16ae:	69 89       	ldd	r22, Y+17	; 0x11
    16b0:	7a 89       	ldd	r23, Y+18	; 0x12
    16b2:	8b 89       	ldd	r24, Y+19	; 0x13
    16b4:	9c 89       	ldd	r25, Y+20	; 0x14
    16b6:	20 e0       	ldi	r18, 0x00	; 0
    16b8:	30 e0       	ldi	r19, 0x00	; 0
    16ba:	4f e7       	ldi	r20, 0x7F	; 127
    16bc:	53 e4       	ldi	r21, 0x43	; 67
    16be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    16c2:	18 16       	cp	r1, r24
    16c4:	0c f0       	brlt	.+2      	; 0x16c8 <HLCD_u8SendCmnd+0xa8>
    16c6:	7b c0       	rjmp	.+246    	; 0x17be <HLCD_u8SendCmnd+0x19e>
	{
		_delay_ms(__us / 1000.0);
    16c8:	6d 89       	ldd	r22, Y+21	; 0x15
    16ca:	7e 89       	ldd	r23, Y+22	; 0x16
    16cc:	8f 89       	ldd	r24, Y+23	; 0x17
    16ce:	98 8d       	ldd	r25, Y+24	; 0x18
    16d0:	20 e0       	ldi	r18, 0x00	; 0
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	4a e7       	ldi	r20, 0x7A	; 122
    16d6:	54 e4       	ldi	r21, 0x44	; 68
    16d8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    16dc:	dc 01       	movw	r26, r24
    16de:	cb 01       	movw	r24, r22
    16e0:	8c 87       	std	Y+12, r24	; 0x0c
    16e2:	9d 87       	std	Y+13, r25	; 0x0d
    16e4:	ae 87       	std	Y+14, r26	; 0x0e
    16e6:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    16e8:	6c 85       	ldd	r22, Y+12	; 0x0c
    16ea:	7d 85       	ldd	r23, Y+13	; 0x0d
    16ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    16ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	4a ef       	ldi	r20, 0xFA	; 250
    16f6:	54 e4       	ldi	r21, 0x44	; 68
    16f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16fc:	dc 01       	movw	r26, r24
    16fe:	cb 01       	movw	r24, r22
    1700:	88 87       	std	Y+8, r24	; 0x08
    1702:	99 87       	std	Y+9, r25	; 0x09
    1704:	aa 87       	std	Y+10, r26	; 0x0a
    1706:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1708:	68 85       	ldd	r22, Y+8	; 0x08
    170a:	79 85       	ldd	r23, Y+9	; 0x09
    170c:	8a 85       	ldd	r24, Y+10	; 0x0a
    170e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	40 e8       	ldi	r20, 0x80	; 128
    1716:	5f e3       	ldi	r21, 0x3F	; 63
    1718:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    171c:	88 23       	and	r24, r24
    171e:	2c f4       	brge	.+10     	; 0x172a <HLCD_u8SendCmnd+0x10a>
		__ticks = 1;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	9f 83       	std	Y+7, r25	; 0x07
    1726:	8e 83       	std	Y+6, r24	; 0x06
    1728:	3f c0       	rjmp	.+126    	; 0x17a8 <HLCD_u8SendCmnd+0x188>
	else if (__tmp > 65535)
    172a:	68 85       	ldd	r22, Y+8	; 0x08
    172c:	79 85       	ldd	r23, Y+9	; 0x09
    172e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1730:	9b 85       	ldd	r25, Y+11	; 0x0b
    1732:	20 e0       	ldi	r18, 0x00	; 0
    1734:	3f ef       	ldi	r19, 0xFF	; 255
    1736:	4f e7       	ldi	r20, 0x7F	; 127
    1738:	57 e4       	ldi	r21, 0x47	; 71
    173a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    173e:	18 16       	cp	r1, r24
    1740:	4c f5       	brge	.+82     	; 0x1794 <HLCD_u8SendCmnd+0x174>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1742:	6c 85       	ldd	r22, Y+12	; 0x0c
    1744:	7d 85       	ldd	r23, Y+13	; 0x0d
    1746:	8e 85       	ldd	r24, Y+14	; 0x0e
    1748:	9f 85       	ldd	r25, Y+15	; 0x0f
    174a:	20 e0       	ldi	r18, 0x00	; 0
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	40 e2       	ldi	r20, 0x20	; 32
    1750:	51 e4       	ldi	r21, 0x41	; 65
    1752:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1756:	dc 01       	movw	r26, r24
    1758:	cb 01       	movw	r24, r22
    175a:	bc 01       	movw	r22, r24
    175c:	cd 01       	movw	r24, r26
    175e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1762:	dc 01       	movw	r26, r24
    1764:	cb 01       	movw	r24, r22
    1766:	9f 83       	std	Y+7, r25	; 0x07
    1768:	8e 83       	std	Y+6, r24	; 0x06
    176a:	0f c0       	rjmp	.+30     	; 0x178a <HLCD_u8SendCmnd+0x16a>
    176c:	88 ec       	ldi	r24, 0xC8	; 200
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	9d 83       	std	Y+5, r25	; 0x05
    1772:	8c 83       	std	Y+4, r24	; 0x04
    1774:	8c 81       	ldd	r24, Y+4	; 0x04
    1776:	9d 81       	ldd	r25, Y+5	; 0x05
    1778:	01 97       	sbiw	r24, 0x01	; 1
    177a:	f1 f7       	brne	.-4      	; 0x1778 <HLCD_u8SendCmnd+0x158>
    177c:	9d 83       	std	Y+5, r25	; 0x05
    177e:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1780:	8e 81       	ldd	r24, Y+6	; 0x06
    1782:	9f 81       	ldd	r25, Y+7	; 0x07
    1784:	01 97       	sbiw	r24, 0x01	; 1
    1786:	9f 83       	std	Y+7, r25	; 0x07
    1788:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    178a:	8e 81       	ldd	r24, Y+6	; 0x06
    178c:	9f 81       	ldd	r25, Y+7	; 0x07
    178e:	00 97       	sbiw	r24, 0x00	; 0
    1790:	69 f7       	brne	.-38     	; 0x176c <HLCD_u8SendCmnd+0x14c>
    1792:	24 c0       	rjmp	.+72     	; 0x17dc <HLCD_u8SendCmnd+0x1bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1794:	68 85       	ldd	r22, Y+8	; 0x08
    1796:	79 85       	ldd	r23, Y+9	; 0x09
    1798:	8a 85       	ldd	r24, Y+10	; 0x0a
    179a:	9b 85       	ldd	r25, Y+11	; 0x0b
    179c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17a0:	dc 01       	movw	r26, r24
    17a2:	cb 01       	movw	r24, r22
    17a4:	9f 83       	std	Y+7, r25	; 0x07
    17a6:	8e 83       	std	Y+6, r24	; 0x06
    17a8:	8e 81       	ldd	r24, Y+6	; 0x06
    17aa:	9f 81       	ldd	r25, Y+7	; 0x07
    17ac:	9b 83       	std	Y+3, r25	; 0x03
    17ae:	8a 83       	std	Y+2, r24	; 0x02
    17b0:	8a 81       	ldd	r24, Y+2	; 0x02
    17b2:	9b 81       	ldd	r25, Y+3	; 0x03
    17b4:	01 97       	sbiw	r24, 0x01	; 1
    17b6:	f1 f7       	brne	.-4      	; 0x17b4 <HLCD_u8SendCmnd+0x194>
    17b8:	9b 83       	std	Y+3, r25	; 0x03
    17ba:	8a 83       	std	Y+2, r24	; 0x02
    17bc:	0f c0       	rjmp	.+30     	; 0x17dc <HLCD_u8SendCmnd+0x1bc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    17be:	69 89       	ldd	r22, Y+17	; 0x11
    17c0:	7a 89       	ldd	r23, Y+18	; 0x12
    17c2:	8b 89       	ldd	r24, Y+19	; 0x13
    17c4:	9c 89       	ldd	r25, Y+20	; 0x14
    17c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17ca:	dc 01       	movw	r26, r24
    17cc:	cb 01       	movw	r24, r22
    17ce:	88 8b       	std	Y+16, r24	; 0x10
    17d0:	88 89       	ldd	r24, Y+16	; 0x10
    17d2:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    17d4:	89 81       	ldd	r24, Y+1	; 0x01
    17d6:	8a 95       	dec	r24
    17d8:	f1 f7       	brne	.-4      	; 0x17d6 <HLCD_u8SendCmnd+0x1b6>
    17da:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	MDIO_u8SetPinValue(HLCD_u8_EN_PORT,HLCD_u8_EN_PIN,MDIO_u8_LOW);
    17dc:	82 e0       	ldi	r24, 0x02	; 2
    17de:	62 e0       	ldi	r22, 0x02	; 2
    17e0:	40 e0       	ldi	r20, 0x00	; 0
    17e2:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
	return Local_u8ErrorState;
    17e6:	89 8d       	ldd	r24, Y+25	; 0x19
}
    17e8:	6a 96       	adiw	r28, 0x1a	; 26
    17ea:	0f b6       	in	r0, 0x3f	; 63
    17ec:	f8 94       	cli
    17ee:	de bf       	out	0x3e, r29	; 62
    17f0:	0f be       	out	0x3f, r0	; 63
    17f2:	cd bf       	out	0x3d, r28	; 61
    17f4:	cf 91       	pop	r28
    17f6:	df 91       	pop	r29
    17f8:	08 95       	ret

000017fa <HLCD_u8SendChar>:

u8 HLCD_u8SendChar (u8 Copy_u8Char)
{
    17fa:	df 93       	push	r29
    17fc:	cf 93       	push	r28
    17fe:	cd b7       	in	r28, 0x3d	; 61
    1800:	de b7       	in	r29, 0x3e	; 62
    1802:	6a 97       	sbiw	r28, 0x1a	; 26
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	cd bf       	out	0x3d, r28	; 61
    180e:	8a 8f       	std	Y+26, r24	; 0x1a
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	89 8f       	std	Y+25, r24	; 0x19
	/*1- set Rs pin=> Low (command)*/
	MDIO_u8SetPinValue(HLCD_u8_RS_PORT,HLCD_u8_RS_PIN,MDIO_u8_HIGH);
    1814:	82 e0       	ldi	r24, 0x02	; 2
    1816:	60 e0       	ldi	r22, 0x00	; 0
    1818:	41 e0       	ldi	r20, 0x01	; 1
    181a:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
	/*2- set Rw pin=>low (write)*/
	MDIO_u8SetPinValue(HLCD_u8_RW_PORT,HLCD_u8_RW_PIN,MDIO_u8_LOW);
    181e:	82 e0       	ldi	r24, 0x02	; 2
    1820:	61 e0       	ldi	r22, 0x01	; 1
    1822:	40 e0       	ldi	r20, 0x00	; 0
    1824:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
	/*3- send command to LCD on data Pins*/
	MDIO_u8SetPortValue(HCLD_u8_DATA_PORT,Copy_u8Char);
    1828:	83 e0       	ldi	r24, 0x03	; 3
    182a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    182c:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <MDIO_u8SetPortValue>
	/*4- set Enable pulse*/
	MDIO_u8SetPinValue(HLCD_u8_EN_PORT,HLCD_u8_EN_PIN,MDIO_u8_HIGH);
    1830:	82 e0       	ldi	r24, 0x02	; 2
    1832:	62 e0       	ldi	r22, 0x02	; 2
    1834:	41 e0       	ldi	r20, 0x01	; 1
    1836:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
    183a:	80 e0       	ldi	r24, 0x00	; 0
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	a0 e8       	ldi	r26, 0x80	; 128
    1840:	bf e3       	ldi	r27, 0x3F	; 63
    1842:	8d 8b       	std	Y+21, r24	; 0x15
    1844:	9e 8b       	std	Y+22, r25	; 0x16
    1846:	af 8b       	std	Y+23, r26	; 0x17
    1848:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    184a:	6d 89       	ldd	r22, Y+21	; 0x15
    184c:	7e 89       	ldd	r23, Y+22	; 0x16
    184e:	8f 89       	ldd	r24, Y+23	; 0x17
    1850:	98 8d       	ldd	r25, Y+24	; 0x18
    1852:	2b ea       	ldi	r18, 0xAB	; 171
    1854:	3a ea       	ldi	r19, 0xAA	; 170
    1856:	4a e2       	ldi	r20, 0x2A	; 42
    1858:	50 e4       	ldi	r21, 0x40	; 64
    185a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    185e:	dc 01       	movw	r26, r24
    1860:	cb 01       	movw	r24, r22
    1862:	89 8b       	std	Y+17, r24	; 0x11
    1864:	9a 8b       	std	Y+18, r25	; 0x12
    1866:	ab 8b       	std	Y+19, r26	; 0x13
    1868:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    186a:	69 89       	ldd	r22, Y+17	; 0x11
    186c:	7a 89       	ldd	r23, Y+18	; 0x12
    186e:	8b 89       	ldd	r24, Y+19	; 0x13
    1870:	9c 89       	ldd	r25, Y+20	; 0x14
    1872:	20 e0       	ldi	r18, 0x00	; 0
    1874:	30 e0       	ldi	r19, 0x00	; 0
    1876:	40 e8       	ldi	r20, 0x80	; 128
    1878:	5f e3       	ldi	r21, 0x3F	; 63
    187a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    187e:	88 23       	and	r24, r24
    1880:	1c f4       	brge	.+6      	; 0x1888 <HLCD_u8SendChar+0x8e>
		__ticks = 1;
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	88 8b       	std	Y+16, r24	; 0x10
    1886:	91 c0       	rjmp	.+290    	; 0x19aa <HLCD_u8SendChar+0x1b0>
	else if (__tmp > 255)
    1888:	69 89       	ldd	r22, Y+17	; 0x11
    188a:	7a 89       	ldd	r23, Y+18	; 0x12
    188c:	8b 89       	ldd	r24, Y+19	; 0x13
    188e:	9c 89       	ldd	r25, Y+20	; 0x14
    1890:	20 e0       	ldi	r18, 0x00	; 0
    1892:	30 e0       	ldi	r19, 0x00	; 0
    1894:	4f e7       	ldi	r20, 0x7F	; 127
    1896:	53 e4       	ldi	r21, 0x43	; 67
    1898:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    189c:	18 16       	cp	r1, r24
    189e:	0c f0       	brlt	.+2      	; 0x18a2 <HLCD_u8SendChar+0xa8>
    18a0:	7b c0       	rjmp	.+246    	; 0x1998 <HLCD_u8SendChar+0x19e>
	{
		_delay_ms(__us / 1000.0);
    18a2:	6d 89       	ldd	r22, Y+21	; 0x15
    18a4:	7e 89       	ldd	r23, Y+22	; 0x16
    18a6:	8f 89       	ldd	r24, Y+23	; 0x17
    18a8:	98 8d       	ldd	r25, Y+24	; 0x18
    18aa:	20 e0       	ldi	r18, 0x00	; 0
    18ac:	30 e0       	ldi	r19, 0x00	; 0
    18ae:	4a e7       	ldi	r20, 0x7A	; 122
    18b0:	54 e4       	ldi	r21, 0x44	; 68
    18b2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    18b6:	dc 01       	movw	r26, r24
    18b8:	cb 01       	movw	r24, r22
    18ba:	8c 87       	std	Y+12, r24	; 0x0c
    18bc:	9d 87       	std	Y+13, r25	; 0x0d
    18be:	ae 87       	std	Y+14, r26	; 0x0e
    18c0:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    18c2:	6c 85       	ldd	r22, Y+12	; 0x0c
    18c4:	7d 85       	ldd	r23, Y+13	; 0x0d
    18c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    18c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    18ca:	20 e0       	ldi	r18, 0x00	; 0
    18cc:	30 e0       	ldi	r19, 0x00	; 0
    18ce:	4a ef       	ldi	r20, 0xFA	; 250
    18d0:	54 e4       	ldi	r21, 0x44	; 68
    18d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18d6:	dc 01       	movw	r26, r24
    18d8:	cb 01       	movw	r24, r22
    18da:	88 87       	std	Y+8, r24	; 0x08
    18dc:	99 87       	std	Y+9, r25	; 0x09
    18de:	aa 87       	std	Y+10, r26	; 0x0a
    18e0:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    18e2:	68 85       	ldd	r22, Y+8	; 0x08
    18e4:	79 85       	ldd	r23, Y+9	; 0x09
    18e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    18e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    18ea:	20 e0       	ldi	r18, 0x00	; 0
    18ec:	30 e0       	ldi	r19, 0x00	; 0
    18ee:	40 e8       	ldi	r20, 0x80	; 128
    18f0:	5f e3       	ldi	r21, 0x3F	; 63
    18f2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    18f6:	88 23       	and	r24, r24
    18f8:	2c f4       	brge	.+10     	; 0x1904 <HLCD_u8SendChar+0x10a>
		__ticks = 1;
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	9f 83       	std	Y+7, r25	; 0x07
    1900:	8e 83       	std	Y+6, r24	; 0x06
    1902:	3f c0       	rjmp	.+126    	; 0x1982 <HLCD_u8SendChar+0x188>
	else if (__tmp > 65535)
    1904:	68 85       	ldd	r22, Y+8	; 0x08
    1906:	79 85       	ldd	r23, Y+9	; 0x09
    1908:	8a 85       	ldd	r24, Y+10	; 0x0a
    190a:	9b 85       	ldd	r25, Y+11	; 0x0b
    190c:	20 e0       	ldi	r18, 0x00	; 0
    190e:	3f ef       	ldi	r19, 0xFF	; 255
    1910:	4f e7       	ldi	r20, 0x7F	; 127
    1912:	57 e4       	ldi	r21, 0x47	; 71
    1914:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1918:	18 16       	cp	r1, r24
    191a:	4c f5       	brge	.+82     	; 0x196e <HLCD_u8SendChar+0x174>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    191c:	6c 85       	ldd	r22, Y+12	; 0x0c
    191e:	7d 85       	ldd	r23, Y+13	; 0x0d
    1920:	8e 85       	ldd	r24, Y+14	; 0x0e
    1922:	9f 85       	ldd	r25, Y+15	; 0x0f
    1924:	20 e0       	ldi	r18, 0x00	; 0
    1926:	30 e0       	ldi	r19, 0x00	; 0
    1928:	40 e2       	ldi	r20, 0x20	; 32
    192a:	51 e4       	ldi	r21, 0x41	; 65
    192c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1930:	dc 01       	movw	r26, r24
    1932:	cb 01       	movw	r24, r22
    1934:	bc 01       	movw	r22, r24
    1936:	cd 01       	movw	r24, r26
    1938:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    193c:	dc 01       	movw	r26, r24
    193e:	cb 01       	movw	r24, r22
    1940:	9f 83       	std	Y+7, r25	; 0x07
    1942:	8e 83       	std	Y+6, r24	; 0x06
    1944:	0f c0       	rjmp	.+30     	; 0x1964 <HLCD_u8SendChar+0x16a>
    1946:	88 ec       	ldi	r24, 0xC8	; 200
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	9d 83       	std	Y+5, r25	; 0x05
    194c:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    194e:	8c 81       	ldd	r24, Y+4	; 0x04
    1950:	9d 81       	ldd	r25, Y+5	; 0x05
    1952:	01 97       	sbiw	r24, 0x01	; 1
    1954:	f1 f7       	brne	.-4      	; 0x1952 <HLCD_u8SendChar+0x158>
    1956:	9d 83       	std	Y+5, r25	; 0x05
    1958:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    195a:	8e 81       	ldd	r24, Y+6	; 0x06
    195c:	9f 81       	ldd	r25, Y+7	; 0x07
    195e:	01 97       	sbiw	r24, 0x01	; 1
    1960:	9f 83       	std	Y+7, r25	; 0x07
    1962:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1964:	8e 81       	ldd	r24, Y+6	; 0x06
    1966:	9f 81       	ldd	r25, Y+7	; 0x07
    1968:	00 97       	sbiw	r24, 0x00	; 0
    196a:	69 f7       	brne	.-38     	; 0x1946 <HLCD_u8SendChar+0x14c>
    196c:	24 c0       	rjmp	.+72     	; 0x19b6 <HLCD_u8SendChar+0x1bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    196e:	68 85       	ldd	r22, Y+8	; 0x08
    1970:	79 85       	ldd	r23, Y+9	; 0x09
    1972:	8a 85       	ldd	r24, Y+10	; 0x0a
    1974:	9b 85       	ldd	r25, Y+11	; 0x0b
    1976:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    197a:	dc 01       	movw	r26, r24
    197c:	cb 01       	movw	r24, r22
    197e:	9f 83       	std	Y+7, r25	; 0x07
    1980:	8e 83       	std	Y+6, r24	; 0x06
    1982:	8e 81       	ldd	r24, Y+6	; 0x06
    1984:	9f 81       	ldd	r25, Y+7	; 0x07
    1986:	9b 83       	std	Y+3, r25	; 0x03
    1988:	8a 83       	std	Y+2, r24	; 0x02
    198a:	8a 81       	ldd	r24, Y+2	; 0x02
    198c:	9b 81       	ldd	r25, Y+3	; 0x03
    198e:	01 97       	sbiw	r24, 0x01	; 1
    1990:	f1 f7       	brne	.-4      	; 0x198e <HLCD_u8SendChar+0x194>
    1992:	9b 83       	std	Y+3, r25	; 0x03
    1994:	8a 83       	std	Y+2, r24	; 0x02
    1996:	0f c0       	rjmp	.+30     	; 0x19b6 <HLCD_u8SendChar+0x1bc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1998:	69 89       	ldd	r22, Y+17	; 0x11
    199a:	7a 89       	ldd	r23, Y+18	; 0x12
    199c:	8b 89       	ldd	r24, Y+19	; 0x13
    199e:	9c 89       	ldd	r25, Y+20	; 0x14
    19a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19a4:	dc 01       	movw	r26, r24
    19a6:	cb 01       	movw	r24, r22
    19a8:	88 8b       	std	Y+16, r24	; 0x10
    19aa:	88 89       	ldd	r24, Y+16	; 0x10
    19ac:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    19ae:	89 81       	ldd	r24, Y+1	; 0x01
    19b0:	8a 95       	dec	r24
    19b2:	f1 f7       	brne	.-4      	; 0x19b0 <HLCD_u8SendChar+0x1b6>
    19b4:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	MDIO_u8SetPinValue(HLCD_u8_EN_PORT,HLCD_u8_EN_PIN,MDIO_u8_LOW);
    19b6:	82 e0       	ldi	r24, 0x02	; 2
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	40 e0       	ldi	r20, 0x00	; 0
    19bc:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <MDIO_u8SetPinValue>
	return Local_u8ErrorState;
    19c0:	89 8d       	ldd	r24, Y+25	; 0x19
}
    19c2:	6a 96       	adiw	r28, 0x1a	; 26
    19c4:	0f b6       	in	r0, 0x3f	; 63
    19c6:	f8 94       	cli
    19c8:	de bf       	out	0x3e, r29	; 62
    19ca:	0f be       	out	0x3f, r0	; 63
    19cc:	cd bf       	out	0x3d, r28	; 61
    19ce:	cf 91       	pop	r28
    19d0:	df 91       	pop	r29
    19d2:	08 95       	ret

000019d4 <HLCD_u8SetCursor>:


u8 HLCD_u8SetCursor(u8 Copy_u8LineNum,u8 Copy_u8CharNum)
{
    19d4:	df 93       	push	r29
    19d6:	cf 93       	push	r28
    19d8:	00 d0       	rcall	.+0      	; 0x19da <HLCD_u8SetCursor+0x6>
    19da:	00 d0       	rcall	.+0      	; 0x19dc <HLCD_u8SetCursor+0x8>
    19dc:	0f 92       	push	r0
    19de:	cd b7       	in	r28, 0x3d	; 61
    19e0:	de b7       	in	r29, 0x3e	; 62
    19e2:	8a 83       	std	Y+2, r24	; 0x02
    19e4:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=STD_TYPES_OK;
    19e6:	81 e0       	ldi	r24, 0x01	; 1
    19e8:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8LineNum)
    19ea:	8a 81       	ldd	r24, Y+2	; 0x02
    19ec:	28 2f       	mov	r18, r24
    19ee:	30 e0       	ldi	r19, 0x00	; 0
    19f0:	3d 83       	std	Y+5, r19	; 0x05
    19f2:	2c 83       	std	Y+4, r18	; 0x04
    19f4:	8c 81       	ldd	r24, Y+4	; 0x04
    19f6:	9d 81       	ldd	r25, Y+5	; 0x05
    19f8:	81 30       	cpi	r24, 0x01	; 1
    19fa:	91 05       	cpc	r25, r1
    19fc:	31 f0       	breq	.+12     	; 0x1a0a <HLCD_u8SetCursor+0x36>
    19fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1a00:	3d 81       	ldd	r19, Y+5	; 0x05
    1a02:	22 30       	cpi	r18, 0x02	; 2
    1a04:	31 05       	cpc	r19, r1
    1a06:	31 f0       	breq	.+12     	; 0x1a14 <HLCD_u8SetCursor+0x40>
    1a08:	0a c0       	rjmp	.+20     	; 0x1a1e <HLCD_u8SetCursor+0x4a>
	{
		case HLCD_u8_LINE_1:HLCD_u8SendCmnd(0x80+Copy_u8CharNum); break;
    1a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0c:	80 58       	subi	r24, 0x80	; 128
    1a0e:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
    1a12:	06 c0       	rjmp	.+12     	; 0x1a20 <HLCD_u8SetCursor+0x4c>
		case HLCD_u8_LINE_2:HLCD_u8SendCmnd(0xC0+Copy_u8CharNum); break;
    1a14:	8b 81       	ldd	r24, Y+3	; 0x03
    1a16:	80 54       	subi	r24, 0x40	; 64
    1a18:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
    1a1c:	01 c0       	rjmp	.+2      	; 0x1a20 <HLCD_u8SetCursor+0x4c>
		default:Local_u8ErrorState=STD_TYPES_NOK;break;
    1a1e:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a22:	0f 90       	pop	r0
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	0f 90       	pop	r0
    1a2a:	0f 90       	pop	r0
    1a2c:	cf 91       	pop	r28
    1a2e:	df 91       	pop	r29
    1a30:	08 95       	ret

00001a32 <HLCD_u8SendString>:

u8 HLCD_u8SendString(u8 Copy_u8String[],u8 Copy_u8Cursor)
{
    1a32:	df 93       	push	r29
    1a34:	cf 93       	push	r28
    1a36:	00 d0       	rcall	.+0      	; 0x1a38 <HLCD_u8SendString+0x6>
    1a38:	00 d0       	rcall	.+0      	; 0x1a3a <HLCD_u8SendString+0x8>
    1a3a:	0f 92       	push	r0
    1a3c:	cd b7       	in	r28, 0x3d	; 61
    1a3e:	de b7       	in	r29, 0x3e	; 62
    1a40:	9c 83       	std	Y+4, r25	; 0x04
    1a42:	8b 83       	std	Y+3, r24	; 0x03
    1a44:	6d 83       	std	Y+5, r22	; 0x05
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	8a 83       	std	Y+2, r24	; 0x02
	for(u8 i=0;Copy_u8String[i] !='\0'; i++)
    1a4a:	19 82       	std	Y+1, r1	; 0x01
    1a4c:	1f c0       	rjmp	.+62     	; 0x1a8c <HLCD_u8SendString+0x5a>
	{
		if(i==16-Copy_u8Cursor)
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	48 2f       	mov	r20, r24
    1a52:	50 e0       	ldi	r21, 0x00	; 0
    1a54:	8d 81       	ldd	r24, Y+5	; 0x05
    1a56:	28 2f       	mov	r18, r24
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	80 e1       	ldi	r24, 0x10	; 16
    1a5c:	90 e0       	ldi	r25, 0x00	; 0
    1a5e:	82 1b       	sub	r24, r18
    1a60:	93 0b       	sbc	r25, r19
    1a62:	48 17       	cp	r20, r24
    1a64:	59 07       	cpc	r21, r25
    1a66:	21 f4       	brne	.+8      	; 0x1a70 <HLCD_u8SendString+0x3e>
			HLCD_u8SetCursor(2,0);
    1a68:	82 e0       	ldi	r24, 0x02	; 2
    1a6a:	60 e0       	ldi	r22, 0x00	; 0
    1a6c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendChar(Copy_u8String[i]);
    1a70:	89 81       	ldd	r24, Y+1	; 0x01
    1a72:	28 2f       	mov	r18, r24
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	8b 81       	ldd	r24, Y+3	; 0x03
    1a78:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7a:	fc 01       	movw	r30, r24
    1a7c:	e2 0f       	add	r30, r18
    1a7e:	f3 1f       	adc	r31, r19
    1a80:	80 81       	ld	r24, Z
    1a82:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
}

u8 HLCD_u8SendString(u8 Copy_u8String[],u8 Copy_u8Cursor)
{
	u8 Local_u8ErrorState=STD_TYPES_OK;
	for(u8 i=0;Copy_u8String[i] !='\0'; i++)
    1a86:	89 81       	ldd	r24, Y+1	; 0x01
    1a88:	8f 5f       	subi	r24, 0xFF	; 255
    1a8a:	89 83       	std	Y+1, r24	; 0x01
    1a8c:	89 81       	ldd	r24, Y+1	; 0x01
    1a8e:	28 2f       	mov	r18, r24
    1a90:	30 e0       	ldi	r19, 0x00	; 0
    1a92:	8b 81       	ldd	r24, Y+3	; 0x03
    1a94:	9c 81       	ldd	r25, Y+4	; 0x04
    1a96:	fc 01       	movw	r30, r24
    1a98:	e2 0f       	add	r30, r18
    1a9a:	f3 1f       	adc	r31, r19
    1a9c:	80 81       	ld	r24, Z
    1a9e:	88 23       	and	r24, r24
    1aa0:	b1 f6       	brne	.-84     	; 0x1a4e <HLCD_u8SendString+0x1c>
		if(i==16-Copy_u8Cursor)
			HLCD_u8SetCursor(2,0);
		HLCD_u8SendChar(Copy_u8String[i]);
	}

	return Local_u8ErrorState;
    1aa2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1aa4:	0f 90       	pop	r0
    1aa6:	0f 90       	pop	r0
    1aa8:	0f 90       	pop	r0
    1aaa:	0f 90       	pop	r0
    1aac:	0f 90       	pop	r0
    1aae:	cf 91       	pop	r28
    1ab0:	df 91       	pop	r29
    1ab2:	08 95       	ret

00001ab4 <HLCD_u8SendNumber>:

u8 HLCD_u8SendNumber(u16 Copy_u8Number)
{
    1ab4:	df 93       	push	r29
    1ab6:	cf 93       	push	r28
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
    1abc:	2b 97       	sbiw	r28, 0x0b	; 11
    1abe:	0f b6       	in	r0, 0x3f	; 63
    1ac0:	f8 94       	cli
    1ac2:	de bf       	out	0x3e, r29	; 62
    1ac4:	0f be       	out	0x3f, r0	; 63
    1ac6:	cd bf       	out	0x3d, r28	; 61
    1ac8:	9b 87       	std	Y+11, r25	; 0x0b
    1aca:	8a 87       	std	Y+10, r24	; 0x0a
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	89 87       	std	Y+9, r24	; 0x09
	u8 temp1;
	u16 temp2=Copy_u8Number;
    1ad0:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ad2:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ad4:	9f 83       	std	Y+7, r25	; 0x07
    1ad6:	8e 83       	std	Y+6, r24	; 0x06
	u16 temp3=1;
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	9d 83       	std	Y+5, r25	; 0x05
    1ade:	8c 83       	std	Y+4, r24	; 0x04
	u8 counter=0;
    1ae0:	1b 82       	std	Y+3, r1	; 0x03
	if(Copy_u8Number==0)
    1ae2:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ae4:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ae6:	00 97       	sbiw	r24, 0x00	; 0
    1ae8:	89 f4       	brne	.+34     	; 0x1b0c <HLCD_u8SendNumber+0x58>
		HLCD_u8SendChar('0');
    1aea:	80 e3       	ldi	r24, 0x30	; 48
    1aec:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
    1af0:	57 c0       	rjmp	.+174    	; 0x1ba0 <HLCD_u8SendNumber+0xec>
	else{
	while(temp2!=0)
	{
		temp2=temp2/10;
    1af2:	8e 81       	ldd	r24, Y+6	; 0x06
    1af4:	9f 81       	ldd	r25, Y+7	; 0x07
    1af6:	2a e0       	ldi	r18, 0x0A	; 10
    1af8:	30 e0       	ldi	r19, 0x00	; 0
    1afa:	b9 01       	movw	r22, r18
    1afc:	0e 94 05 32 	call	0x640a	; 0x640a <__udivmodhi4>
    1b00:	cb 01       	movw	r24, r22
    1b02:	9f 83       	std	Y+7, r25	; 0x07
    1b04:	8e 83       	std	Y+6, r24	; 0x06
		counter++;
    1b06:	8b 81       	ldd	r24, Y+3	; 0x03
    1b08:	8f 5f       	subi	r24, 0xFF	; 255
    1b0a:	8b 83       	std	Y+3, r24	; 0x03
	u16 temp3=1;
	u8 counter=0;
	if(Copy_u8Number==0)
		HLCD_u8SendChar('0');
	else{
	while(temp2!=0)
    1b0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b0e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b10:	00 97       	sbiw	r24, 0x00	; 0
    1b12:	79 f7       	brne	.-34     	; 0x1af2 <HLCD_u8SendNumber+0x3e>
	{
		temp2=temp2/10;
		counter++;
	}
	for(u8 i=0;i<(counter-1);i++)
    1b14:	1a 82       	std	Y+2, r1	; 0x02
    1b16:	11 c0       	rjmp	.+34     	; 0x1b3a <HLCD_u8SendNumber+0x86>
			temp3=temp3*10;
    1b18:	8c 81       	ldd	r24, Y+4	; 0x04
    1b1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b1c:	9c 01       	movw	r18, r24
    1b1e:	22 0f       	add	r18, r18
    1b20:	33 1f       	adc	r19, r19
    1b22:	c9 01       	movw	r24, r18
    1b24:	88 0f       	add	r24, r24
    1b26:	99 1f       	adc	r25, r25
    1b28:	88 0f       	add	r24, r24
    1b2a:	99 1f       	adc	r25, r25
    1b2c:	82 0f       	add	r24, r18
    1b2e:	93 1f       	adc	r25, r19
    1b30:	9d 83       	std	Y+5, r25	; 0x05
    1b32:	8c 83       	std	Y+4, r24	; 0x04
	while(temp2!=0)
	{
		temp2=temp2/10;
		counter++;
	}
	for(u8 i=0;i<(counter-1);i++)
    1b34:	8a 81       	ldd	r24, Y+2	; 0x02
    1b36:	8f 5f       	subi	r24, 0xFF	; 255
    1b38:	8a 83       	std	Y+2, r24	; 0x02
    1b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3c:	28 2f       	mov	r18, r24
    1b3e:	30 e0       	ldi	r19, 0x00	; 0
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	88 2f       	mov	r24, r24
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	01 97       	sbiw	r24, 0x01	; 1
    1b48:	28 17       	cp	r18, r24
    1b4a:	39 07       	cpc	r19, r25
    1b4c:	2c f3       	brlt	.-54     	; 0x1b18 <HLCD_u8SendNumber+0x64>
			temp3=temp3*10;
	for(u8 i=0;i<counter; i++)
    1b4e:	19 82       	std	Y+1, r1	; 0x01
    1b50:	23 c0       	rjmp	.+70     	; 0x1b98 <HLCD_u8SendNumber+0xe4>
	{
		temp1=(Copy_u8Number)/temp3;
    1b52:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b54:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b56:	2c 81       	ldd	r18, Y+4	; 0x04
    1b58:	3d 81       	ldd	r19, Y+5	; 0x05
    1b5a:	b9 01       	movw	r22, r18
    1b5c:	0e 94 05 32 	call	0x640a	; 0x640a <__udivmodhi4>
    1b60:	cb 01       	movw	r24, r22
    1b62:	88 87       	std	Y+8, r24	; 0x08
		Copy_u8Number=(Copy_u8Number)%temp3;
    1b64:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b66:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b68:	2c 81       	ldd	r18, Y+4	; 0x04
    1b6a:	3d 81       	ldd	r19, Y+5	; 0x05
    1b6c:	b9 01       	movw	r22, r18
    1b6e:	0e 94 05 32 	call	0x640a	; 0x640a <__udivmodhi4>
    1b72:	9b 87       	std	Y+11, r25	; 0x0b
    1b74:	8a 87       	std	Y+10, r24	; 0x0a
		temp3=temp3/10;
    1b76:	8c 81       	ldd	r24, Y+4	; 0x04
    1b78:	9d 81       	ldd	r25, Y+5	; 0x05
    1b7a:	2a e0       	ldi	r18, 0x0A	; 10
    1b7c:	30 e0       	ldi	r19, 0x00	; 0
    1b7e:	b9 01       	movw	r22, r18
    1b80:	0e 94 05 32 	call	0x640a	; 0x640a <__udivmodhi4>
    1b84:	cb 01       	movw	r24, r22
    1b86:	9d 83       	std	Y+5, r25	; 0x05
    1b88:	8c 83       	std	Y+4, r24	; 0x04
		HLCD_u8SendChar(48+temp1);
    1b8a:	88 85       	ldd	r24, Y+8	; 0x08
    1b8c:	80 5d       	subi	r24, 0xD0	; 208
    1b8e:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
		temp2=temp2/10;
		counter++;
	}
	for(u8 i=0;i<(counter-1);i++)
			temp3=temp3*10;
	for(u8 i=0;i<counter; i++)
    1b92:	89 81       	ldd	r24, Y+1	; 0x01
    1b94:	8f 5f       	subi	r24, 0xFF	; 255
    1b96:	89 83       	std	Y+1, r24	; 0x01
    1b98:	99 81       	ldd	r25, Y+1	; 0x01
    1b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9c:	98 17       	cp	r25, r24
    1b9e:	c8 f2       	brcs	.-78     	; 0x1b52 <HLCD_u8SendNumber+0x9e>
		Copy_u8Number=(Copy_u8Number)%temp3;
		temp3=temp3/10;
		HLCD_u8SendChar(48+temp1);
	}
	}
	return Local_u8ErrorState;
    1ba0:	89 85       	ldd	r24, Y+9	; 0x09
}
    1ba2:	2b 96       	adiw	r28, 0x0b	; 11
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	de bf       	out	0x3e, r29	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	cd bf       	out	0x3d, r28	; 61
    1bae:	cf 91       	pop	r28
    1bb0:	df 91       	pop	r29
    1bb2:	08 95       	ret

00001bb4 <HLCD_u8GenerateSpecialCharacter>:

u8 HLCD_u8GenerateSpecialCharacter(u8* Copy_Pu8_pattern,u8 Copy_u8_CGROM_Index)
{
    1bb4:	df 93       	push	r29
    1bb6:	cf 93       	push	r28
    1bb8:	00 d0       	rcall	.+0      	; 0x1bba <HLCD_u8GenerateSpecialCharacter+0x6>
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <HLCD_u8GenerateSpecialCharacter+0x8>
    1bbc:	0f 92       	push	r0
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	9c 83       	std	Y+4, r25	; 0x04
    1bc4:	8b 83       	std	Y+3, r24	; 0x03
    1bc6:	6d 83       	std	Y+5, r22	; 0x05
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1bc8:	81 e0       	ldi	r24, 0x01	; 1
    1bca:	8a 83       	std	Y+2, r24	; 0x02
	HLCD_u8SendCmnd((0x40+Copy_u8_CGROM_Index));
    1bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    1bce:	80 5c       	subi	r24, 0xC0	; 192
    1bd0:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
	for(u8 i=0;i<8;i++)
    1bd4:	19 82       	std	Y+1, r1	; 0x01
    1bd6:	0e c0       	rjmp	.+28     	; 0x1bf4 <HLCD_u8GenerateSpecialCharacter+0x40>
		HLCD_u8SendChar(Copy_Pu8_pattern[i]);
    1bd8:	89 81       	ldd	r24, Y+1	; 0x01
    1bda:	28 2f       	mov	r18, r24
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	8b 81       	ldd	r24, Y+3	; 0x03
    1be0:	9c 81       	ldd	r25, Y+4	; 0x04
    1be2:	fc 01       	movw	r30, r24
    1be4:	e2 0f       	add	r30, r18
    1be6:	f3 1f       	adc	r31, r19
    1be8:	80 81       	ld	r24, Z
    1bea:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>

u8 HLCD_u8GenerateSpecialCharacter(u8* Copy_Pu8_pattern,u8 Copy_u8_CGROM_Index)
{
	u8 Local_u8ErrorState=STD_TYPES_OK;
	HLCD_u8SendCmnd((0x40+Copy_u8_CGROM_Index));
	for(u8 i=0;i<8;i++)
    1bee:	89 81       	ldd	r24, Y+1	; 0x01
    1bf0:	8f 5f       	subi	r24, 0xFF	; 255
    1bf2:	89 83       	std	Y+1, r24	; 0x01
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	88 30       	cpi	r24, 0x08	; 8
    1bf8:	78 f3       	brcs	.-34     	; 0x1bd8 <HLCD_u8GenerateSpecialCharacter+0x24>
		HLCD_u8SendChar(Copy_Pu8_pattern[i]);

	return Local_u8ErrorState;
    1bfa:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1bfc:	0f 90       	pop	r0
    1bfe:	0f 90       	pop	r0
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	0f 90       	pop	r0
    1c06:	cf 91       	pop	r28
    1c08:	df 91       	pop	r29
    1c0a:	08 95       	ret

00001c0c <HLCD_u8DisplaySpecialCharacter>:

u8 HLCD_u8DisplaySpecialCharacter(u8 Copy_u8_PatternId,u8 Copy_u8LineNum,u8 Copy_u8CharNum)
{
    1c0c:	df 93       	push	r29
    1c0e:	cf 93       	push	r28
    1c10:	00 d0       	rcall	.+0      	; 0x1c12 <HLCD_u8DisplaySpecialCharacter+0x6>
    1c12:	00 d0       	rcall	.+0      	; 0x1c14 <HLCD_u8DisplaySpecialCharacter+0x8>
    1c14:	cd b7       	in	r28, 0x3d	; 61
    1c16:	de b7       	in	r29, 0x3e	; 62
    1c18:	8a 83       	std	Y+2, r24	; 0x02
    1c1a:	6b 83       	std	Y+3, r22	; 0x03
    1c1c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	89 83       	std	Y+1, r24	; 0x01
	HLCD_u8SetCursor(Copy_u8LineNum,Copy_u8CharNum);
    1c22:	8b 81       	ldd	r24, Y+3	; 0x03
    1c24:	6c 81       	ldd	r22, Y+4	; 0x04
    1c26:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
	HLCD_u8SendChar(Copy_u8_PatternId);
    1c2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c2c:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
	return Local_u8ErrorState;
    1c30:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c32:	0f 90       	pop	r0
    1c34:	0f 90       	pop	r0
    1c36:	0f 90       	pop	r0
    1c38:	0f 90       	pop	r0
    1c3a:	cf 91       	pop	r28
    1c3c:	df 91       	pop	r29
    1c3e:	08 95       	ret

00001c40 <HLCD_u8ClearDisplay>:

u8 HLCD_u8ClearDisplay(void)
{
    1c40:	df 93       	push	r29
    1c42:	cf 93       	push	r28
    1c44:	cd b7       	in	r28, 0x3d	; 61
    1c46:	de b7       	in	r29, 0x3e	; 62
    1c48:	2e 97       	sbiw	r28, 0x0e	; 14
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	de bf       	out	0x3e, r29	; 62
    1c50:	0f be       	out	0x3f, r0	; 63
    1c52:	cd bf       	out	0x3d, r28	; 61
	HLCD_u8SendCmnd(0x01);
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	0e 94 10 0b 	call	0x1620	; 0x1620 <HLCD_u8SendCmnd>
    1c5a:	80 e0       	ldi	r24, 0x00	; 0
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	a8 ec       	ldi	r26, 0xC8	; 200
    1c60:	b2 e4       	ldi	r27, 0x42	; 66
    1c62:	8b 87       	std	Y+11, r24	; 0x0b
    1c64:	9c 87       	std	Y+12, r25	; 0x0c
    1c66:	ad 87       	std	Y+13, r26	; 0x0d
    1c68:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c6a:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c6c:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c70:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c72:	20 e0       	ldi	r18, 0x00	; 0
    1c74:	30 e0       	ldi	r19, 0x00	; 0
    1c76:	4a ef       	ldi	r20, 0xFA	; 250
    1c78:	54 e4       	ldi	r21, 0x44	; 68
    1c7a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c7e:	dc 01       	movw	r26, r24
    1c80:	cb 01       	movw	r24, r22
    1c82:	8f 83       	std	Y+7, r24	; 0x07
    1c84:	98 87       	std	Y+8, r25	; 0x08
    1c86:	a9 87       	std	Y+9, r26	; 0x09
    1c88:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1c8a:	6f 81       	ldd	r22, Y+7	; 0x07
    1c8c:	78 85       	ldd	r23, Y+8	; 0x08
    1c8e:	89 85       	ldd	r24, Y+9	; 0x09
    1c90:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c92:	20 e0       	ldi	r18, 0x00	; 0
    1c94:	30 e0       	ldi	r19, 0x00	; 0
    1c96:	40 e8       	ldi	r20, 0x80	; 128
    1c98:	5f e3       	ldi	r21, 0x3F	; 63
    1c9a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1c9e:	88 23       	and	r24, r24
    1ca0:	2c f4       	brge	.+10     	; 0x1cac <HLCD_u8ClearDisplay+0x6c>
		__ticks = 1;
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	9e 83       	std	Y+6, r25	; 0x06
    1ca8:	8d 83       	std	Y+5, r24	; 0x05
    1caa:	3f c0       	rjmp	.+126    	; 0x1d2a <HLCD_u8ClearDisplay+0xea>
	else if (__tmp > 65535)
    1cac:	6f 81       	ldd	r22, Y+7	; 0x07
    1cae:	78 85       	ldd	r23, Y+8	; 0x08
    1cb0:	89 85       	ldd	r24, Y+9	; 0x09
    1cb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cb4:	20 e0       	ldi	r18, 0x00	; 0
    1cb6:	3f ef       	ldi	r19, 0xFF	; 255
    1cb8:	4f e7       	ldi	r20, 0x7F	; 127
    1cba:	57 e4       	ldi	r21, 0x47	; 71
    1cbc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1cc0:	18 16       	cp	r1, r24
    1cc2:	4c f5       	brge	.+82     	; 0x1d16 <HLCD_u8ClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cc4:	6b 85       	ldd	r22, Y+11	; 0x0b
    1cc6:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cca:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ccc:	20 e0       	ldi	r18, 0x00	; 0
    1cce:	30 e0       	ldi	r19, 0x00	; 0
    1cd0:	40 e2       	ldi	r20, 0x20	; 32
    1cd2:	51 e4       	ldi	r21, 0x41	; 65
    1cd4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cd8:	dc 01       	movw	r26, r24
    1cda:	cb 01       	movw	r24, r22
    1cdc:	bc 01       	movw	r22, r24
    1cde:	cd 01       	movw	r24, r26
    1ce0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ce4:	dc 01       	movw	r26, r24
    1ce6:	cb 01       	movw	r24, r22
    1ce8:	9e 83       	std	Y+6, r25	; 0x06
    1cea:	8d 83       	std	Y+5, r24	; 0x05
    1cec:	0f c0       	rjmp	.+30     	; 0x1d0c <HLCD_u8ClearDisplay+0xcc>
    1cee:	88 ec       	ldi	r24, 0xC8	; 200
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	9c 83       	std	Y+4, r25	; 0x04
    1cf4:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfa:	01 97       	sbiw	r24, 0x01	; 1
    1cfc:	f1 f7       	brne	.-4      	; 0x1cfa <HLCD_u8ClearDisplay+0xba>
    1cfe:	9c 83       	std	Y+4, r25	; 0x04
    1d00:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d02:	8d 81       	ldd	r24, Y+5	; 0x05
    1d04:	9e 81       	ldd	r25, Y+6	; 0x06
    1d06:	01 97       	sbiw	r24, 0x01	; 1
    1d08:	9e 83       	std	Y+6, r25	; 0x06
    1d0a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d10:	00 97       	sbiw	r24, 0x00	; 0
    1d12:	69 f7       	brne	.-38     	; 0x1cee <HLCD_u8ClearDisplay+0xae>
    1d14:	14 c0       	rjmp	.+40     	; 0x1d3e <HLCD_u8ClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d16:	6f 81       	ldd	r22, Y+7	; 0x07
    1d18:	78 85       	ldd	r23, Y+8	; 0x08
    1d1a:	89 85       	ldd	r24, Y+9	; 0x09
    1d1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d1e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d22:	dc 01       	movw	r26, r24
    1d24:	cb 01       	movw	r24, r22
    1d26:	9e 83       	std	Y+6, r25	; 0x06
    1d28:	8d 83       	std	Y+5, r24	; 0x05
    1d2a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d2c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d2e:	9a 83       	std	Y+2, r25	; 0x02
    1d30:	89 83       	std	Y+1, r24	; 0x01
    1d32:	89 81       	ldd	r24, Y+1	; 0x01
    1d34:	9a 81       	ldd	r25, Y+2	; 0x02
    1d36:	01 97       	sbiw	r24, 0x01	; 1
    1d38:	f1 f7       	brne	.-4      	; 0x1d36 <HLCD_u8ClearDisplay+0xf6>
    1d3a:	9a 83       	std	Y+2, r25	; 0x02
    1d3c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(100);
	return 1;
    1d3e:	81 e0       	ldi	r24, 0x01	; 1
}
    1d40:	2e 96       	adiw	r28, 0x0e	; 14
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	de bf       	out	0x3e, r29	; 62
    1d48:	0f be       	out	0x3f, r0	; 63
    1d4a:	cd bf       	out	0x3d, r28	; 61
    1d4c:	cf 91       	pop	r28
    1d4e:	df 91       	pop	r29
    1d50:	08 95       	ret

00001d52 <MDIO_u8INIT>:
#include"BIT_MATH.h"
#include"MDIO_private.h"
#include"MDIO_interface.h"
#include"MDIO_config.h"
u8 MDIO_u8INIT(void)
{
    1d52:	df 93       	push	r29
    1d54:	cf 93       	push	r28
    1d56:	0f 92       	push	r0
    1d58:	cd b7       	in	r28, 0x3d	; 61
    1d5a:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8ErrorState=STD_TYPES_OK;
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	89 83       	std	Y+1, r24	; 0x01
	/*PORTA*/
	MDIO_u8_DDRA_REG = PRIVATE_u8_CONC(MDIO_u8_PA7_DIRECTION,
    1d60:	ea e3       	ldi	r30, 0x3A	; 58
    1d62:	f0 e0       	ldi	r31, 0x00	; 0
    1d64:	80 ef       	ldi	r24, 0xF0	; 240
    1d66:	80 83       	st	Z, r24
			MDIO_u8_PA3_DIRECTION,
			MDIO_u8_PA2_DIRECTION,
			MDIO_u8_PA1_DIRECTION,
			MDIO_u8_PA0_DIRECTION);

	MDIO_u8_DDRB_REG = PRIVATE_u8_CONC(MDIO_u8_PB7_DIRECTION,
    1d68:	e7 e3       	ldi	r30, 0x37	; 55
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	81 e0       	ldi	r24, 0x01	; 1
    1d6e:	80 83       	st	Z, r24
			MDIO_u8_PB3_DIRECTION,
			MDIO_u8_PB2_DIRECTION,
			MDIO_u8_PB1_DIRECTION,
			MDIO_u8_PB0_DIRECTION);

	MDIO_u8_DDRC_REG = PRIVATE_u8_CONC(MDIO_u8_PC7_DIRECTION,
    1d70:	e4 e3       	ldi	r30, 0x34	; 52
    1d72:	f0 e0       	ldi	r31, 0x00	; 0
    1d74:	87 e0       	ldi	r24, 0x07	; 7
    1d76:	80 83       	st	Z, r24
			MDIO_u8_PC3_DIRECTION,
			MDIO_u8_PC2_DIRECTION,
			MDIO_u8_PC1_DIRECTION,
			MDIO_u8_PC0_DIRECTION);

	MDIO_u8_DDRD_REG = PRIVATE_u8_CONC(MDIO_u8_PD7_DIRECTION,
    1d78:	e1 e3       	ldi	r30, 0x31	; 49
    1d7a:	f0 e0       	ldi	r31, 0x00	; 0
    1d7c:	8f ef       	ldi	r24, 0xFF	; 255
    1d7e:	80 83       	st	Z, r24
			MDIO_u8_PD3_DIRECTION,
			MDIO_u8_PD2_DIRECTION,
			MDIO_u8_PD1_DIRECTION,
			MDIO_u8_PD0_DIRECTION);

	MDIO_u8_PORTA_REG= PRIVATE_u8_CONC(MDIO_u8_PA7_value,
    1d80:	eb e3       	ldi	r30, 0x3B	; 59
    1d82:	f0 e0       	ldi	r31, 0x00	; 0
    1d84:	8f ef       	ldi	r24, 0xFF	; 255
    1d86:	80 83       	st	Z, r24
           MDIO_u8_PA3_value,
           MDIO_u8_PA2_value,
           MDIO_u8_PA1_value,
           MDIO_u8_PA0_value);

	MDIO_u8_PORTB_REG= PRIVATE_u8_CONC(MDIO_u8_PB7_value,
    1d88:	e8 e3       	ldi	r30, 0x38	; 56
    1d8a:	f0 e0       	ldi	r31, 0x00	; 0
    1d8c:	10 82       	st	Z, r1
	       MDIO_u8_PB3_value,
	       MDIO_u8_PB2_value,
	       MDIO_u8_PB1_value,
	       MDIO_u8_PB0_value);

	MDIO_u8_PORTC_REG= PRIVATE_u8_CONC(MDIO_u8_PC7_value,
    1d8e:	e5 e3       	ldi	r30, 0x35	; 53
    1d90:	f0 e0       	ldi	r31, 0x00	; 0
    1d92:	10 82       	st	Z, r1
	       MDIO_u8_PC3_value,
	       MDIO_u8_PC2_value,
	       MDIO_u8_PC1_value,
	       MDIO_u8_PC0_value);

	MDIO_u8_PORTD_REG= PRIVATE_u8_CONC(MDIO_u8_PD7_value,
    1d94:	e2 e3       	ldi	r30, 0x32	; 50
    1d96:	f0 e0       	ldi	r31, 0x00	; 0
    1d98:	10 82       	st	Z, r1
	       MDIO_u8_PD3_value,
	       MDIO_u8_PD2_value,
	       MDIO_u8_PD1_value,
	       MDIO_u8_PD0_value);

	return Local_u8ErrorState;
    1d9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d9c:	0f 90       	pop	r0
    1d9e:	cf 91       	pop	r28
    1da0:	df 91       	pop	r29
    1da2:	08 95       	ret

00001da4 <MDIO_u8SetPinDirection>:

u8 MDIO_u8SetPinDirection(u8 Copy_u8_Port_Id,u8 Copy_u8_Pin_Id,u8 Copy_u8_Pin_Direction)
{
    1da4:	df 93       	push	r29
    1da6:	cf 93       	push	r28
    1da8:	cd b7       	in	r28, 0x3d	; 61
    1daa:	de b7       	in	r29, 0x3e	; 62
    1dac:	2c 97       	sbiw	r28, 0x0c	; 12
    1dae:	0f b6       	in	r0, 0x3f	; 63
    1db0:	f8 94       	cli
    1db2:	de bf       	out	0x3e, r29	; 62
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	cd bf       	out	0x3d, r28	; 61
    1db8:	8a 83       	std	Y+2, r24	; 0x02
    1dba:	6b 83       	std	Y+3, r22	; 0x03
    1dbc:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState= STD_TYPES_NOK;
    1dbe:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8_Port_Id<=MDIO_u8_PORTD)&&(Copy_u8_Pin_Id<=MDIO_u8_PIN_7))
    1dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc2:	84 30       	cpi	r24, 0x04	; 4
    1dc4:	08 f0       	brcs	.+2      	; 0x1dc8 <MDIO_u8SetPinDirection+0x24>
    1dc6:	6d c1       	rjmp	.+730    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	88 30       	cpi	r24, 0x08	; 8
    1dcc:	08 f0       	brcs	.+2      	; 0x1dd0 <MDIO_u8SetPinDirection+0x2c>
    1dce:	69 c1       	rjmp	.+722    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
	{
		Local_u8ErrorState= STD_TYPES_OK;
    1dd0:	81 e0       	ldi	r24, 0x01	; 1
    1dd2:	89 83       	std	Y+1, r24	; 0x01
		switch(Copy_u8_Pin_Direction)
    1dd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd6:	28 2f       	mov	r18, r24
    1dd8:	30 e0       	ldi	r19, 0x00	; 0
    1dda:	3c 87       	std	Y+12, r19	; 0x0c
    1ddc:	2b 87       	std	Y+11, r18	; 0x0b
    1dde:	8b 85       	ldd	r24, Y+11	; 0x0b
    1de0:	9c 85       	ldd	r25, Y+12	; 0x0c
    1de2:	81 30       	cpi	r24, 0x01	; 1
    1de4:	91 05       	cpc	r25, r1
    1de6:	61 f0       	breq	.+24     	; 0x1e00 <MDIO_u8SetPinDirection+0x5c>
    1de8:	2b 85       	ldd	r18, Y+11	; 0x0b
    1dea:	3c 85       	ldd	r19, Y+12	; 0x0c
    1dec:	22 30       	cpi	r18, 0x02	; 2
    1dee:	31 05       	cpc	r19, r1
    1df0:	09 f4       	brne	.+2      	; 0x1df4 <MDIO_u8SetPinDirection+0x50>
    1df2:	e2 c0       	rjmp	.+452    	; 0x1fb8 <MDIO_u8SetPinDirection+0x214>
    1df4:	8b 85       	ldd	r24, Y+11	; 0x0b
    1df6:	9c 85       	ldd	r25, Y+12	; 0x0c
    1df8:	00 97       	sbiw	r24, 0x00	; 0
    1dfa:	09 f4       	brne	.+2      	; 0x1dfe <MDIO_u8SetPinDirection+0x5a>
    1dfc:	70 c0       	rjmp	.+224    	; 0x1ede <MDIO_u8SetPinDirection+0x13a>
    1dfe:	50 c1       	rjmp	.+672    	; 0x20a0 <MDIO_u8SetPinDirection+0x2fc>
		{
			case MDIO_u8_OUTPUT:
				switch(Copy_u8_Port_Id)
    1e00:	8a 81       	ldd	r24, Y+2	; 0x02
    1e02:	28 2f       	mov	r18, r24
    1e04:	30 e0       	ldi	r19, 0x00	; 0
    1e06:	3a 87       	std	Y+10, r19	; 0x0a
    1e08:	29 87       	std	Y+9, r18	; 0x09
    1e0a:	89 85       	ldd	r24, Y+9	; 0x09
    1e0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e0e:	81 30       	cpi	r24, 0x01	; 1
    1e10:	91 05       	cpc	r25, r1
    1e12:	49 f1       	breq	.+82     	; 0x1e66 <MDIO_u8SetPinDirection+0xc2>
    1e14:	29 85       	ldd	r18, Y+9	; 0x09
    1e16:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e18:	22 30       	cpi	r18, 0x02	; 2
    1e1a:	31 05       	cpc	r19, r1
    1e1c:	2c f4       	brge	.+10     	; 0x1e28 <MDIO_u8SetPinDirection+0x84>
    1e1e:	89 85       	ldd	r24, Y+9	; 0x09
    1e20:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	61 f0       	breq	.+24     	; 0x1e3e <MDIO_u8SetPinDirection+0x9a>
    1e26:	3d c1       	rjmp	.+634    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
    1e28:	29 85       	ldd	r18, Y+9	; 0x09
    1e2a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e2c:	22 30       	cpi	r18, 0x02	; 2
    1e2e:	31 05       	cpc	r19, r1
    1e30:	71 f1       	breq	.+92     	; 0x1e8e <MDIO_u8SetPinDirection+0xea>
    1e32:	89 85       	ldd	r24, Y+9	; 0x09
    1e34:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e36:	83 30       	cpi	r24, 0x03	; 3
    1e38:	91 05       	cpc	r25, r1
    1e3a:	e9 f1       	breq	.+122    	; 0x1eb6 <MDIO_u8SetPinDirection+0x112>
    1e3c:	32 c1       	rjmp	.+612    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
				{
					case MDIO_u8_PORTA:
						SET_BIT(MDIO_u8_DDRA_REG,Copy_u8_Pin_Id);
    1e3e:	aa e3       	ldi	r26, 0x3A	; 58
    1e40:	b0 e0       	ldi	r27, 0x00	; 0
    1e42:	ea e3       	ldi	r30, 0x3A	; 58
    1e44:	f0 e0       	ldi	r31, 0x00	; 0
    1e46:	80 81       	ld	r24, Z
    1e48:	48 2f       	mov	r20, r24
    1e4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e4c:	28 2f       	mov	r18, r24
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	02 2e       	mov	r0, r18
    1e56:	02 c0       	rjmp	.+4      	; 0x1e5c <MDIO_u8SetPinDirection+0xb8>
    1e58:	88 0f       	add	r24, r24
    1e5a:	99 1f       	adc	r25, r25
    1e5c:	0a 94       	dec	r0
    1e5e:	e2 f7       	brpl	.-8      	; 0x1e58 <MDIO_u8SetPinDirection+0xb4>
    1e60:	84 2b       	or	r24, r20
    1e62:	8c 93       	st	X, r24
    1e64:	1e c1       	rjmp	.+572    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
						break;

					case MDIO_u8_PORTB:
						SET_BIT(MDIO_u8_DDRB_REG,Copy_u8_Pin_Id);
    1e66:	a7 e3       	ldi	r26, 0x37	; 55
    1e68:	b0 e0       	ldi	r27, 0x00	; 0
    1e6a:	e7 e3       	ldi	r30, 0x37	; 55
    1e6c:	f0 e0       	ldi	r31, 0x00	; 0
    1e6e:	80 81       	ld	r24, Z
    1e70:	48 2f       	mov	r20, r24
    1e72:	8b 81       	ldd	r24, Y+3	; 0x03
    1e74:	28 2f       	mov	r18, r24
    1e76:	30 e0       	ldi	r19, 0x00	; 0
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	02 2e       	mov	r0, r18
    1e7e:	02 c0       	rjmp	.+4      	; 0x1e84 <MDIO_u8SetPinDirection+0xe0>
    1e80:	88 0f       	add	r24, r24
    1e82:	99 1f       	adc	r25, r25
    1e84:	0a 94       	dec	r0
    1e86:	e2 f7       	brpl	.-8      	; 0x1e80 <MDIO_u8SetPinDirection+0xdc>
    1e88:	84 2b       	or	r24, r20
    1e8a:	8c 93       	st	X, r24
    1e8c:	0a c1       	rjmp	.+532    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
						break;

					case MDIO_u8_PORTC:
						SET_BIT(MDIO_u8_DDRC_REG,Copy_u8_Pin_Id);
    1e8e:	a4 e3       	ldi	r26, 0x34	; 52
    1e90:	b0 e0       	ldi	r27, 0x00	; 0
    1e92:	e4 e3       	ldi	r30, 0x34	; 52
    1e94:	f0 e0       	ldi	r31, 0x00	; 0
    1e96:	80 81       	ld	r24, Z
    1e98:	48 2f       	mov	r20, r24
    1e9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9c:	28 2f       	mov	r18, r24
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	02 2e       	mov	r0, r18
    1ea6:	02 c0       	rjmp	.+4      	; 0x1eac <MDIO_u8SetPinDirection+0x108>
    1ea8:	88 0f       	add	r24, r24
    1eaa:	99 1f       	adc	r25, r25
    1eac:	0a 94       	dec	r0
    1eae:	e2 f7       	brpl	.-8      	; 0x1ea8 <MDIO_u8SetPinDirection+0x104>
    1eb0:	84 2b       	or	r24, r20
    1eb2:	8c 93       	st	X, r24
    1eb4:	f6 c0       	rjmp	.+492    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
						break;

					case MDIO_u8_PORTD:
						SET_BIT(MDIO_u8_DDRD_REG,Copy_u8_Pin_Id);
    1eb6:	a1 e3       	ldi	r26, 0x31	; 49
    1eb8:	b0 e0       	ldi	r27, 0x00	; 0
    1eba:	e1 e3       	ldi	r30, 0x31	; 49
    1ebc:	f0 e0       	ldi	r31, 0x00	; 0
    1ebe:	80 81       	ld	r24, Z
    1ec0:	48 2f       	mov	r20, r24
    1ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec4:	28 2f       	mov	r18, r24
    1ec6:	30 e0       	ldi	r19, 0x00	; 0
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	02 2e       	mov	r0, r18
    1ece:	02 c0       	rjmp	.+4      	; 0x1ed4 <MDIO_u8SetPinDirection+0x130>
    1ed0:	88 0f       	add	r24, r24
    1ed2:	99 1f       	adc	r25, r25
    1ed4:	0a 94       	dec	r0
    1ed6:	e2 f7       	brpl	.-8      	; 0x1ed0 <MDIO_u8SetPinDirection+0x12c>
    1ed8:	84 2b       	or	r24, r20
    1eda:	8c 93       	st	X, r24
    1edc:	e2 c0       	rjmp	.+452    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
						break;
				}
				break;

		  case MDIO_u8_INPUT_PULLED_UP:
		  	switch(Copy_u8_Port_Id)
    1ede:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee0:	28 2f       	mov	r18, r24
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	38 87       	std	Y+8, r19	; 0x08
    1ee6:	2f 83       	std	Y+7, r18	; 0x07
    1ee8:	8f 81       	ldd	r24, Y+7	; 0x07
    1eea:	98 85       	ldd	r25, Y+8	; 0x08
    1eec:	81 30       	cpi	r24, 0x01	; 1
    1eee:	91 05       	cpc	r25, r1
    1ef0:	49 f1       	breq	.+82     	; 0x1f44 <MDIO_u8SetPinDirection+0x1a0>
    1ef2:	2f 81       	ldd	r18, Y+7	; 0x07
    1ef4:	38 85       	ldd	r19, Y+8	; 0x08
    1ef6:	22 30       	cpi	r18, 0x02	; 2
    1ef8:	31 05       	cpc	r19, r1
    1efa:	2c f4       	brge	.+10     	; 0x1f06 <MDIO_u8SetPinDirection+0x162>
    1efc:	8f 81       	ldd	r24, Y+7	; 0x07
    1efe:	98 85       	ldd	r25, Y+8	; 0x08
    1f00:	00 97       	sbiw	r24, 0x00	; 0
    1f02:	61 f0       	breq	.+24     	; 0x1f1c <MDIO_u8SetPinDirection+0x178>
    1f04:	59 c0       	rjmp	.+178    	; 0x1fb8 <MDIO_u8SetPinDirection+0x214>
    1f06:	2f 81       	ldd	r18, Y+7	; 0x07
    1f08:	38 85       	ldd	r19, Y+8	; 0x08
    1f0a:	22 30       	cpi	r18, 0x02	; 2
    1f0c:	31 05       	cpc	r19, r1
    1f0e:	71 f1       	breq	.+92     	; 0x1f6c <MDIO_u8SetPinDirection+0x1c8>
    1f10:	8f 81       	ldd	r24, Y+7	; 0x07
    1f12:	98 85       	ldd	r25, Y+8	; 0x08
    1f14:	83 30       	cpi	r24, 0x03	; 3
    1f16:	91 05       	cpc	r25, r1
    1f18:	e9 f1       	breq	.+122    	; 0x1f94 <MDIO_u8SetPinDirection+0x1f0>
    1f1a:	4e c0       	rjmp	.+156    	; 0x1fb8 <MDIO_u8SetPinDirection+0x214>
		  	{
		  		case MDIO_u8_PORTA:
		  			SET_BIT(MDIO_u8_PORTA_REG,Copy_u8_Pin_Id);
    1f1c:	ab e3       	ldi	r26, 0x3B	; 59
    1f1e:	b0 e0       	ldi	r27, 0x00	; 0
    1f20:	eb e3       	ldi	r30, 0x3B	; 59
    1f22:	f0 e0       	ldi	r31, 0x00	; 0
    1f24:	80 81       	ld	r24, Z
    1f26:	48 2f       	mov	r20, r24
    1f28:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2a:	28 2f       	mov	r18, r24
    1f2c:	30 e0       	ldi	r19, 0x00	; 0
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	02 2e       	mov	r0, r18
    1f34:	02 c0       	rjmp	.+4      	; 0x1f3a <MDIO_u8SetPinDirection+0x196>
    1f36:	88 0f       	add	r24, r24
    1f38:	99 1f       	adc	r25, r25
    1f3a:	0a 94       	dec	r0
    1f3c:	e2 f7       	brpl	.-8      	; 0x1f36 <MDIO_u8SetPinDirection+0x192>
    1f3e:	84 2b       	or	r24, r20
    1f40:	8c 93       	st	X, r24
    1f42:	3a c0       	rjmp	.+116    	; 0x1fb8 <MDIO_u8SetPinDirection+0x214>
		  			break;

		  		case MDIO_u8_PORTB:
		  			SET_BIT(MDIO_u8_PORTB_REG,Copy_u8_Pin_Id);
    1f44:	a8 e3       	ldi	r26, 0x38	; 56
    1f46:	b0 e0       	ldi	r27, 0x00	; 0
    1f48:	e8 e3       	ldi	r30, 0x38	; 56
    1f4a:	f0 e0       	ldi	r31, 0x00	; 0
    1f4c:	80 81       	ld	r24, Z
    1f4e:	48 2f       	mov	r20, r24
    1f50:	8b 81       	ldd	r24, Y+3	; 0x03
    1f52:	28 2f       	mov	r18, r24
    1f54:	30 e0       	ldi	r19, 0x00	; 0
    1f56:	81 e0       	ldi	r24, 0x01	; 1
    1f58:	90 e0       	ldi	r25, 0x00	; 0
    1f5a:	02 2e       	mov	r0, r18
    1f5c:	02 c0       	rjmp	.+4      	; 0x1f62 <MDIO_u8SetPinDirection+0x1be>
    1f5e:	88 0f       	add	r24, r24
    1f60:	99 1f       	adc	r25, r25
    1f62:	0a 94       	dec	r0
    1f64:	e2 f7       	brpl	.-8      	; 0x1f5e <MDIO_u8SetPinDirection+0x1ba>
    1f66:	84 2b       	or	r24, r20
    1f68:	8c 93       	st	X, r24
    1f6a:	26 c0       	rjmp	.+76     	; 0x1fb8 <MDIO_u8SetPinDirection+0x214>
		  			break;

		  		case MDIO_u8_PORTC:
		  			SET_BIT(MDIO_u8_PORTC_REG,Copy_u8_Pin_Id);
    1f6c:	a5 e3       	ldi	r26, 0x35	; 53
    1f6e:	b0 e0       	ldi	r27, 0x00	; 0
    1f70:	e5 e3       	ldi	r30, 0x35	; 53
    1f72:	f0 e0       	ldi	r31, 0x00	; 0
    1f74:	80 81       	ld	r24, Z
    1f76:	48 2f       	mov	r20, r24
    1f78:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7a:	28 2f       	mov	r18, r24
    1f7c:	30 e0       	ldi	r19, 0x00	; 0
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	02 2e       	mov	r0, r18
    1f84:	02 c0       	rjmp	.+4      	; 0x1f8a <MDIO_u8SetPinDirection+0x1e6>
    1f86:	88 0f       	add	r24, r24
    1f88:	99 1f       	adc	r25, r25
    1f8a:	0a 94       	dec	r0
    1f8c:	e2 f7       	brpl	.-8      	; 0x1f86 <MDIO_u8SetPinDirection+0x1e2>
    1f8e:	84 2b       	or	r24, r20
    1f90:	8c 93       	st	X, r24
    1f92:	12 c0       	rjmp	.+36     	; 0x1fb8 <MDIO_u8SetPinDirection+0x214>
		  			break;

		  		case MDIO_u8_PORTD:
		  			SET_BIT(MDIO_u8_PORTD_REG,Copy_u8_Pin_Id);
    1f94:	a2 e3       	ldi	r26, 0x32	; 50
    1f96:	b0 e0       	ldi	r27, 0x00	; 0
    1f98:	e2 e3       	ldi	r30, 0x32	; 50
    1f9a:	f0 e0       	ldi	r31, 0x00	; 0
    1f9c:	80 81       	ld	r24, Z
    1f9e:	48 2f       	mov	r20, r24
    1fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa2:	28 2f       	mov	r18, r24
    1fa4:	30 e0       	ldi	r19, 0x00	; 0
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	02 c0       	rjmp	.+4      	; 0x1fb0 <MDIO_u8SetPinDirection+0x20c>
    1fac:	88 0f       	add	r24, r24
    1fae:	99 1f       	adc	r25, r25
    1fb0:	2a 95       	dec	r18
    1fb2:	e2 f7       	brpl	.-8      	; 0x1fac <MDIO_u8SetPinDirection+0x208>
    1fb4:	84 2b       	or	r24, r20
    1fb6:	8c 93       	st	X, r24
		  			break;
		  	}
		  	/* no break */

		 case MDIO_u8_INPUT_FLOATING:
		 	switch(Copy_u8_Port_Id)
    1fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fba:	28 2f       	mov	r18, r24
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	3e 83       	std	Y+6, r19	; 0x06
    1fc0:	2d 83       	std	Y+5, r18	; 0x05
    1fc2:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc4:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc6:	81 30       	cpi	r24, 0x01	; 1
    1fc8:	91 05       	cpc	r25, r1
    1fca:	59 f1       	breq	.+86     	; 0x2022 <MDIO_u8SetPinDirection+0x27e>
    1fcc:	2d 81       	ldd	r18, Y+5	; 0x05
    1fce:	3e 81       	ldd	r19, Y+6	; 0x06
    1fd0:	22 30       	cpi	r18, 0x02	; 2
    1fd2:	31 05       	cpc	r19, r1
    1fd4:	2c f4       	brge	.+10     	; 0x1fe0 <MDIO_u8SetPinDirection+0x23c>
    1fd6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fd8:	9e 81       	ldd	r25, Y+6	; 0x06
    1fda:	00 97       	sbiw	r24, 0x00	; 0
    1fdc:	69 f0       	breq	.+26     	; 0x1ff8 <MDIO_u8SetPinDirection+0x254>
    1fde:	61 c0       	rjmp	.+194    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
    1fe0:	2d 81       	ldd	r18, Y+5	; 0x05
    1fe2:	3e 81       	ldd	r19, Y+6	; 0x06
    1fe4:	22 30       	cpi	r18, 0x02	; 2
    1fe6:	31 05       	cpc	r19, r1
    1fe8:	89 f1       	breq	.+98     	; 0x204c <MDIO_u8SetPinDirection+0x2a8>
    1fea:	8d 81       	ldd	r24, Y+5	; 0x05
    1fec:	9e 81       	ldd	r25, Y+6	; 0x06
    1fee:	83 30       	cpi	r24, 0x03	; 3
    1ff0:	91 05       	cpc	r25, r1
    1ff2:	09 f4       	brne	.+2      	; 0x1ff6 <MDIO_u8SetPinDirection+0x252>
    1ff4:	40 c0       	rjmp	.+128    	; 0x2076 <MDIO_u8SetPinDirection+0x2d2>
    1ff6:	55 c0       	rjmp	.+170    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
		 	{
		 		case MDIO_u8_PORTA:
		 			CLR_BIT(MDIO_u8_DDRA_REG,Copy_u8_Pin_Id);
    1ff8:	aa e3       	ldi	r26, 0x3A	; 58
    1ffa:	b0 e0       	ldi	r27, 0x00	; 0
    1ffc:	ea e3       	ldi	r30, 0x3A	; 58
    1ffe:	f0 e0       	ldi	r31, 0x00	; 0
    2000:	80 81       	ld	r24, Z
    2002:	48 2f       	mov	r20, r24
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	28 2f       	mov	r18, r24
    2008:	30 e0       	ldi	r19, 0x00	; 0
    200a:	81 e0       	ldi	r24, 0x01	; 1
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	02 2e       	mov	r0, r18
    2010:	02 c0       	rjmp	.+4      	; 0x2016 <MDIO_u8SetPinDirection+0x272>
    2012:	88 0f       	add	r24, r24
    2014:	99 1f       	adc	r25, r25
    2016:	0a 94       	dec	r0
    2018:	e2 f7       	brpl	.-8      	; 0x2012 <MDIO_u8SetPinDirection+0x26e>
    201a:	80 95       	com	r24
    201c:	84 23       	and	r24, r20
    201e:	8c 93       	st	X, r24
    2020:	40 c0       	rjmp	.+128    	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
		 			break;

		 		case MDIO_u8_PORTB:
		 			CLR_BIT(MDIO_u8_DDRB_REG,Copy_u8_Pin_Id);
    2022:	a7 e3       	ldi	r26, 0x37	; 55
    2024:	b0 e0       	ldi	r27, 0x00	; 0
    2026:	e7 e3       	ldi	r30, 0x37	; 55
    2028:	f0 e0       	ldi	r31, 0x00	; 0
    202a:	80 81       	ld	r24, Z
    202c:	48 2f       	mov	r20, r24
    202e:	8b 81       	ldd	r24, Y+3	; 0x03
    2030:	28 2f       	mov	r18, r24
    2032:	30 e0       	ldi	r19, 0x00	; 0
    2034:	81 e0       	ldi	r24, 0x01	; 1
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	02 2e       	mov	r0, r18
    203a:	02 c0       	rjmp	.+4      	; 0x2040 <MDIO_u8SetPinDirection+0x29c>
    203c:	88 0f       	add	r24, r24
    203e:	99 1f       	adc	r25, r25
    2040:	0a 94       	dec	r0
    2042:	e2 f7       	brpl	.-8      	; 0x203c <MDIO_u8SetPinDirection+0x298>
    2044:	80 95       	com	r24
    2046:	84 23       	and	r24, r20
    2048:	8c 93       	st	X, r24
    204a:	2b c0       	rjmp	.+86     	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
		 			break;

		 		case MDIO_u8_PORTC:
		 			CLR_BIT(MDIO_u8_DDRC_REG,Copy_u8_Pin_Id);
    204c:	a4 e3       	ldi	r26, 0x34	; 52
    204e:	b0 e0       	ldi	r27, 0x00	; 0
    2050:	e4 e3       	ldi	r30, 0x34	; 52
    2052:	f0 e0       	ldi	r31, 0x00	; 0
    2054:	80 81       	ld	r24, Z
    2056:	48 2f       	mov	r20, r24
    2058:	8b 81       	ldd	r24, Y+3	; 0x03
    205a:	28 2f       	mov	r18, r24
    205c:	30 e0       	ldi	r19, 0x00	; 0
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	02 2e       	mov	r0, r18
    2064:	02 c0       	rjmp	.+4      	; 0x206a <MDIO_u8SetPinDirection+0x2c6>
    2066:	88 0f       	add	r24, r24
    2068:	99 1f       	adc	r25, r25
    206a:	0a 94       	dec	r0
    206c:	e2 f7       	brpl	.-8      	; 0x2066 <MDIO_u8SetPinDirection+0x2c2>
    206e:	80 95       	com	r24
    2070:	84 23       	and	r24, r20
    2072:	8c 93       	st	X, r24
    2074:	16 c0       	rjmp	.+44     	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
		 			break;

		 		case MDIO_u8_PORTD:
		 			CLR_BIT(MDIO_u8_DDRD_REG,Copy_u8_Pin_Id);
    2076:	a1 e3       	ldi	r26, 0x31	; 49
    2078:	b0 e0       	ldi	r27, 0x00	; 0
    207a:	e1 e3       	ldi	r30, 0x31	; 49
    207c:	f0 e0       	ldi	r31, 0x00	; 0
    207e:	80 81       	ld	r24, Z
    2080:	48 2f       	mov	r20, r24
    2082:	8b 81       	ldd	r24, Y+3	; 0x03
    2084:	28 2f       	mov	r18, r24
    2086:	30 e0       	ldi	r19, 0x00	; 0
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	90 e0       	ldi	r25, 0x00	; 0
    208c:	02 2e       	mov	r0, r18
    208e:	02 c0       	rjmp	.+4      	; 0x2094 <MDIO_u8SetPinDirection+0x2f0>
    2090:	88 0f       	add	r24, r24
    2092:	99 1f       	adc	r25, r25
    2094:	0a 94       	dec	r0
    2096:	e2 f7       	brpl	.-8      	; 0x2090 <MDIO_u8SetPinDirection+0x2ec>
    2098:	80 95       	com	r24
    209a:	84 23       	and	r24, r20
    209c:	8c 93       	st	X, r24
    209e:	01 c0       	rjmp	.+2      	; 0x20a2 <MDIO_u8SetPinDirection+0x2fe>
		 			break;
		 	}
		 break;

		 	default:
		 	Local_u8ErrorState=STD_TYPES_NOK;
    20a0:	19 82       	std	Y+1, r1	; 0x01
		 	break;
		}
	}

	return Local_u8ErrorState;
    20a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    20a4:	2c 96       	adiw	r28, 0x0c	; 12
    20a6:	0f b6       	in	r0, 0x3f	; 63
    20a8:	f8 94       	cli
    20aa:	de bf       	out	0x3e, r29	; 62
    20ac:	0f be       	out	0x3f, r0	; 63
    20ae:	cd bf       	out	0x3d, r28	; 61
    20b0:	cf 91       	pop	r28
    20b2:	df 91       	pop	r29
    20b4:	08 95       	ret

000020b6 <MDIO_u8SetPinValue>:

u8 MDIO_u8SetPinValue(u8 Copy_u8_Port_Id,u8 Copy_u8_Pin_Id,u8 Copy_u8_Pin_Value)
{
    20b6:	df 93       	push	r29
    20b8:	cf 93       	push	r28
    20ba:	cd b7       	in	r28, 0x3d	; 61
    20bc:	de b7       	in	r29, 0x3e	; 62
    20be:	2a 97       	sbiw	r28, 0x0a	; 10
    20c0:	0f b6       	in	r0, 0x3f	; 63
    20c2:	f8 94       	cli
    20c4:	de bf       	out	0x3e, r29	; 62
    20c6:	0f be       	out	0x3f, r0	; 63
    20c8:	cd bf       	out	0x3d, r28	; 61
    20ca:	8a 83       	std	Y+2, r24	; 0x02
    20cc:	6b 83       	std	Y+3, r22	; 0x03
    20ce:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState= STD_TYPES_NOK;
    20d0:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8_Port_Id<=MDIO_u8_PORTD)&&(Copy_u8_Pin_Id<=MDIO_u8_PIN_7))
    20d2:	8a 81       	ldd	r24, Y+2	; 0x02
    20d4:	84 30       	cpi	r24, 0x04	; 4
    20d6:	08 f0       	brcs	.+2      	; 0x20da <MDIO_u8SetPinValue+0x24>
    20d8:	fa c0       	rjmp	.+500    	; 0x22ce <MDIO_u8SetPinValue+0x218>
    20da:	8b 81       	ldd	r24, Y+3	; 0x03
    20dc:	88 30       	cpi	r24, 0x08	; 8
    20de:	08 f0       	brcs	.+2      	; 0x20e2 <MDIO_u8SetPinValue+0x2c>
    20e0:	f6 c0       	rjmp	.+492    	; 0x22ce <MDIO_u8SetPinValue+0x218>
	{
		Local_u8ErrorState= STD_TYPES_OK;
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	89 83       	std	Y+1, r24	; 0x01
		switch(Copy_u8_Pin_Value)
    20e6:	8c 81       	ldd	r24, Y+4	; 0x04
    20e8:	28 2f       	mov	r18, r24
    20ea:	30 e0       	ldi	r19, 0x00	; 0
    20ec:	3a 87       	std	Y+10, r19	; 0x0a
    20ee:	29 87       	std	Y+9, r18	; 0x09
    20f0:	89 85       	ldd	r24, Y+9	; 0x09
    20f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    20f4:	00 97       	sbiw	r24, 0x00	; 0
    20f6:	09 f4       	brne	.+2      	; 0x20fa <MDIO_u8SetPinValue+0x44>
    20f8:	75 c0       	rjmp	.+234    	; 0x21e4 <MDIO_u8SetPinValue+0x12e>
    20fa:	29 85       	ldd	r18, Y+9	; 0x09
    20fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    20fe:	21 30       	cpi	r18, 0x01	; 1
    2100:	31 05       	cpc	r19, r1
    2102:	09 f0       	breq	.+2      	; 0x2106 <MDIO_u8SetPinValue+0x50>
    2104:	e3 c0       	rjmp	.+454    	; 0x22cc <MDIO_u8SetPinValue+0x216>
		{
			case MDIO_u8_HIGH:
				switch(Copy_u8_Port_Id)
    2106:	8a 81       	ldd	r24, Y+2	; 0x02
    2108:	28 2f       	mov	r18, r24
    210a:	30 e0       	ldi	r19, 0x00	; 0
    210c:	38 87       	std	Y+8, r19	; 0x08
    210e:	2f 83       	std	Y+7, r18	; 0x07
    2110:	8f 81       	ldd	r24, Y+7	; 0x07
    2112:	98 85       	ldd	r25, Y+8	; 0x08
    2114:	81 30       	cpi	r24, 0x01	; 1
    2116:	91 05       	cpc	r25, r1
    2118:	49 f1       	breq	.+82     	; 0x216c <MDIO_u8SetPinValue+0xb6>
    211a:	2f 81       	ldd	r18, Y+7	; 0x07
    211c:	38 85       	ldd	r19, Y+8	; 0x08
    211e:	22 30       	cpi	r18, 0x02	; 2
    2120:	31 05       	cpc	r19, r1
    2122:	2c f4       	brge	.+10     	; 0x212e <MDIO_u8SetPinValue+0x78>
    2124:	8f 81       	ldd	r24, Y+7	; 0x07
    2126:	98 85       	ldd	r25, Y+8	; 0x08
    2128:	00 97       	sbiw	r24, 0x00	; 0
    212a:	61 f0       	breq	.+24     	; 0x2144 <MDIO_u8SetPinValue+0x8e>
    212c:	d0 c0       	rjmp	.+416    	; 0x22ce <MDIO_u8SetPinValue+0x218>
    212e:	2f 81       	ldd	r18, Y+7	; 0x07
    2130:	38 85       	ldd	r19, Y+8	; 0x08
    2132:	22 30       	cpi	r18, 0x02	; 2
    2134:	31 05       	cpc	r19, r1
    2136:	71 f1       	breq	.+92     	; 0x2194 <MDIO_u8SetPinValue+0xde>
    2138:	8f 81       	ldd	r24, Y+7	; 0x07
    213a:	98 85       	ldd	r25, Y+8	; 0x08
    213c:	83 30       	cpi	r24, 0x03	; 3
    213e:	91 05       	cpc	r25, r1
    2140:	e9 f1       	breq	.+122    	; 0x21bc <MDIO_u8SetPinValue+0x106>
    2142:	c5 c0       	rjmp	.+394    	; 0x22ce <MDIO_u8SetPinValue+0x218>
				{
					case MDIO_u8_PORTA:
						SET_BIT(MDIO_u8_PORTA_REG,Copy_u8_Pin_Id);
    2144:	ab e3       	ldi	r26, 0x3B	; 59
    2146:	b0 e0       	ldi	r27, 0x00	; 0
    2148:	eb e3       	ldi	r30, 0x3B	; 59
    214a:	f0 e0       	ldi	r31, 0x00	; 0
    214c:	80 81       	ld	r24, Z
    214e:	48 2f       	mov	r20, r24
    2150:	8b 81       	ldd	r24, Y+3	; 0x03
    2152:	28 2f       	mov	r18, r24
    2154:	30 e0       	ldi	r19, 0x00	; 0
    2156:	81 e0       	ldi	r24, 0x01	; 1
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	02 2e       	mov	r0, r18
    215c:	02 c0       	rjmp	.+4      	; 0x2162 <MDIO_u8SetPinValue+0xac>
    215e:	88 0f       	add	r24, r24
    2160:	99 1f       	adc	r25, r25
    2162:	0a 94       	dec	r0
    2164:	e2 f7       	brpl	.-8      	; 0x215e <MDIO_u8SetPinValue+0xa8>
    2166:	84 2b       	or	r24, r20
    2168:	8c 93       	st	X, r24
    216a:	b1 c0       	rjmp	.+354    	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;

					case MDIO_u8_PORTB:
						SET_BIT(MDIO_u8_PORTB_REG,Copy_u8_Pin_Id);
    216c:	a8 e3       	ldi	r26, 0x38	; 56
    216e:	b0 e0       	ldi	r27, 0x00	; 0
    2170:	e8 e3       	ldi	r30, 0x38	; 56
    2172:	f0 e0       	ldi	r31, 0x00	; 0
    2174:	80 81       	ld	r24, Z
    2176:	48 2f       	mov	r20, r24
    2178:	8b 81       	ldd	r24, Y+3	; 0x03
    217a:	28 2f       	mov	r18, r24
    217c:	30 e0       	ldi	r19, 0x00	; 0
    217e:	81 e0       	ldi	r24, 0x01	; 1
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	02 2e       	mov	r0, r18
    2184:	02 c0       	rjmp	.+4      	; 0x218a <MDIO_u8SetPinValue+0xd4>
    2186:	88 0f       	add	r24, r24
    2188:	99 1f       	adc	r25, r25
    218a:	0a 94       	dec	r0
    218c:	e2 f7       	brpl	.-8      	; 0x2186 <MDIO_u8SetPinValue+0xd0>
    218e:	84 2b       	or	r24, r20
    2190:	8c 93       	st	X, r24
    2192:	9d c0       	rjmp	.+314    	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;

					case MDIO_u8_PORTC:
						SET_BIT(MDIO_u8_PORTC_REG,Copy_u8_Pin_Id);
    2194:	a5 e3       	ldi	r26, 0x35	; 53
    2196:	b0 e0       	ldi	r27, 0x00	; 0
    2198:	e5 e3       	ldi	r30, 0x35	; 53
    219a:	f0 e0       	ldi	r31, 0x00	; 0
    219c:	80 81       	ld	r24, Z
    219e:	48 2f       	mov	r20, r24
    21a0:	8b 81       	ldd	r24, Y+3	; 0x03
    21a2:	28 2f       	mov	r18, r24
    21a4:	30 e0       	ldi	r19, 0x00	; 0
    21a6:	81 e0       	ldi	r24, 0x01	; 1
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	02 2e       	mov	r0, r18
    21ac:	02 c0       	rjmp	.+4      	; 0x21b2 <MDIO_u8SetPinValue+0xfc>
    21ae:	88 0f       	add	r24, r24
    21b0:	99 1f       	adc	r25, r25
    21b2:	0a 94       	dec	r0
    21b4:	e2 f7       	brpl	.-8      	; 0x21ae <MDIO_u8SetPinValue+0xf8>
    21b6:	84 2b       	or	r24, r20
    21b8:	8c 93       	st	X, r24
    21ba:	89 c0       	rjmp	.+274    	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;

					case MDIO_u8_PORTD:
						SET_BIT(MDIO_u8_PORTD_REG,Copy_u8_Pin_Id);
    21bc:	a2 e3       	ldi	r26, 0x32	; 50
    21be:	b0 e0       	ldi	r27, 0x00	; 0
    21c0:	e2 e3       	ldi	r30, 0x32	; 50
    21c2:	f0 e0       	ldi	r31, 0x00	; 0
    21c4:	80 81       	ld	r24, Z
    21c6:	48 2f       	mov	r20, r24
    21c8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ca:	28 2f       	mov	r18, r24
    21cc:	30 e0       	ldi	r19, 0x00	; 0
    21ce:	81 e0       	ldi	r24, 0x01	; 1
    21d0:	90 e0       	ldi	r25, 0x00	; 0
    21d2:	02 2e       	mov	r0, r18
    21d4:	02 c0       	rjmp	.+4      	; 0x21da <MDIO_u8SetPinValue+0x124>
    21d6:	88 0f       	add	r24, r24
    21d8:	99 1f       	adc	r25, r25
    21da:	0a 94       	dec	r0
    21dc:	e2 f7       	brpl	.-8      	; 0x21d6 <MDIO_u8SetPinValue+0x120>
    21de:	84 2b       	or	r24, r20
    21e0:	8c 93       	st	X, r24
    21e2:	75 c0       	rjmp	.+234    	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;
				}
			break;

			case MDIO_u8_LOW:
				switch(Copy_u8_Port_Id)
    21e4:	8a 81       	ldd	r24, Y+2	; 0x02
    21e6:	28 2f       	mov	r18, r24
    21e8:	30 e0       	ldi	r19, 0x00	; 0
    21ea:	3e 83       	std	Y+6, r19	; 0x06
    21ec:	2d 83       	std	Y+5, r18	; 0x05
    21ee:	8d 81       	ldd	r24, Y+5	; 0x05
    21f0:	9e 81       	ldd	r25, Y+6	; 0x06
    21f2:	81 30       	cpi	r24, 0x01	; 1
    21f4:	91 05       	cpc	r25, r1
    21f6:	59 f1       	breq	.+86     	; 0x224e <MDIO_u8SetPinValue+0x198>
    21f8:	2d 81       	ldd	r18, Y+5	; 0x05
    21fa:	3e 81       	ldd	r19, Y+6	; 0x06
    21fc:	22 30       	cpi	r18, 0x02	; 2
    21fe:	31 05       	cpc	r19, r1
    2200:	2c f4       	brge	.+10     	; 0x220c <MDIO_u8SetPinValue+0x156>
    2202:	8d 81       	ldd	r24, Y+5	; 0x05
    2204:	9e 81       	ldd	r25, Y+6	; 0x06
    2206:	00 97       	sbiw	r24, 0x00	; 0
    2208:	69 f0       	breq	.+26     	; 0x2224 <MDIO_u8SetPinValue+0x16e>
    220a:	61 c0       	rjmp	.+194    	; 0x22ce <MDIO_u8SetPinValue+0x218>
    220c:	2d 81       	ldd	r18, Y+5	; 0x05
    220e:	3e 81       	ldd	r19, Y+6	; 0x06
    2210:	22 30       	cpi	r18, 0x02	; 2
    2212:	31 05       	cpc	r19, r1
    2214:	89 f1       	breq	.+98     	; 0x2278 <MDIO_u8SetPinValue+0x1c2>
    2216:	8d 81       	ldd	r24, Y+5	; 0x05
    2218:	9e 81       	ldd	r25, Y+6	; 0x06
    221a:	83 30       	cpi	r24, 0x03	; 3
    221c:	91 05       	cpc	r25, r1
    221e:	09 f4       	brne	.+2      	; 0x2222 <MDIO_u8SetPinValue+0x16c>
    2220:	40 c0       	rjmp	.+128    	; 0x22a2 <MDIO_u8SetPinValue+0x1ec>
    2222:	55 c0       	rjmp	.+170    	; 0x22ce <MDIO_u8SetPinValue+0x218>
				{
					case MDIO_u8_PORTA:
						CLR_BIT(MDIO_u8_PORTA_REG,Copy_u8_Pin_Id);
    2224:	ab e3       	ldi	r26, 0x3B	; 59
    2226:	b0 e0       	ldi	r27, 0x00	; 0
    2228:	eb e3       	ldi	r30, 0x3B	; 59
    222a:	f0 e0       	ldi	r31, 0x00	; 0
    222c:	80 81       	ld	r24, Z
    222e:	48 2f       	mov	r20, r24
    2230:	8b 81       	ldd	r24, Y+3	; 0x03
    2232:	28 2f       	mov	r18, r24
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	02 2e       	mov	r0, r18
    223c:	02 c0       	rjmp	.+4      	; 0x2242 <MDIO_u8SetPinValue+0x18c>
    223e:	88 0f       	add	r24, r24
    2240:	99 1f       	adc	r25, r25
    2242:	0a 94       	dec	r0
    2244:	e2 f7       	brpl	.-8      	; 0x223e <MDIO_u8SetPinValue+0x188>
    2246:	80 95       	com	r24
    2248:	84 23       	and	r24, r20
    224a:	8c 93       	st	X, r24
    224c:	40 c0       	rjmp	.+128    	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;

					case MDIO_u8_PORTB:
						CLR_BIT(MDIO_u8_PORTB_REG,Copy_u8_Pin_Id);
    224e:	a8 e3       	ldi	r26, 0x38	; 56
    2250:	b0 e0       	ldi	r27, 0x00	; 0
    2252:	e8 e3       	ldi	r30, 0x38	; 56
    2254:	f0 e0       	ldi	r31, 0x00	; 0
    2256:	80 81       	ld	r24, Z
    2258:	48 2f       	mov	r20, r24
    225a:	8b 81       	ldd	r24, Y+3	; 0x03
    225c:	28 2f       	mov	r18, r24
    225e:	30 e0       	ldi	r19, 0x00	; 0
    2260:	81 e0       	ldi	r24, 0x01	; 1
    2262:	90 e0       	ldi	r25, 0x00	; 0
    2264:	02 2e       	mov	r0, r18
    2266:	02 c0       	rjmp	.+4      	; 0x226c <MDIO_u8SetPinValue+0x1b6>
    2268:	88 0f       	add	r24, r24
    226a:	99 1f       	adc	r25, r25
    226c:	0a 94       	dec	r0
    226e:	e2 f7       	brpl	.-8      	; 0x2268 <MDIO_u8SetPinValue+0x1b2>
    2270:	80 95       	com	r24
    2272:	84 23       	and	r24, r20
    2274:	8c 93       	st	X, r24
    2276:	2b c0       	rjmp	.+86     	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;

					case MDIO_u8_PORTC:
						CLR_BIT(MDIO_u8_PORTC_REG,Copy_u8_Pin_Id);
    2278:	a5 e3       	ldi	r26, 0x35	; 53
    227a:	b0 e0       	ldi	r27, 0x00	; 0
    227c:	e5 e3       	ldi	r30, 0x35	; 53
    227e:	f0 e0       	ldi	r31, 0x00	; 0
    2280:	80 81       	ld	r24, Z
    2282:	48 2f       	mov	r20, r24
    2284:	8b 81       	ldd	r24, Y+3	; 0x03
    2286:	28 2f       	mov	r18, r24
    2288:	30 e0       	ldi	r19, 0x00	; 0
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	90 e0       	ldi	r25, 0x00	; 0
    228e:	02 2e       	mov	r0, r18
    2290:	02 c0       	rjmp	.+4      	; 0x2296 <MDIO_u8SetPinValue+0x1e0>
    2292:	88 0f       	add	r24, r24
    2294:	99 1f       	adc	r25, r25
    2296:	0a 94       	dec	r0
    2298:	e2 f7       	brpl	.-8      	; 0x2292 <MDIO_u8SetPinValue+0x1dc>
    229a:	80 95       	com	r24
    229c:	84 23       	and	r24, r20
    229e:	8c 93       	st	X, r24
    22a0:	16 c0       	rjmp	.+44     	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;

					case MDIO_u8_PORTD:
						CLR_BIT(MDIO_u8_PORTD_REG,Copy_u8_Pin_Id);
    22a2:	a2 e3       	ldi	r26, 0x32	; 50
    22a4:	b0 e0       	ldi	r27, 0x00	; 0
    22a6:	e2 e3       	ldi	r30, 0x32	; 50
    22a8:	f0 e0       	ldi	r31, 0x00	; 0
    22aa:	80 81       	ld	r24, Z
    22ac:	48 2f       	mov	r20, r24
    22ae:	8b 81       	ldd	r24, Y+3	; 0x03
    22b0:	28 2f       	mov	r18, r24
    22b2:	30 e0       	ldi	r19, 0x00	; 0
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	90 e0       	ldi	r25, 0x00	; 0
    22b8:	02 2e       	mov	r0, r18
    22ba:	02 c0       	rjmp	.+4      	; 0x22c0 <MDIO_u8SetPinValue+0x20a>
    22bc:	88 0f       	add	r24, r24
    22be:	99 1f       	adc	r25, r25
    22c0:	0a 94       	dec	r0
    22c2:	e2 f7       	brpl	.-8      	; 0x22bc <MDIO_u8SetPinValue+0x206>
    22c4:	80 95       	com	r24
    22c6:	84 23       	and	r24, r20
    22c8:	8c 93       	st	X, r24
    22ca:	01 c0       	rjmp	.+2      	; 0x22ce <MDIO_u8SetPinValue+0x218>
						break;
				}
			break;

			default:
			Local_u8ErrorState=STD_TYPES_NOK;
    22cc:	19 82       	std	Y+1, r1	; 0x01
			break;
		}
	}
	return Local_u8ErrorState ;
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    22d0:	2a 96       	adiw	r28, 0x0a	; 10
    22d2:	0f b6       	in	r0, 0x3f	; 63
    22d4:	f8 94       	cli
    22d6:	de bf       	out	0x3e, r29	; 62
    22d8:	0f be       	out	0x3f, r0	; 63
    22da:	cd bf       	out	0x3d, r28	; 61
    22dc:	cf 91       	pop	r28
    22de:	df 91       	pop	r29
    22e0:	08 95       	ret

000022e2 <MDIO_u8GetPinValue>:

u8 MDIO_u8GetPinValue(u8 Copy_u8_Port_Id,u8 Copy_u8_Pin_Id,u8* Copy_Pu8_Pin_Value)
{
    22e2:	df 93       	push	r29
    22e4:	cf 93       	push	r28
    22e6:	cd b7       	in	r28, 0x3d	; 61
    22e8:	de b7       	in	r29, 0x3e	; 62
    22ea:	27 97       	sbiw	r28, 0x07	; 7
    22ec:	0f b6       	in	r0, 0x3f	; 63
    22ee:	f8 94       	cli
    22f0:	de bf       	out	0x3e, r29	; 62
    22f2:	0f be       	out	0x3f, r0	; 63
    22f4:	cd bf       	out	0x3d, r28	; 61
    22f6:	8a 83       	std	Y+2, r24	; 0x02
    22f8:	6b 83       	std	Y+3, r22	; 0x03
    22fa:	5d 83       	std	Y+5, r21	; 0x05
    22fc:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=STD_TYPES_NOK;
    22fe:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8_Port_Id<=MDIO_u8_PORTD)&&(Copy_u8_Pin_Id<=MDIO_u8_PIN_7)
    2300:	8a 81       	ldd	r24, Y+2	; 0x02
    2302:	84 30       	cpi	r24, 0x04	; 4
    2304:	08 f0       	brcs	.+2      	; 0x2308 <MDIO_u8GetPinValue+0x26>
    2306:	7d c0       	rjmp	.+250    	; 0x2402 <MDIO_u8GetPinValue+0x120>
    2308:	8b 81       	ldd	r24, Y+3	; 0x03
    230a:	88 30       	cpi	r24, 0x08	; 8
    230c:	08 f0       	brcs	.+2      	; 0x2310 <MDIO_u8GetPinValue+0x2e>
    230e:	79 c0       	rjmp	.+242    	; 0x2402 <MDIO_u8GetPinValue+0x120>
    2310:	8c 81       	ldd	r24, Y+4	; 0x04
    2312:	9d 81       	ldd	r25, Y+5	; 0x05
    2314:	00 97       	sbiw	r24, 0x00	; 0
    2316:	09 f4       	brne	.+2      	; 0x231a <MDIO_u8GetPinValue+0x38>
    2318:	74 c0       	rjmp	.+232    	; 0x2402 <MDIO_u8GetPinValue+0x120>
			&&(Copy_Pu8_Pin_Value!=STD_TYPES_NULL))
	{
		Local_u8ErrorState=STD_TYPES_OK;
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	89 83       	std	Y+1, r24	; 0x01
		switch(Copy_u8_Port_Id)
    231e:	8a 81       	ldd	r24, Y+2	; 0x02
    2320:	28 2f       	mov	r18, r24
    2322:	30 e0       	ldi	r19, 0x00	; 0
    2324:	3f 83       	std	Y+7, r19	; 0x07
    2326:	2e 83       	std	Y+6, r18	; 0x06
    2328:	4e 81       	ldd	r20, Y+6	; 0x06
    232a:	5f 81       	ldd	r21, Y+7	; 0x07
    232c:	41 30       	cpi	r20, 0x01	; 1
    232e:	51 05       	cpc	r21, r1
    2330:	59 f1       	breq	.+86     	; 0x2388 <MDIO_u8GetPinValue+0xa6>
    2332:	8e 81       	ldd	r24, Y+6	; 0x06
    2334:	9f 81       	ldd	r25, Y+7	; 0x07
    2336:	82 30       	cpi	r24, 0x02	; 2
    2338:	91 05       	cpc	r25, r1
    233a:	34 f4       	brge	.+12     	; 0x2348 <MDIO_u8GetPinValue+0x66>
    233c:	2e 81       	ldd	r18, Y+6	; 0x06
    233e:	3f 81       	ldd	r19, Y+7	; 0x07
    2340:	21 15       	cp	r18, r1
    2342:	31 05       	cpc	r19, r1
    2344:	69 f0       	breq	.+26     	; 0x2360 <MDIO_u8GetPinValue+0x7e>
    2346:	5c c0       	rjmp	.+184    	; 0x2400 <MDIO_u8GetPinValue+0x11e>
    2348:	4e 81       	ldd	r20, Y+6	; 0x06
    234a:	5f 81       	ldd	r21, Y+7	; 0x07
    234c:	42 30       	cpi	r20, 0x02	; 2
    234e:	51 05       	cpc	r21, r1
    2350:	79 f1       	breq	.+94     	; 0x23b0 <MDIO_u8GetPinValue+0xce>
    2352:	8e 81       	ldd	r24, Y+6	; 0x06
    2354:	9f 81       	ldd	r25, Y+7	; 0x07
    2356:	83 30       	cpi	r24, 0x03	; 3
    2358:	91 05       	cpc	r25, r1
    235a:	09 f4       	brne	.+2      	; 0x235e <MDIO_u8GetPinValue+0x7c>
    235c:	3d c0       	rjmp	.+122    	; 0x23d8 <MDIO_u8GetPinValue+0xf6>
    235e:	50 c0       	rjmp	.+160    	; 0x2400 <MDIO_u8GetPinValue+0x11e>
		{
		    case MDIO_u8_PORTA:
			*Copy_Pu8_Pin_Value=GET_BIT(MDIO_u8_PINA_REG,Copy_u8_Pin_Id);
    2360:	e9 e3       	ldi	r30, 0x39	; 57
    2362:	f0 e0       	ldi	r31, 0x00	; 0
    2364:	80 81       	ld	r24, Z
    2366:	28 2f       	mov	r18, r24
    2368:	30 e0       	ldi	r19, 0x00	; 0
    236a:	8b 81       	ldd	r24, Y+3	; 0x03
    236c:	88 2f       	mov	r24, r24
    236e:	90 e0       	ldi	r25, 0x00	; 0
    2370:	a9 01       	movw	r20, r18
    2372:	02 c0       	rjmp	.+4      	; 0x2378 <MDIO_u8GetPinValue+0x96>
    2374:	55 95       	asr	r21
    2376:	47 95       	ror	r20
    2378:	8a 95       	dec	r24
    237a:	e2 f7       	brpl	.-8      	; 0x2374 <MDIO_u8GetPinValue+0x92>
    237c:	ca 01       	movw	r24, r20
    237e:	81 70       	andi	r24, 0x01	; 1
    2380:	ec 81       	ldd	r30, Y+4	; 0x04
    2382:	fd 81       	ldd	r31, Y+5	; 0x05
    2384:	80 83       	st	Z, r24
    2386:	3d c0       	rjmp	.+122    	; 0x2402 <MDIO_u8GetPinValue+0x120>
			break;

		    case MDIO_u8_PORTB:
		    *Copy_Pu8_Pin_Value=GET_BIT(MDIO_u8_PINB_REG,Copy_u8_Pin_Id);
    2388:	e6 e3       	ldi	r30, 0x36	; 54
    238a:	f0 e0       	ldi	r31, 0x00	; 0
    238c:	80 81       	ld	r24, Z
    238e:	28 2f       	mov	r18, r24
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	8b 81       	ldd	r24, Y+3	; 0x03
    2394:	88 2f       	mov	r24, r24
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	a9 01       	movw	r20, r18
    239a:	02 c0       	rjmp	.+4      	; 0x23a0 <MDIO_u8GetPinValue+0xbe>
    239c:	55 95       	asr	r21
    239e:	47 95       	ror	r20
    23a0:	8a 95       	dec	r24
    23a2:	e2 f7       	brpl	.-8      	; 0x239c <MDIO_u8GetPinValue+0xba>
    23a4:	ca 01       	movw	r24, r20
    23a6:	81 70       	andi	r24, 0x01	; 1
    23a8:	ec 81       	ldd	r30, Y+4	; 0x04
    23aa:	fd 81       	ldd	r31, Y+5	; 0x05
    23ac:	80 83       	st	Z, r24
    23ae:	29 c0       	rjmp	.+82     	; 0x2402 <MDIO_u8GetPinValue+0x120>
			break;

		    case MDIO_u8_PORTC:
		    *Copy_Pu8_Pin_Value=GET_BIT(MDIO_u8_PINC_REG,Copy_u8_Pin_Id);
    23b0:	e3 e3       	ldi	r30, 0x33	; 51
    23b2:	f0 e0       	ldi	r31, 0x00	; 0
    23b4:	80 81       	ld	r24, Z
    23b6:	28 2f       	mov	r18, r24
    23b8:	30 e0       	ldi	r19, 0x00	; 0
    23ba:	8b 81       	ldd	r24, Y+3	; 0x03
    23bc:	88 2f       	mov	r24, r24
    23be:	90 e0       	ldi	r25, 0x00	; 0
    23c0:	a9 01       	movw	r20, r18
    23c2:	02 c0       	rjmp	.+4      	; 0x23c8 <MDIO_u8GetPinValue+0xe6>
    23c4:	55 95       	asr	r21
    23c6:	47 95       	ror	r20
    23c8:	8a 95       	dec	r24
    23ca:	e2 f7       	brpl	.-8      	; 0x23c4 <MDIO_u8GetPinValue+0xe2>
    23cc:	ca 01       	movw	r24, r20
    23ce:	81 70       	andi	r24, 0x01	; 1
    23d0:	ec 81       	ldd	r30, Y+4	; 0x04
    23d2:	fd 81       	ldd	r31, Y+5	; 0x05
    23d4:	80 83       	st	Z, r24
    23d6:	15 c0       	rjmp	.+42     	; 0x2402 <MDIO_u8GetPinValue+0x120>
			break;

		    case MDIO_u8_PORTD:
		    *Copy_Pu8_Pin_Value=GET_BIT(MDIO_u8_PIND_REG,Copy_u8_Pin_Id);
    23d8:	e0 e3       	ldi	r30, 0x30	; 48
    23da:	f0 e0       	ldi	r31, 0x00	; 0
    23dc:	80 81       	ld	r24, Z
    23de:	28 2f       	mov	r18, r24
    23e0:	30 e0       	ldi	r19, 0x00	; 0
    23e2:	8b 81       	ldd	r24, Y+3	; 0x03
    23e4:	88 2f       	mov	r24, r24
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	a9 01       	movw	r20, r18
    23ea:	02 c0       	rjmp	.+4      	; 0x23f0 <MDIO_u8GetPinValue+0x10e>
    23ec:	55 95       	asr	r21
    23ee:	47 95       	ror	r20
    23f0:	8a 95       	dec	r24
    23f2:	e2 f7       	brpl	.-8      	; 0x23ec <MDIO_u8GetPinValue+0x10a>
    23f4:	ca 01       	movw	r24, r20
    23f6:	81 70       	andi	r24, 0x01	; 1
    23f8:	ec 81       	ldd	r30, Y+4	; 0x04
    23fa:	fd 81       	ldd	r31, Y+5	; 0x05
    23fc:	80 83       	st	Z, r24
    23fe:	01 c0       	rjmp	.+2      	; 0x2402 <MDIO_u8GetPinValue+0x120>
			break;

		    default:
		    Local_u8ErrorState=STD_TYPES_NOK;
    2400:	19 82       	std	Y+1, r1	; 0x01
		    break;
		}
	}

	return Local_u8ErrorState;
    2402:	89 81       	ldd	r24, Y+1	; 0x01
}
    2404:	27 96       	adiw	r28, 0x07	; 7
    2406:	0f b6       	in	r0, 0x3f	; 63
    2408:	f8 94       	cli
    240a:	de bf       	out	0x3e, r29	; 62
    240c:	0f be       	out	0x3f, r0	; 63
    240e:	cd bf       	out	0x3d, r28	; 61
    2410:	cf 91       	pop	r28
    2412:	df 91       	pop	r29
    2414:	08 95       	ret

00002416 <MDIO_u8SetPortDirection>:


u8 MDIO_u8SetPortDirection(u8 Copy_u8_Port_Id,u8 Copy_u8_Port_Direction)
{
    2416:	df 93       	push	r29
    2418:	cf 93       	push	r28
    241a:	cd b7       	in	r28, 0x3d	; 61
    241c:	de b7       	in	r29, 0x3e	; 62
    241e:	2b 97       	sbiw	r28, 0x0b	; 11
    2420:	0f b6       	in	r0, 0x3f	; 63
    2422:	f8 94       	cli
    2424:	de bf       	out	0x3e, r29	; 62
    2426:	0f be       	out	0x3f, r0	; 63
    2428:	cd bf       	out	0x3d, r28	; 61
    242a:	8a 83       	std	Y+2, r24	; 0x02
    242c:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=STD_TYPES_NOK;
    242e:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8_Port_Id<=MDIO_u8_PORTD)
    2430:	8a 81       	ldd	r24, Y+2	; 0x02
    2432:	84 30       	cpi	r24, 0x04	; 4
    2434:	08 f0       	brcs	.+2      	; 0x2438 <MDIO_u8SetPortDirection+0x22>
    2436:	ac c0       	rjmp	.+344    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
	{
		Local_u8ErrorState=STD_TYPES_OK;
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	89 83       	std	Y+1, r24	; 0x01
		switch(Copy_u8_Port_Direction)
    243c:	8b 81       	ldd	r24, Y+3	; 0x03
    243e:	28 2f       	mov	r18, r24
    2440:	30 e0       	ldi	r19, 0x00	; 0
    2442:	3b 87       	std	Y+11, r19	; 0x0b
    2444:	2a 87       	std	Y+10, r18	; 0x0a
    2446:	8a 85       	ldd	r24, Y+10	; 0x0a
    2448:	9b 85       	ldd	r25, Y+11	; 0x0b
    244a:	81 30       	cpi	r24, 0x01	; 1
    244c:	91 05       	cpc	r25, r1
    244e:	59 f0       	breq	.+22     	; 0x2466 <MDIO_u8SetPortDirection+0x50>
    2450:	2a 85       	ldd	r18, Y+10	; 0x0a
    2452:	3b 85       	ldd	r19, Y+11	; 0x0b
    2454:	22 30       	cpi	r18, 0x02	; 2
    2456:	31 05       	cpc	r19, r1
    2458:	09 f4       	brne	.+2      	; 0x245c <MDIO_u8SetPortDirection+0x46>
    245a:	6a c0       	rjmp	.+212    	; 0x2530 <MDIO_u8SetPortDirection+0x11a>
    245c:	8a 85       	ldd	r24, Y+10	; 0x0a
    245e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2460:	00 97       	sbiw	r24, 0x00	; 0
    2462:	a1 f1       	breq	.+104    	; 0x24cc <MDIO_u8SetPortDirection+0xb6>
    2464:	94 c0       	rjmp	.+296    	; 0x258e <MDIO_u8SetPortDirection+0x178>
		{
			case MDIO_u8_OUTPUT:
				switch(Copy_u8_Port_Id)
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	28 2f       	mov	r18, r24
    246a:	30 e0       	ldi	r19, 0x00	; 0
    246c:	39 87       	std	Y+9, r19	; 0x09
    246e:	28 87       	std	Y+8, r18	; 0x08
    2470:	88 85       	ldd	r24, Y+8	; 0x08
    2472:	99 85       	ldd	r25, Y+9	; 0x09
    2474:	81 30       	cpi	r24, 0x01	; 1
    2476:	91 05       	cpc	r25, r1
    2478:	d1 f0       	breq	.+52     	; 0x24ae <MDIO_u8SetPortDirection+0x98>
    247a:	28 85       	ldd	r18, Y+8	; 0x08
    247c:	39 85       	ldd	r19, Y+9	; 0x09
    247e:	22 30       	cpi	r18, 0x02	; 2
    2480:	31 05       	cpc	r19, r1
    2482:	2c f4       	brge	.+10     	; 0x248e <MDIO_u8SetPortDirection+0x78>
    2484:	88 85       	ldd	r24, Y+8	; 0x08
    2486:	99 85       	ldd	r25, Y+9	; 0x09
    2488:	00 97       	sbiw	r24, 0x00	; 0
    248a:	61 f0       	breq	.+24     	; 0x24a4 <MDIO_u8SetPortDirection+0x8e>
    248c:	81 c0       	rjmp	.+258    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
    248e:	28 85       	ldd	r18, Y+8	; 0x08
    2490:	39 85       	ldd	r19, Y+9	; 0x09
    2492:	22 30       	cpi	r18, 0x02	; 2
    2494:	31 05       	cpc	r19, r1
    2496:	81 f0       	breq	.+32     	; 0x24b8 <MDIO_u8SetPortDirection+0xa2>
    2498:	88 85       	ldd	r24, Y+8	; 0x08
    249a:	99 85       	ldd	r25, Y+9	; 0x09
    249c:	83 30       	cpi	r24, 0x03	; 3
    249e:	91 05       	cpc	r25, r1
    24a0:	81 f0       	breq	.+32     	; 0x24c2 <MDIO_u8SetPortDirection+0xac>
    24a2:	76 c0       	rjmp	.+236    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
				{
					case MDIO_u8_PORTA:
						MDIO_u8_DDRA_REG=0xff;
    24a4:	ea e3       	ldi	r30, 0x3A	; 58
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	8f ef       	ldi	r24, 0xFF	; 255
    24aa:	80 83       	st	Z, r24
    24ac:	71 c0       	rjmp	.+226    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
						break;

					case MDIO_u8_PORTB:
						MDIO_u8_DDRB_REG=0xff;
    24ae:	e7 e3       	ldi	r30, 0x37	; 55
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	8f ef       	ldi	r24, 0xFF	; 255
    24b4:	80 83       	st	Z, r24
    24b6:	6c c0       	rjmp	.+216    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
						break;

					case MDIO_u8_PORTC:
						MDIO_u8_DDRC_REG=0xff;
    24b8:	e4 e3       	ldi	r30, 0x34	; 52
    24ba:	f0 e0       	ldi	r31, 0x00	; 0
    24bc:	8f ef       	ldi	r24, 0xFF	; 255
    24be:	80 83       	st	Z, r24
    24c0:	67 c0       	rjmp	.+206    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
						break;

					case MDIO_u8_PORTD:
						MDIO_u8_DDRD_REG=0xff;
    24c2:	e1 e3       	ldi	r30, 0x31	; 49
    24c4:	f0 e0       	ldi	r31, 0x00	; 0
    24c6:	8f ef       	ldi	r24, 0xFF	; 255
    24c8:	80 83       	st	Z, r24
    24ca:	62 c0       	rjmp	.+196    	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
						break;
				}
				break;

		   case MDIO_u8_INPUT_PULLED_UP:
			   switch(Copy_u8_Port_Id)
    24cc:	8a 81       	ldd	r24, Y+2	; 0x02
    24ce:	28 2f       	mov	r18, r24
    24d0:	30 e0       	ldi	r19, 0x00	; 0
    24d2:	3f 83       	std	Y+7, r19	; 0x07
    24d4:	2e 83       	std	Y+6, r18	; 0x06
    24d6:	8e 81       	ldd	r24, Y+6	; 0x06
    24d8:	9f 81       	ldd	r25, Y+7	; 0x07
    24da:	81 30       	cpi	r24, 0x01	; 1
    24dc:	91 05       	cpc	r25, r1
    24de:	d1 f0       	breq	.+52     	; 0x2514 <MDIO_u8SetPortDirection+0xfe>
    24e0:	2e 81       	ldd	r18, Y+6	; 0x06
    24e2:	3f 81       	ldd	r19, Y+7	; 0x07
    24e4:	22 30       	cpi	r18, 0x02	; 2
    24e6:	31 05       	cpc	r19, r1
    24e8:	2c f4       	brge	.+10     	; 0x24f4 <MDIO_u8SetPortDirection+0xde>
    24ea:	8e 81       	ldd	r24, Y+6	; 0x06
    24ec:	9f 81       	ldd	r25, Y+7	; 0x07
    24ee:	00 97       	sbiw	r24, 0x00	; 0
    24f0:	61 f0       	breq	.+24     	; 0x250a <MDIO_u8SetPortDirection+0xf4>
    24f2:	1e c0       	rjmp	.+60     	; 0x2530 <MDIO_u8SetPortDirection+0x11a>
    24f4:	2e 81       	ldd	r18, Y+6	; 0x06
    24f6:	3f 81       	ldd	r19, Y+7	; 0x07
    24f8:	22 30       	cpi	r18, 0x02	; 2
    24fa:	31 05       	cpc	r19, r1
    24fc:	81 f0       	breq	.+32     	; 0x251e <MDIO_u8SetPortDirection+0x108>
    24fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2500:	9f 81       	ldd	r25, Y+7	; 0x07
    2502:	83 30       	cpi	r24, 0x03	; 3
    2504:	91 05       	cpc	r25, r1
    2506:	81 f0       	breq	.+32     	; 0x2528 <MDIO_u8SetPortDirection+0x112>
    2508:	13 c0       	rjmp	.+38     	; 0x2530 <MDIO_u8SetPortDirection+0x11a>
			   {
			   	case MDIO_u8_PORTA:
			   		MDIO_u8_PORTA_REG=0xff;
    250a:	eb e3       	ldi	r30, 0x3B	; 59
    250c:	f0 e0       	ldi	r31, 0x00	; 0
    250e:	8f ef       	ldi	r24, 0xFF	; 255
    2510:	80 83       	st	Z, r24
    2512:	0e c0       	rjmp	.+28     	; 0x2530 <MDIO_u8SetPortDirection+0x11a>
			   		break;

			   	case MDIO_u8_PORTB:
			   		MDIO_u8_PORTB_REG=0xff;
    2514:	e8 e3       	ldi	r30, 0x38	; 56
    2516:	f0 e0       	ldi	r31, 0x00	; 0
    2518:	8f ef       	ldi	r24, 0xFF	; 255
    251a:	80 83       	st	Z, r24
    251c:	09 c0       	rjmp	.+18     	; 0x2530 <MDIO_u8SetPortDirection+0x11a>
			   		break;

			   	case MDIO_u8_PORTC:
			   		MDIO_u8_PORTC_REG=0xff;
    251e:	e5 e3       	ldi	r30, 0x35	; 53
    2520:	f0 e0       	ldi	r31, 0x00	; 0
    2522:	8f ef       	ldi	r24, 0xFF	; 255
    2524:	80 83       	st	Z, r24
    2526:	04 c0       	rjmp	.+8      	; 0x2530 <MDIO_u8SetPortDirection+0x11a>
			   		break;

			   	case MDIO_u8_PORTD:
			   		MDIO_u8_PORTD_REG=0xff;
    2528:	e2 e3       	ldi	r30, 0x32	; 50
    252a:	f0 e0       	ldi	r31, 0x00	; 0
    252c:	8f ef       	ldi	r24, 0xFF	; 255
    252e:	80 83       	st	Z, r24
			   		break;
			   }
			   /* no break */

		 case MDIO_u8_INPUT_FLOATING:
			 switch(Copy_u8_Port_Id)
    2530:	8a 81       	ldd	r24, Y+2	; 0x02
    2532:	28 2f       	mov	r18, r24
    2534:	30 e0       	ldi	r19, 0x00	; 0
    2536:	3d 83       	std	Y+5, r19	; 0x05
    2538:	2c 83       	std	Y+4, r18	; 0x04
    253a:	8c 81       	ldd	r24, Y+4	; 0x04
    253c:	9d 81       	ldd	r25, Y+5	; 0x05
    253e:	81 30       	cpi	r24, 0x01	; 1
    2540:	91 05       	cpc	r25, r1
    2542:	c9 f0       	breq	.+50     	; 0x2576 <MDIO_u8SetPortDirection+0x160>
    2544:	2c 81       	ldd	r18, Y+4	; 0x04
    2546:	3d 81       	ldd	r19, Y+5	; 0x05
    2548:	22 30       	cpi	r18, 0x02	; 2
    254a:	31 05       	cpc	r19, r1
    254c:	2c f4       	brge	.+10     	; 0x2558 <MDIO_u8SetPortDirection+0x142>
    254e:	8c 81       	ldd	r24, Y+4	; 0x04
    2550:	9d 81       	ldd	r25, Y+5	; 0x05
    2552:	00 97       	sbiw	r24, 0x00	; 0
    2554:	61 f0       	breq	.+24     	; 0x256e <MDIO_u8SetPortDirection+0x158>
    2556:	1c c0       	rjmp	.+56     	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
    2558:	2c 81       	ldd	r18, Y+4	; 0x04
    255a:	3d 81       	ldd	r19, Y+5	; 0x05
    255c:	22 30       	cpi	r18, 0x02	; 2
    255e:	31 05       	cpc	r19, r1
    2560:	71 f0       	breq	.+28     	; 0x257e <MDIO_u8SetPortDirection+0x168>
    2562:	8c 81       	ldd	r24, Y+4	; 0x04
    2564:	9d 81       	ldd	r25, Y+5	; 0x05
    2566:	83 30       	cpi	r24, 0x03	; 3
    2568:	91 05       	cpc	r25, r1
    256a:	69 f0       	breq	.+26     	; 0x2586 <MDIO_u8SetPortDirection+0x170>
    256c:	11 c0       	rjmp	.+34     	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
			 {
			 	case MDIO_u8_PORTA:
			 		MDIO_u8_DDRA_REG=0x00;
    256e:	ea e3       	ldi	r30, 0x3A	; 58
    2570:	f0 e0       	ldi	r31, 0x00	; 0
    2572:	10 82       	st	Z, r1
    2574:	0d c0       	rjmp	.+26     	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
			 		break;

			 	case MDIO_u8_PORTB:
			 		MDIO_u8_DDRB_REG=0x00;
    2576:	e7 e3       	ldi	r30, 0x37	; 55
    2578:	f0 e0       	ldi	r31, 0x00	; 0
    257a:	10 82       	st	Z, r1
    257c:	09 c0       	rjmp	.+18     	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
			 		break;

			 	case MDIO_u8_PORTC:
			 		MDIO_u8_DDRC_REG=0x00;
    257e:	e4 e3       	ldi	r30, 0x34	; 52
    2580:	f0 e0       	ldi	r31, 0x00	; 0
    2582:	10 82       	st	Z, r1
    2584:	05 c0       	rjmp	.+10     	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
			 		break;

			 	case MDIO_u8_PORTD:
			 		MDIO_u8_DDRD_REG=0x00;
    2586:	e1 e3       	ldi	r30, 0x31	; 49
    2588:	f0 e0       	ldi	r31, 0x00	; 0
    258a:	10 82       	st	Z, r1
    258c:	01 c0       	rjmp	.+2      	; 0x2590 <MDIO_u8SetPortDirection+0x17a>
			 		break;
			 }
			 break;

		default:
			 Local_u8ErrorState=STD_TYPES_NOK;
    258e:	19 82       	std	Y+1, r1	; 0x01
			 break;
		}
	}
	return Local_u8ErrorState;
    2590:	89 81       	ldd	r24, Y+1	; 0x01
}
    2592:	2b 96       	adiw	r28, 0x0b	; 11
    2594:	0f b6       	in	r0, 0x3f	; 63
    2596:	f8 94       	cli
    2598:	de bf       	out	0x3e, r29	; 62
    259a:	0f be       	out	0x3f, r0	; 63
    259c:	cd bf       	out	0x3d, r28	; 61
    259e:	cf 91       	pop	r28
    25a0:	df 91       	pop	r29
    25a2:	08 95       	ret

000025a4 <MDIO_u8SetPortValue>:

u8 MDIO_u8SetPortValue(u8 Copy_u8_Port_Id,u8 Copy_u8_Port_Value)
{
    25a4:	df 93       	push	r29
    25a6:	cf 93       	push	r28
    25a8:	00 d0       	rcall	.+0      	; 0x25aa <MDIO_u8SetPortValue+0x6>
    25aa:	00 d0       	rcall	.+0      	; 0x25ac <MDIO_u8SetPortValue+0x8>
    25ac:	0f 92       	push	r0
    25ae:	cd b7       	in	r28, 0x3d	; 61
    25b0:	de b7       	in	r29, 0x3e	; 62
    25b2:	8a 83       	std	Y+2, r24	; 0x02
    25b4:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=STD_TYPES_NOK;
    25b6:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8_Port_Id<=MDIO_u8_PORTD)
    25b8:	8a 81       	ldd	r24, Y+2	; 0x02
    25ba:	84 30       	cpi	r24, 0x04	; 4
    25bc:	a0 f5       	brcc	.+104    	; 0x2626 <MDIO_u8SetPortValue+0x82>
	{
		Local_u8ErrorState=STD_TYPES_OK;
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	89 83       	std	Y+1, r24	; 0x01
		switch(Copy_u8_Port_Id)
    25c2:	8a 81       	ldd	r24, Y+2	; 0x02
    25c4:	28 2f       	mov	r18, r24
    25c6:	30 e0       	ldi	r19, 0x00	; 0
    25c8:	3d 83       	std	Y+5, r19	; 0x05
    25ca:	2c 83       	std	Y+4, r18	; 0x04
    25cc:	8c 81       	ldd	r24, Y+4	; 0x04
    25ce:	9d 81       	ldd	r25, Y+5	; 0x05
    25d0:	81 30       	cpi	r24, 0x01	; 1
    25d2:	91 05       	cpc	r25, r1
    25d4:	d1 f0       	breq	.+52     	; 0x260a <MDIO_u8SetPortValue+0x66>
    25d6:	2c 81       	ldd	r18, Y+4	; 0x04
    25d8:	3d 81       	ldd	r19, Y+5	; 0x05
    25da:	22 30       	cpi	r18, 0x02	; 2
    25dc:	31 05       	cpc	r19, r1
    25de:	2c f4       	brge	.+10     	; 0x25ea <MDIO_u8SetPortValue+0x46>
    25e0:	8c 81       	ldd	r24, Y+4	; 0x04
    25e2:	9d 81       	ldd	r25, Y+5	; 0x05
    25e4:	00 97       	sbiw	r24, 0x00	; 0
    25e6:	61 f0       	breq	.+24     	; 0x2600 <MDIO_u8SetPortValue+0x5c>
    25e8:	1e c0       	rjmp	.+60     	; 0x2626 <MDIO_u8SetPortValue+0x82>
    25ea:	2c 81       	ldd	r18, Y+4	; 0x04
    25ec:	3d 81       	ldd	r19, Y+5	; 0x05
    25ee:	22 30       	cpi	r18, 0x02	; 2
    25f0:	31 05       	cpc	r19, r1
    25f2:	81 f0       	breq	.+32     	; 0x2614 <MDIO_u8SetPortValue+0x70>
    25f4:	8c 81       	ldd	r24, Y+4	; 0x04
    25f6:	9d 81       	ldd	r25, Y+5	; 0x05
    25f8:	83 30       	cpi	r24, 0x03	; 3
    25fa:	91 05       	cpc	r25, r1
    25fc:	81 f0       	breq	.+32     	; 0x261e <MDIO_u8SetPortValue+0x7a>
    25fe:	13 c0       	rjmp	.+38     	; 0x2626 <MDIO_u8SetPortValue+0x82>
		{
		case MDIO_u8_PORTA:
			MDIO_u8_PORTA_REG=Copy_u8_Port_Value;
    2600:	eb e3       	ldi	r30, 0x3B	; 59
    2602:	f0 e0       	ldi	r31, 0x00	; 0
    2604:	8b 81       	ldd	r24, Y+3	; 0x03
    2606:	80 83       	st	Z, r24
    2608:	0e c0       	rjmp	.+28     	; 0x2626 <MDIO_u8SetPortValue+0x82>
			break;

		case MDIO_u8_PORTB:
			MDIO_u8_PORTB_REG=Copy_u8_Port_Value;
    260a:	e8 e3       	ldi	r30, 0x38	; 56
    260c:	f0 e0       	ldi	r31, 0x00	; 0
    260e:	8b 81       	ldd	r24, Y+3	; 0x03
    2610:	80 83       	st	Z, r24
    2612:	09 c0       	rjmp	.+18     	; 0x2626 <MDIO_u8SetPortValue+0x82>
			break;

		case MDIO_u8_PORTC:
			MDIO_u8_PORTC_REG=Copy_u8_Port_Value;
    2614:	e5 e3       	ldi	r30, 0x35	; 53
    2616:	f0 e0       	ldi	r31, 0x00	; 0
    2618:	8b 81       	ldd	r24, Y+3	; 0x03
    261a:	80 83       	st	Z, r24
    261c:	04 c0       	rjmp	.+8      	; 0x2626 <MDIO_u8SetPortValue+0x82>
			break;

		case MDIO_u8_PORTD:
			MDIO_u8_PORTD_REG=Copy_u8_Port_Value;
    261e:	e2 e3       	ldi	r30, 0x32	; 50
    2620:	f0 e0       	ldi	r31, 0x00	; 0
    2622:	8b 81       	ldd	r24, Y+3	; 0x03
    2624:	80 83       	st	Z, r24
			break;
		}
	}


	return Local_u8ErrorState;
    2626:	89 81       	ldd	r24, Y+1	; 0x01
}
    2628:	0f 90       	pop	r0
    262a:	0f 90       	pop	r0
    262c:	0f 90       	pop	r0
    262e:	0f 90       	pop	r0
    2630:	0f 90       	pop	r0
    2632:	cf 91       	pop	r28
    2634:	df 91       	pop	r29
    2636:	08 95       	ret

00002638 <MDIO_u8GetPortValue>:

u8 MDIO_u8GetPortValue(u8 Copy_u8_Port_Id,u8* Copy_Pu8_Port_Value)
{
    2638:	df 93       	push	r29
    263a:	cf 93       	push	r28
    263c:	00 d0       	rcall	.+0      	; 0x263e <MDIO_u8GetPortValue+0x6>
    263e:	00 d0       	rcall	.+0      	; 0x2640 <MDIO_u8GetPortValue+0x8>
    2640:	00 d0       	rcall	.+0      	; 0x2642 <MDIO_u8GetPortValue+0xa>
    2642:	cd b7       	in	r28, 0x3d	; 61
    2644:	de b7       	in	r29, 0x3e	; 62
    2646:	8a 83       	std	Y+2, r24	; 0x02
    2648:	7c 83       	std	Y+4, r23	; 0x04
    264a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=STD_TYPES_NOK;
    264c:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8_Port_Id<=MDIO_u8_PORTD)&&(Copy_Pu8_Port_Value!=STD_TYPES_NULL))
    264e:	8a 81       	ldd	r24, Y+2	; 0x02
    2650:	84 30       	cpi	r24, 0x04	; 4
    2652:	08 f0       	brcs	.+2      	; 0x2656 <MDIO_u8GetPortValue+0x1e>
    2654:	40 c0       	rjmp	.+128    	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
    2656:	8b 81       	ldd	r24, Y+3	; 0x03
    2658:	9c 81       	ldd	r25, Y+4	; 0x04
    265a:	00 97       	sbiw	r24, 0x00	; 0
    265c:	e1 f1       	breq	.+120    	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
	{
		Local_u8ErrorState=STD_TYPES_OK;
    265e:	81 e0       	ldi	r24, 0x01	; 1
    2660:	89 83       	std	Y+1, r24	; 0x01
		switch(Copy_u8_Port_Id)
    2662:	8a 81       	ldd	r24, Y+2	; 0x02
    2664:	28 2f       	mov	r18, r24
    2666:	30 e0       	ldi	r19, 0x00	; 0
    2668:	3e 83       	std	Y+6, r19	; 0x06
    266a:	2d 83       	std	Y+5, r18	; 0x05
    266c:	8d 81       	ldd	r24, Y+5	; 0x05
    266e:	9e 81       	ldd	r25, Y+6	; 0x06
    2670:	81 30       	cpi	r24, 0x01	; 1
    2672:	91 05       	cpc	r25, r1
    2674:	e1 f0       	breq	.+56     	; 0x26ae <MDIO_u8GetPortValue+0x76>
    2676:	2d 81       	ldd	r18, Y+5	; 0x05
    2678:	3e 81       	ldd	r19, Y+6	; 0x06
    267a:	22 30       	cpi	r18, 0x02	; 2
    267c:	31 05       	cpc	r19, r1
    267e:	2c f4       	brge	.+10     	; 0x268a <MDIO_u8GetPortValue+0x52>
    2680:	8d 81       	ldd	r24, Y+5	; 0x05
    2682:	9e 81       	ldd	r25, Y+6	; 0x06
    2684:	00 97       	sbiw	r24, 0x00	; 0
    2686:	61 f0       	breq	.+24     	; 0x26a0 <MDIO_u8GetPortValue+0x68>
    2688:	26 c0       	rjmp	.+76     	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
    268a:	2d 81       	ldd	r18, Y+5	; 0x05
    268c:	3e 81       	ldd	r19, Y+6	; 0x06
    268e:	22 30       	cpi	r18, 0x02	; 2
    2690:	31 05       	cpc	r19, r1
    2692:	a1 f0       	breq	.+40     	; 0x26bc <MDIO_u8GetPortValue+0x84>
    2694:	8d 81       	ldd	r24, Y+5	; 0x05
    2696:	9e 81       	ldd	r25, Y+6	; 0x06
    2698:	83 30       	cpi	r24, 0x03	; 3
    269a:	91 05       	cpc	r25, r1
    269c:	b1 f0       	breq	.+44     	; 0x26ca <MDIO_u8GetPortValue+0x92>
    269e:	1b c0       	rjmp	.+54     	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
		{
			case MDIO_u8_PORTA:
				*Copy_Pu8_Port_Value=MDIO_u8_PINA_REG;
    26a0:	e9 e3       	ldi	r30, 0x39	; 57
    26a2:	f0 e0       	ldi	r31, 0x00	; 0
    26a4:	80 81       	ld	r24, Z
    26a6:	eb 81       	ldd	r30, Y+3	; 0x03
    26a8:	fc 81       	ldd	r31, Y+4	; 0x04
    26aa:	80 83       	st	Z, r24
    26ac:	14 c0       	rjmp	.+40     	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
				break;

			case MDIO_u8_PORTB:
				*Copy_Pu8_Port_Value=MDIO_u8_PINB_REG;
    26ae:	e6 e3       	ldi	r30, 0x36	; 54
    26b0:	f0 e0       	ldi	r31, 0x00	; 0
    26b2:	80 81       	ld	r24, Z
    26b4:	eb 81       	ldd	r30, Y+3	; 0x03
    26b6:	fc 81       	ldd	r31, Y+4	; 0x04
    26b8:	80 83       	st	Z, r24
    26ba:	0d c0       	rjmp	.+26     	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
				break;

			case MDIO_u8_PORTC:
				*Copy_Pu8_Port_Value=MDIO_u8_PINC_REG;
    26bc:	e3 e3       	ldi	r30, 0x33	; 51
    26be:	f0 e0       	ldi	r31, 0x00	; 0
    26c0:	80 81       	ld	r24, Z
    26c2:	eb 81       	ldd	r30, Y+3	; 0x03
    26c4:	fc 81       	ldd	r31, Y+4	; 0x04
    26c6:	80 83       	st	Z, r24
    26c8:	06 c0       	rjmp	.+12     	; 0x26d6 <MDIO_u8GetPortValue+0x9e>
				break;

			case MDIO_u8_PORTD:
				*Copy_Pu8_Port_Value=MDIO_u8_PIND_REG;
    26ca:	e0 e3       	ldi	r30, 0x30	; 48
    26cc:	f0 e0       	ldi	r31, 0x00	; 0
    26ce:	80 81       	ld	r24, Z
    26d0:	eb 81       	ldd	r30, Y+3	; 0x03
    26d2:	fc 81       	ldd	r31, Y+4	; 0x04
    26d4:	80 83       	st	Z, r24
				break;
		}
	}

	return Local_u8ErrorState;
    26d6:	89 81       	ldd	r24, Y+1	; 0x01
    26d8:	26 96       	adiw	r28, 0x06	; 6
    26da:	0f b6       	in	r0, 0x3f	; 63
    26dc:	f8 94       	cli
    26de:	de bf       	out	0x3e, r29	; 62
    26e0:	0f be       	out	0x3f, r0	; 63
    26e2:	cd bf       	out	0x3d, r28	; 61
    26e4:	cf 91       	pop	r28
    26e6:	df 91       	pop	r29
    26e8:	08 95       	ret

000026ea <main>:
u8 lcd[2][16];

u8 Get_Pressed(void);


int main(void){
    26ea:	af 92       	push	r10
    26ec:	bf 92       	push	r11
    26ee:	cf 92       	push	r12
    26f0:	df 92       	push	r13
    26f2:	ef 92       	push	r14
    26f4:	ff 92       	push	r15
    26f6:	0f 93       	push	r16
    26f8:	df 93       	push	r29
    26fa:	cf 93       	push	r28
    26fc:	0f 92       	push	r0
    26fe:	cd b7       	in	r28, 0x3d	; 61
    2700:	de b7       	in	r29, 0x3e	; 62
	MDIO_u8INIT();
    2702:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <MDIO_u8INIT>
	HLCD_voidINIT();
    2706:	0e 94 dd 07 	call	0xfba	; 0xfba <HLCD_voidINIT>
	timer0_init();
    270a:	0e 94 ba 31 	call	0x6374	; 0x6374 <timer0_init>
	u8 option;

	while(1){
	  HLCD_u8SetCursor(HLCD_u8_LINE_1  , HLCD_u8_Position_0);
    270e:	81 e0       	ldi	r24, 0x01	; 1
    2710:	60 e0       	ldi	r22, 0x00	; 0
    2712:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
	  HLCD_u8SendString("1-Snake 2-Pacman",0);
    2716:	80 e6       	ldi	r24, 0x60	; 96
    2718:	90 e0       	ldi	r25, 0x00	; 0
    271a:	60 e0       	ldi	r22, 0x00	; 0
    271c:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
	  HLCD_u8SetCursor(HLCD_u8_LINE_2 , HLCD_u8_Position_0);
    2720:	82 e0       	ldi	r24, 0x02	; 2
    2722:	60 e0       	ldi	r22, 0x00	; 0
    2724:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
	  HLCD_u8SendString("3-Head Ball " , 0);
    2728:	81 e7       	ldi	r24, 0x71	; 113
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	60 e0       	ldi	r22, 0x00	; 0
    272e:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>

	  /* get the option from the player */

	  option = Get_Pressed();
    2732:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <Get_Pressed>
    2736:	89 83       	std	Y+1, r24	; 0x01
	  HLCD_u8ClearDisplay();
    2738:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <HLCD_u8ClearDisplay>

	  /*check which game the player wants and start it*/

	  if(option == SNAKE){
    273c:	89 81       	ldd	r24, Y+1	; 0x01
    273e:	87 33       	cpi	r24, 0x37	; 55
    2740:	29 f5       	brne	.+74     	; 0x278c <main+0xa2>

	  /*allocate the tcb of the task 1 for context switching issues*/
	  xTaskCreate(set_snake_direction_input_task , STD_TYPES_NULL , 200  , STD_TYPES_NULL ,0, STD_TYPES_NULL);
    2742:	8b e5       	ldi	r24, 0x5B	; 91
    2744:	94 e1       	ldi	r25, 0x14	; 20
    2746:	60 e0       	ldi	r22, 0x00	; 0
    2748:	70 e0       	ldi	r23, 0x00	; 0
    274a:	48 ec       	ldi	r20, 0xC8	; 200
    274c:	50 e0       	ldi	r21, 0x00	; 0
    274e:	20 e0       	ldi	r18, 0x00	; 0
    2750:	30 e0       	ldi	r19, 0x00	; 0
    2752:	00 e0       	ldi	r16, 0x00	; 0
    2754:	ee 24       	eor	r14, r14
    2756:	ff 24       	eor	r15, r15
    2758:	cc 24       	eor	r12, r12
    275a:	dd 24       	eor	r13, r13
    275c:	aa 24       	eor	r10, r10
    275e:	bb 24       	eor	r11, r11
    2760:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

	  /*allocate the tcb of the task 2 for context switching issues*/
	  xTaskCreate(move_snake_output_task , STD_TYPES_NULL , 600  , STD_TYPES_NULL ,0, STD_TYPES_NULL);
    2764:	8f e9       	ldi	r24, 0x9F	; 159
    2766:	94 e1       	ldi	r25, 0x14	; 20
    2768:	60 e0       	ldi	r22, 0x00	; 0
    276a:	70 e0       	ldi	r23, 0x00	; 0
    276c:	48 e5       	ldi	r20, 0x58	; 88
    276e:	52 e0       	ldi	r21, 0x02	; 2
    2770:	20 e0       	ldi	r18, 0x00	; 0
    2772:	30 e0       	ldi	r19, 0x00	; 0
    2774:	00 e0       	ldi	r16, 0x00	; 0
    2776:	ee 24       	eor	r14, r14
    2778:	ff 24       	eor	r15, r15
    277a:	cc 24       	eor	r12, r12
    277c:	dd 24       	eor	r13, r13
    277e:	aa 24       	eor	r10, r10
    2780:	bb 24       	eor	r11, r11
    2782:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

	  /*start the game*/
	  vTaskStartScheduler();
    2786:	0e 94 c8 2c 	call	0x5990	; 0x5990 <vTaskStartScheduler>
    278a:	c1 cf       	rjmp	.-126    	; 0x270e <main+0x24>

	  }else if(option == PACMAN){
    278c:	89 81       	ldd	r24, Y+1	; 0x01
    278e:	88 33       	cpi	r24, 0x38	; 56
    2790:	09 f0       	breq	.+2      	; 0x2794 <main+0xaa>
    2792:	57 c0       	rjmp	.+174    	; 0x2842 <main+0x158>

		  /*create queue for communication between tasks*/
		  pacman_buffer = xQueueCreate(4 , sizeof(u8));
    2794:	84 e0       	ldi	r24, 0x04	; 4
    2796:	61 e0       	ldi	r22, 0x01	; 1
    2798:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <xQueueCreate>
    279c:	90 93 67 07 	sts	0x0767, r25
    27a0:	80 93 66 07 	sts	0x0766, r24

		  /*create semaphore to save lcd resource from mutual exclusion*/
		  vSemaphoreCreateBinary(pacman_sema);
    27a4:	81 e0       	ldi	r24, 0x01	; 1
    27a6:	60 e0       	ldi	r22, 0x00	; 0
    27a8:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <xQueueCreate>
    27ac:	90 93 69 07 	sts	0x0769, r25
    27b0:	80 93 68 07 	sts	0x0768, r24
    27b4:	80 91 68 07 	lds	r24, 0x0768
    27b8:	90 91 69 07 	lds	r25, 0x0769
    27bc:	00 97       	sbiw	r24, 0x00	; 0
    27be:	59 f0       	breq	.+22     	; 0x27d6 <main+0xec>
    27c0:	80 91 68 07 	lds	r24, 0x0768
    27c4:	90 91 69 07 	lds	r25, 0x0769
    27c8:	60 e0       	ldi	r22, 0x00	; 0
    27ca:	70 e0       	ldi	r23, 0x00	; 0
    27cc:	40 e0       	ldi	r20, 0x00	; 0
    27ce:	50 e0       	ldi	r21, 0x00	; 0
    27d0:	20 e0       	ldi	r18, 0x00	; 0
    27d2:	0e 94 f7 26 	call	0x4dee	; 0x4dee <xQueueGenericSend>

		  /*allocate the tcb of the task 1 for context switching issues*/
		  xTaskCreate(pacman_input_task , STD_TYPES_NULL , 200  , STD_TYPES_NULL ,2, STD_TYPES_NULL);
    27d6:	8b e7       	ldi	r24, 0x7B	; 123
    27d8:	98 e1       	ldi	r25, 0x18	; 24
    27da:	60 e0       	ldi	r22, 0x00	; 0
    27dc:	70 e0       	ldi	r23, 0x00	; 0
    27de:	48 ec       	ldi	r20, 0xC8	; 200
    27e0:	50 e0       	ldi	r21, 0x00	; 0
    27e2:	20 e0       	ldi	r18, 0x00	; 0
    27e4:	30 e0       	ldi	r19, 0x00	; 0
    27e6:	02 e0       	ldi	r16, 0x02	; 2
    27e8:	ee 24       	eor	r14, r14
    27ea:	ff 24       	eor	r15, r15
    27ec:	cc 24       	eor	r12, r12
    27ee:	dd 24       	eor	r13, r13
    27f0:	aa 24       	eor	r10, r10
    27f2:	bb 24       	eor	r11, r11
    27f4:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

		  /*allocate the tcb of the task 2 for context switching issues*/
		  xTaskCreate(pacman_eating_output_task , STD_TYPES_NULL , 350  , STD_TYPES_NULL ,3, STD_TYPES_NULL);
    27f8:	84 ea       	ldi	r24, 0xA4	; 164
    27fa:	98 e1       	ldi	r25, 0x18	; 24
    27fc:	60 e0       	ldi	r22, 0x00	; 0
    27fe:	70 e0       	ldi	r23, 0x00	; 0
    2800:	4e e5       	ldi	r20, 0x5E	; 94
    2802:	51 e0       	ldi	r21, 0x01	; 1
    2804:	20 e0       	ldi	r18, 0x00	; 0
    2806:	30 e0       	ldi	r19, 0x00	; 0
    2808:	03 e0       	ldi	r16, 0x03	; 3
    280a:	ee 24       	eor	r14, r14
    280c:	ff 24       	eor	r15, r15
    280e:	cc 24       	eor	r12, r12
    2810:	dd 24       	eor	r13, r13
    2812:	aa 24       	eor	r10, r10
    2814:	bb 24       	eor	r11, r11
    2816:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

		  /*allocate the tcb of the task 3 for context switching issues*/
		  xTaskCreate(pacman_monster_task , STD_TYPES_NULL , 250  , STD_TYPES_NULL ,1, STD_TYPES_NULL);
    281a:	83 eb       	ldi	r24, 0xB3	; 179
    281c:	9a e1       	ldi	r25, 0x1A	; 26
    281e:	60 e0       	ldi	r22, 0x00	; 0
    2820:	70 e0       	ldi	r23, 0x00	; 0
    2822:	4a ef       	ldi	r20, 0xFA	; 250
    2824:	50 e0       	ldi	r21, 0x00	; 0
    2826:	20 e0       	ldi	r18, 0x00	; 0
    2828:	30 e0       	ldi	r19, 0x00	; 0
    282a:	01 e0       	ldi	r16, 0x01	; 1
    282c:	ee 24       	eor	r14, r14
    282e:	ff 24       	eor	r15, r15
    2830:	cc 24       	eor	r12, r12
    2832:	dd 24       	eor	r13, r13
    2834:	aa 24       	eor	r10, r10
    2836:	bb 24       	eor	r11, r11
    2838:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

		  /*start the game*/
		  vTaskStartScheduler();
    283c:	0e 94 c8 2c 	call	0x5990	; 0x5990 <vTaskStartScheduler>
    2840:	66 cf       	rjmp	.-308    	; 0x270e <main+0x24>
	  }else if(option == HEADBALL){
    2842:	89 81       	ldd	r24, Y+1	; 0x01
    2844:	89 33       	cpi	r24, 0x39	; 57
    2846:	09 f0       	breq	.+2      	; 0x284a <main+0x160>
    2848:	62 cf       	rjmp	.-316    	; 0x270e <main+0x24>

		  /*allocate the tcb of the task 1 for context switching issues*/
		  xTaskCreate(headball_player_task , STD_TYPES_NULL , 300  , STD_TYPES_NULL , 3 , STD_TYPES_NULL);
    284a:	82 ed       	ldi	r24, 0xD2	; 210
    284c:	9b e1       	ldi	r25, 0x1B	; 27
    284e:	60 e0       	ldi	r22, 0x00	; 0
    2850:	70 e0       	ldi	r23, 0x00	; 0
    2852:	4c e2       	ldi	r20, 0x2C	; 44
    2854:	51 e0       	ldi	r21, 0x01	; 1
    2856:	20 e0       	ldi	r18, 0x00	; 0
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	03 e0       	ldi	r16, 0x03	; 3
    285c:	ee 24       	eor	r14, r14
    285e:	ff 24       	eor	r15, r15
    2860:	cc 24       	eor	r12, r12
    2862:	dd 24       	eor	r13, r13
    2864:	aa 24       	eor	r10, r10
    2866:	bb 24       	eor	r11, r11
    2868:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

		  /*allocate the tcb of the task 2 for context switching issues*/
		  xTaskCreate(headball_automated_player_task , STD_TYPES_NULL , 300  , STD_TYPES_NULL , 3 , STD_TYPES_NULL);
    286c:	87 e1       	ldi	r24, 0x17	; 23
    286e:	9c e1       	ldi	r25, 0x1C	; 28
    2870:	60 e0       	ldi	r22, 0x00	; 0
    2872:	70 e0       	ldi	r23, 0x00	; 0
    2874:	4c e2       	ldi	r20, 0x2C	; 44
    2876:	51 e0       	ldi	r21, 0x01	; 1
    2878:	20 e0       	ldi	r18, 0x00	; 0
    287a:	30 e0       	ldi	r19, 0x00	; 0
    287c:	03 e0       	ldi	r16, 0x03	; 3
    287e:	ee 24       	eor	r14, r14
    2880:	ff 24       	eor	r15, r15
    2882:	cc 24       	eor	r12, r12
    2884:	dd 24       	eor	r13, r13
    2886:	aa 24       	eor	r10, r10
    2888:	bb 24       	eor	r11, r11
    288a:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

		  /*allocate the tcb of the task 3 for context switching issues*/
		  xTaskCreate(headball_ball_task , STD_TYPES_NULL , 400  , STD_TYPES_NULL , 4 , STD_TYPES_NULL);
    288e:	8c e7       	ldi	r24, 0x7C	; 124
    2890:	9c e1       	ldi	r25, 0x1C	; 28
    2892:	60 e0       	ldi	r22, 0x00	; 0
    2894:	70 e0       	ldi	r23, 0x00	; 0
    2896:	40 e9       	ldi	r20, 0x90	; 144
    2898:	51 e0       	ldi	r21, 0x01	; 1
    289a:	20 e0       	ldi	r18, 0x00	; 0
    289c:	30 e0       	ldi	r19, 0x00	; 0
    289e:	04 e0       	ldi	r16, 0x04	; 4
    28a0:	ee 24       	eor	r14, r14
    28a2:	ff 24       	eor	r15, r15
    28a4:	cc 24       	eor	r12, r12
    28a6:	dd 24       	eor	r13, r13
    28a8:	aa 24       	eor	r10, r10
    28aa:	bb 24       	eor	r11, r11
    28ac:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>

		  /*start the game*/
		  vTaskStartScheduler();
    28b0:	0e 94 c8 2c 	call	0x5990	; 0x5990 <vTaskStartScheduler>
    28b4:	2c cf       	rjmp	.-424    	; 0x270e <main+0x24>

000028b6 <set_snake_direction_input_task>:
 * start snake game tasks
 *
 *
 *  ***/

void set_snake_direction_input_task(void * Copy_Pv){
    28b6:	df 93       	push	r29
    28b8:	cf 93       	push	r28
    28ba:	00 d0       	rcall	.+0      	; 0x28bc <set_snake_direction_input_task+0x6>
    28bc:	0f 92       	push	r0
    28be:	cd b7       	in	r28, 0x3d	; 61
    28c0:	de b7       	in	r29, 0x3e	; 62
    28c2:	9b 83       	std	Y+3, r25	; 0x03
    28c4:	8a 83       	std	Y+2, r24	; 0x02
	u8 direction;
	while(1){
		/*get the move from the player*/
		direction = Get_Pressed();
    28c6:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <Get_Pressed>
    28ca:	89 83       	std	Y+1, r24	; 0x01
		/*set the global enum of direction*/
			if(direction == RIGHT){
    28cc:	89 81       	ldd	r24, Y+1	; 0x01
    28ce:	86 33       	cpi	r24, 0x36	; 54
    28d0:	39 f4       	brne	.+14     	; 0x28e0 <set_snake_direction_input_task+0x2a>
				if(global_direction != snake_direction_left) global_direction = snake_direction_right;
    28d2:	80 91 40 01 	lds	r24, 0x0140
    28d6:	81 30       	cpi	r24, 0x01	; 1
    28d8:	19 f1       	breq	.+70     	; 0x2920 <set_snake_direction_input_task+0x6a>
    28da:	10 92 40 01 	sts	0x0140, r1
    28de:	20 c0       	rjmp	.+64     	; 0x2920 <set_snake_direction_input_task+0x6a>
			}else if(direction == LEFT){
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	84 33       	cpi	r24, 0x34	; 52
    28e4:	41 f4       	brne	.+16     	; 0x28f6 <set_snake_direction_input_task+0x40>
				if(global_direction != snake_direction_right) global_direction = snake_direction_left;
    28e6:	80 91 40 01 	lds	r24, 0x0140
    28ea:	88 23       	and	r24, r24
    28ec:	c9 f0       	breq	.+50     	; 0x2920 <set_snake_direction_input_task+0x6a>
    28ee:	81 e0       	ldi	r24, 0x01	; 1
    28f0:	80 93 40 01 	sts	0x0140, r24
    28f4:	15 c0       	rjmp	.+42     	; 0x2920 <set_snake_direction_input_task+0x6a>
			}else if(direction == UP){
    28f6:	89 81       	ldd	r24, Y+1	; 0x01
    28f8:	88 33       	cpi	r24, 0x38	; 56
    28fa:	41 f4       	brne	.+16     	; 0x290c <set_snake_direction_input_task+0x56>
				if(global_direction != snake_direction_down) global_direction = snake_direction_up;
    28fc:	80 91 40 01 	lds	r24, 0x0140
    2900:	83 30       	cpi	r24, 0x03	; 3
    2902:	71 f0       	breq	.+28     	; 0x2920 <set_snake_direction_input_task+0x6a>
    2904:	82 e0       	ldi	r24, 0x02	; 2
    2906:	80 93 40 01 	sts	0x0140, r24
    290a:	0a c0       	rjmp	.+20     	; 0x2920 <set_snake_direction_input_task+0x6a>
			}else if(direction == DOWN){
    290c:	89 81       	ldd	r24, Y+1	; 0x01
    290e:	85 33       	cpi	r24, 0x35	; 53
    2910:	39 f4       	brne	.+14     	; 0x2920 <set_snake_direction_input_task+0x6a>
				if(global_direction != snake_direction_up) global_direction = snake_direction_down;
    2912:	80 91 40 01 	lds	r24, 0x0140
    2916:	82 30       	cpi	r24, 0x02	; 2
    2918:	19 f0       	breq	.+6      	; 0x2920 <set_snake_direction_input_task+0x6a>
    291a:	83 e0       	ldi	r24, 0x03	; 3
    291c:	80 93 40 01 	sts	0x0140, r24
			}
			/*check if the player lost or not*/
			if(endSnakeFlag) break;
    2920:	80 91 41 01 	lds	r24, 0x0141
    2924:	88 23       	and	r24, r24
    2926:	29 f4       	brne	.+10     	; 0x2932 <set_snake_direction_input_task+0x7c>
		vTaskDelay(50);
    2928:	82 e3       	ldi	r24, 0x32	; 50
    292a:	90 e0       	ldi	r25, 0x00	; 0
    292c:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    2930:	ca cf       	rjmp	.-108    	; 0x28c6 <set_snake_direction_input_task+0x10>
  }
}
    2932:	0f 90       	pop	r0
    2934:	0f 90       	pop	r0
    2936:	0f 90       	pop	r0
    2938:	cf 91       	pop	r28
    293a:	df 91       	pop	r29
    293c:	08 95       	ret

0000293e <move_snake_output_task>:

void move_snake_output_task(void * Copy_Pv){
    293e:	df 93       	push	r29
    2940:	cf 93       	push	r28
    2942:	cd b7       	in	r28, 0x3d	; 61
    2944:	de b7       	in	r29, 0x3e	; 62
    2946:	a6 97       	sbiw	r28, 0x26	; 38
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	9a 8f       	std	Y+26, r25	; 0x1a
    2954:	89 8f       	std	Y+25, r24	; 0x19
	/* at the beginning we allocate the snake at the start point */
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2956:	18 8e       	std	Y+24, r1	; 0x18
    2958:	32 c0       	rjmp	.+100    	; 0x29be <move_snake_output_task+0x80>
	   global_snake[i].x = 1;
    295a:	88 8d       	ldd	r24, Y+24	; 0x18
    295c:	28 2f       	mov	r18, r24
    295e:	30 e0       	ldi	r19, 0x00	; 0
    2960:	c9 01       	movw	r24, r18
    2962:	88 0f       	add	r24, r24
    2964:	99 1f       	adc	r25, r25
    2966:	82 0f       	add	r24, r18
    2968:	93 1f       	adc	r25, r19
    296a:	fc 01       	movw	r30, r24
    296c:	ed 5c       	subi	r30, 0xCD	; 205
    296e:	f8 4f       	sbci	r31, 0xF8	; 248
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	80 83       	st	Z, r24
	   global_snake[i].y = global_snake_length-1-i;
    2974:	88 8d       	ldd	r24, Y+24	; 0x18
    2976:	28 2f       	mov	r18, r24
    2978:	30 e0       	ldi	r19, 0x00	; 0
    297a:	90 91 e0 00 	lds	r25, 0x00E0
    297e:	88 8d       	ldd	r24, Y+24	; 0x18
    2980:	49 2f       	mov	r20, r25
    2982:	48 1b       	sub	r20, r24
    2984:	84 2f       	mov	r24, r20
    2986:	48 2f       	mov	r20, r24
    2988:	41 50       	subi	r20, 0x01	; 1
    298a:	c9 01       	movw	r24, r18
    298c:	88 0f       	add	r24, r24
    298e:	99 1f       	adc	r25, r25
    2990:	82 0f       	add	r24, r18
    2992:	93 1f       	adc	r25, r19
    2994:	fc 01       	movw	r30, r24
    2996:	ec 5c       	subi	r30, 0xCC	; 204
    2998:	f8 4f       	sbci	r31, 0xF8	; 248
    299a:	40 83       	st	Z, r20
	   global_snake[i].direction = global_direction;
    299c:	88 8d       	ldd	r24, Y+24	; 0x18
    299e:	28 2f       	mov	r18, r24
    29a0:	30 e0       	ldi	r19, 0x00	; 0
    29a2:	40 91 40 01 	lds	r20, 0x0140
    29a6:	c9 01       	movw	r24, r18
    29a8:	88 0f       	add	r24, r24
    29aa:	99 1f       	adc	r25, r25
    29ac:	82 0f       	add	r24, r18
    29ae:	93 1f       	adc	r25, r19
    29b0:	fc 01       	movw	r30, r24
    29b2:	eb 5c       	subi	r30, 0xCB	; 203
    29b4:	f8 4f       	sbci	r31, 0xF8	; 248
    29b6:	40 83       	st	Z, r20
  }
}

void move_snake_output_task(void * Copy_Pv){
	/* at the beginning we allocate the snake at the start point */
	for(u8 i = 0 ; i < global_snake_length ; i++){
    29b8:	88 8d       	ldd	r24, Y+24	; 0x18
    29ba:	8f 5f       	subi	r24, 0xFF	; 255
    29bc:	88 8f       	std	Y+24, r24	; 0x18
    29be:	90 91 e0 00 	lds	r25, 0x00E0
    29c2:	88 8d       	ldd	r24, Y+24	; 0x18
    29c4:	89 17       	cp	r24, r25
    29c6:	48 f2       	brcs	.-110    	; 0x295a <move_snake_output_task+0x1c>
	}

	while(1){
	/*update the direction for all snake points
	 * to make each point follow the next of it*/
	for(int i = global_snake_length-1 ; i > 0 ; i--){
    29c8:	80 91 e0 00 	lds	r24, 0x00E0
    29cc:	88 2f       	mov	r24, r24
    29ce:	90 e0       	ldi	r25, 0x00	; 0
    29d0:	01 97       	sbiw	r24, 0x01	; 1
    29d2:	9e 8b       	std	Y+22, r25	; 0x16
    29d4:	8d 8b       	std	Y+21, r24	; 0x15
    29d6:	1e c0       	rjmp	.+60     	; 0x2a14 <move_snake_output_task+0xd6>
		global_snake[i].direction = global_snake[i-1].direction;
    29d8:	4d 89       	ldd	r20, Y+21	; 0x15
    29da:	5e 89       	ldd	r21, Y+22	; 0x16
    29dc:	8d 89       	ldd	r24, Y+21	; 0x15
    29de:	9e 89       	ldd	r25, Y+22	; 0x16
    29e0:	9c 01       	movw	r18, r24
    29e2:	21 50       	subi	r18, 0x01	; 1
    29e4:	30 40       	sbci	r19, 0x00	; 0
    29e6:	c9 01       	movw	r24, r18
    29e8:	88 0f       	add	r24, r24
    29ea:	99 1f       	adc	r25, r25
    29ec:	82 0f       	add	r24, r18
    29ee:	93 1f       	adc	r25, r19
    29f0:	fc 01       	movw	r30, r24
    29f2:	eb 5c       	subi	r30, 0xCB	; 203
    29f4:	f8 4f       	sbci	r31, 0xF8	; 248
    29f6:	20 81       	ld	r18, Z
    29f8:	ca 01       	movw	r24, r20
    29fa:	88 0f       	add	r24, r24
    29fc:	99 1f       	adc	r25, r25
    29fe:	84 0f       	add	r24, r20
    2a00:	95 1f       	adc	r25, r21
    2a02:	fc 01       	movw	r30, r24
    2a04:	eb 5c       	subi	r30, 0xCB	; 203
    2a06:	f8 4f       	sbci	r31, 0xF8	; 248
    2a08:	20 83       	st	Z, r18
	}

	while(1){
	/*update the direction for all snake points
	 * to make each point follow the next of it*/
	for(int i = global_snake_length-1 ; i > 0 ; i--){
    2a0a:	8d 89       	ldd	r24, Y+21	; 0x15
    2a0c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a0e:	01 97       	sbiw	r24, 0x01	; 1
    2a10:	9e 8b       	std	Y+22, r25	; 0x16
    2a12:	8d 8b       	std	Y+21, r24	; 0x15
    2a14:	8d 89       	ldd	r24, Y+21	; 0x15
    2a16:	9e 89       	ldd	r25, Y+22	; 0x16
    2a18:	18 16       	cp	r1, r24
    2a1a:	19 06       	cpc	r1, r25
    2a1c:	ec f2       	brlt	.-70     	; 0x29d8 <move_snake_output_task+0x9a>
		global_snake[i].direction = global_snake[i-1].direction;
	}

	global_snake[0].direction = global_direction;
    2a1e:	80 91 40 01 	lds	r24, 0x0140
    2a22:	80 93 35 07 	sts	0x0735, r24
	/*update the tail of the snake for the growth*/
	snake_tail = global_snake[global_snake_length - 1];
    2a26:	80 91 e0 00 	lds	r24, 0x00E0
    2a2a:	88 2f       	mov	r24, r24
    2a2c:	90 e0       	ldi	r25, 0x00	; 0
    2a2e:	9c 01       	movw	r18, r24
    2a30:	21 50       	subi	r18, 0x01	; 1
    2a32:	30 40       	sbci	r19, 0x00	; 0
    2a34:	c9 01       	movw	r24, r18
    2a36:	88 0f       	add	r24, r24
    2a38:	99 1f       	adc	r25, r25
    2a3a:	82 0f       	add	r24, r18
    2a3c:	93 1f       	adc	r25, r19
    2a3e:	8d 5c       	subi	r24, 0xCD	; 205
    2a40:	98 4f       	sbci	r25, 0xF8	; 248
    2a42:	e0 e3       	ldi	r30, 0x30	; 48
    2a44:	f7 e0       	ldi	r31, 0x07	; 7
    2a46:	fe 8f       	std	Y+30, r31	; 0x1e
    2a48:	ed 8f       	std	Y+29, r30	; 0x1d
    2a4a:	98 a3       	std	Y+32, r25	; 0x20
    2a4c:	8f 8f       	std	Y+31, r24	; 0x1f
    2a4e:	f3 e0       	ldi	r31, 0x03	; 3
    2a50:	f9 a3       	std	Y+33, r31	; 0x21
    2a52:	ef 8d       	ldd	r30, Y+31	; 0x1f
    2a54:	f8 a1       	ldd	r31, Y+32	; 0x20
    2a56:	00 80       	ld	r0, Z
    2a58:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2a5a:	38 a1       	ldd	r19, Y+32	; 0x20
    2a5c:	2f 5f       	subi	r18, 0xFF	; 255
    2a5e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a60:	38 a3       	std	Y+32, r19	; 0x20
    2a62:	2f 8f       	std	Y+31, r18	; 0x1f
    2a64:	ed 8d       	ldd	r30, Y+29	; 0x1d
    2a66:	fe 8d       	ldd	r31, Y+30	; 0x1e
    2a68:	00 82       	st	Z, r0
    2a6a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2a6c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2a6e:	2f 5f       	subi	r18, 0xFF	; 255
    2a70:	3f 4f       	sbci	r19, 0xFF	; 255
    2a72:	3e 8f       	std	Y+30, r19	; 0x1e
    2a74:	2d 8f       	std	Y+29, r18	; 0x1d
    2a76:	39 a1       	ldd	r19, Y+33	; 0x21
    2a78:	31 50       	subi	r19, 0x01	; 1
    2a7a:	39 a3       	std	Y+33, r19	; 0x21
    2a7c:	49 a1       	ldd	r20, Y+33	; 0x21
    2a7e:	44 23       	and	r20, r20
    2a80:	41 f7       	brne	.-48     	; 0x2a52 <move_snake_output_task+0x114>

	/*update each point coordinate */
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2a82:	1c 8a       	std	Y+20, r1	; 0x14
    2a84:	33 c1       	rjmp	.+614    	; 0x2cec <move_snake_output_task+0x3ae>
		switch(global_snake[i].direction){
    2a86:	8c 89       	ldd	r24, Y+20	; 0x14
    2a88:	28 2f       	mov	r18, r24
    2a8a:	30 e0       	ldi	r19, 0x00	; 0
    2a8c:	c9 01       	movw	r24, r18
    2a8e:	88 0f       	add	r24, r24
    2a90:	99 1f       	adc	r25, r25
    2a92:	82 0f       	add	r24, r18
    2a94:	93 1f       	adc	r25, r19
    2a96:	fc 01       	movw	r30, r24
    2a98:	eb 5c       	subi	r30, 0xCB	; 203
    2a9a:	f8 4f       	sbci	r31, 0xF8	; 248
    2a9c:	80 81       	ld	r24, Z
    2a9e:	e8 2f       	mov	r30, r24
    2aa0:	f0 e0       	ldi	r31, 0x00	; 0
    2aa2:	fc 8f       	std	Y+28, r31	; 0x1c
    2aa4:	eb 8f       	std	Y+27, r30	; 0x1b
    2aa6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2aa8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2aaa:	21 30       	cpi	r18, 0x01	; 1
    2aac:	31 05       	cpc	r19, r1
    2aae:	09 f4       	brne	.+2      	; 0x2ab2 <move_snake_output_task+0x174>
    2ab0:	49 c0       	rjmp	.+146    	; 0x2b44 <move_snake_output_task+0x206>
    2ab2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ab4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2ab6:	82 30       	cpi	r24, 0x02	; 2
    2ab8:	91 05       	cpc	r25, r1
    2aba:	2c f4       	brge	.+10     	; 0x2ac6 <move_snake_output_task+0x188>
    2abc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2abe:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2ac0:	30 97       	sbiw	r30, 0x00	; 0
    2ac2:	71 f0       	breq	.+28     	; 0x2ae0 <move_snake_output_task+0x1a2>
    2ac4:	e3 c0       	rjmp	.+454    	; 0x2c8c <move_snake_output_task+0x34e>
    2ac6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2ac8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2aca:	22 30       	cpi	r18, 0x02	; 2
    2acc:	31 05       	cpc	r19, r1
    2ace:	09 f4       	brne	.+2      	; 0x2ad2 <move_snake_output_task+0x194>
    2ad0:	6d c0       	rjmp	.+218    	; 0x2bac <move_snake_output_task+0x26e>
    2ad2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ad4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2ad6:	83 30       	cpi	r24, 0x03	; 3
    2ad8:	91 05       	cpc	r25, r1
    2ada:	09 f4       	brne	.+2      	; 0x2ade <move_snake_output_task+0x1a0>
    2adc:	a0 c0       	rjmp	.+320    	; 0x2c1e <move_snake_output_task+0x2e0>
    2ade:	d6 c0       	rjmp	.+428    	; 0x2c8c <move_snake_output_task+0x34e>
			case snake_direction_right:{
				global_snake[i].y++;
    2ae0:	8c 89       	ldd	r24, Y+20	; 0x14
    2ae2:	28 2f       	mov	r18, r24
    2ae4:	30 e0       	ldi	r19, 0x00	; 0
    2ae6:	c9 01       	movw	r24, r18
    2ae8:	88 0f       	add	r24, r24
    2aea:	99 1f       	adc	r25, r25
    2aec:	82 0f       	add	r24, r18
    2aee:	93 1f       	adc	r25, r19
    2af0:	fc 01       	movw	r30, r24
    2af2:	ec 5c       	subi	r30, 0xCC	; 204
    2af4:	f8 4f       	sbci	r31, 0xF8	; 248
    2af6:	80 81       	ld	r24, Z
    2af8:	48 2f       	mov	r20, r24
    2afa:	4f 5f       	subi	r20, 0xFF	; 255
    2afc:	c9 01       	movw	r24, r18
    2afe:	88 0f       	add	r24, r24
    2b00:	99 1f       	adc	r25, r25
    2b02:	82 0f       	add	r24, r18
    2b04:	93 1f       	adc	r25, r19
    2b06:	fc 01       	movw	r30, r24
    2b08:	ec 5c       	subi	r30, 0xCC	; 204
    2b0a:	f8 4f       	sbci	r31, 0xF8	; 248
    2b0c:	40 83       	st	Z, r20
				global_snake[i].y %= 16;
    2b0e:	8c 89       	ldd	r24, Y+20	; 0x14
    2b10:	48 2f       	mov	r20, r24
    2b12:	50 e0       	ldi	r21, 0x00	; 0
    2b14:	8c 89       	ldd	r24, Y+20	; 0x14
    2b16:	28 2f       	mov	r18, r24
    2b18:	30 e0       	ldi	r19, 0x00	; 0
    2b1a:	c9 01       	movw	r24, r18
    2b1c:	88 0f       	add	r24, r24
    2b1e:	99 1f       	adc	r25, r25
    2b20:	82 0f       	add	r24, r18
    2b22:	93 1f       	adc	r25, r19
    2b24:	fc 01       	movw	r30, r24
    2b26:	ec 5c       	subi	r30, 0xCC	; 204
    2b28:	f8 4f       	sbci	r31, 0xF8	; 248
    2b2a:	80 81       	ld	r24, Z
    2b2c:	28 2f       	mov	r18, r24
    2b2e:	2f 70       	andi	r18, 0x0F	; 15
    2b30:	ca 01       	movw	r24, r20
    2b32:	88 0f       	add	r24, r24
    2b34:	99 1f       	adc	r25, r25
    2b36:	84 0f       	add	r24, r20
    2b38:	95 1f       	adc	r25, r21
    2b3a:	fc 01       	movw	r30, r24
    2b3c:	ec 5c       	subi	r30, 0xCC	; 204
    2b3e:	f8 4f       	sbci	r31, 0xF8	; 248
    2b40:	20 83       	st	Z, r18
    2b42:	a4 c0       	rjmp	.+328    	; 0x2c8c <move_snake_output_task+0x34e>
				break;
			}
			case snake_direction_left:{
				if(global_snake[i].y == 0){
    2b44:	8c 89       	ldd	r24, Y+20	; 0x14
    2b46:	28 2f       	mov	r18, r24
    2b48:	30 e0       	ldi	r19, 0x00	; 0
    2b4a:	c9 01       	movw	r24, r18
    2b4c:	88 0f       	add	r24, r24
    2b4e:	99 1f       	adc	r25, r25
    2b50:	82 0f       	add	r24, r18
    2b52:	93 1f       	adc	r25, r19
    2b54:	fc 01       	movw	r30, r24
    2b56:	ec 5c       	subi	r30, 0xCC	; 204
    2b58:	f8 4f       	sbci	r31, 0xF8	; 248
    2b5a:	80 81       	ld	r24, Z
    2b5c:	88 23       	and	r24, r24
    2b5e:	71 f4       	brne	.+28     	; 0x2b7c <move_snake_output_task+0x23e>
					global_snake[i].y = MAX_SNAKE_LENGHT;
    2b60:	8c 89       	ldd	r24, Y+20	; 0x14
    2b62:	28 2f       	mov	r18, r24
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	c9 01       	movw	r24, r18
    2b68:	88 0f       	add	r24, r24
    2b6a:	99 1f       	adc	r25, r25
    2b6c:	82 0f       	add	r24, r18
    2b6e:	93 1f       	adc	r25, r19
    2b70:	fc 01       	movw	r30, r24
    2b72:	ec 5c       	subi	r30, 0xCC	; 204
    2b74:	f8 4f       	sbci	r31, 0xF8	; 248
    2b76:	8f e0       	ldi	r24, 0x0F	; 15
    2b78:	80 83       	st	Z, r24
    2b7a:	88 c0       	rjmp	.+272    	; 0x2c8c <move_snake_output_task+0x34e>
				}else{
					global_snake[i].y--;
    2b7c:	8c 89       	ldd	r24, Y+20	; 0x14
    2b7e:	28 2f       	mov	r18, r24
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	c9 01       	movw	r24, r18
    2b84:	88 0f       	add	r24, r24
    2b86:	99 1f       	adc	r25, r25
    2b88:	82 0f       	add	r24, r18
    2b8a:	93 1f       	adc	r25, r19
    2b8c:	fc 01       	movw	r30, r24
    2b8e:	ec 5c       	subi	r30, 0xCC	; 204
    2b90:	f8 4f       	sbci	r31, 0xF8	; 248
    2b92:	80 81       	ld	r24, Z
    2b94:	48 2f       	mov	r20, r24
    2b96:	41 50       	subi	r20, 0x01	; 1
    2b98:	c9 01       	movw	r24, r18
    2b9a:	88 0f       	add	r24, r24
    2b9c:	99 1f       	adc	r25, r25
    2b9e:	82 0f       	add	r24, r18
    2ba0:	93 1f       	adc	r25, r19
    2ba2:	fc 01       	movw	r30, r24
    2ba4:	ec 5c       	subi	r30, 0xCC	; 204
    2ba6:	f8 4f       	sbci	r31, 0xF8	; 248
    2ba8:	40 83       	st	Z, r20
    2baa:	70 c0       	rjmp	.+224    	; 0x2c8c <move_snake_output_task+0x34e>
				}
				break;
			}
			case snake_direction_up:{
				if(global_snake[i].x == 1) global_snake[i].x = 2;
    2bac:	8c 89       	ldd	r24, Y+20	; 0x14
    2bae:	28 2f       	mov	r18, r24
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	c9 01       	movw	r24, r18
    2bb4:	88 0f       	add	r24, r24
    2bb6:	99 1f       	adc	r25, r25
    2bb8:	82 0f       	add	r24, r18
    2bba:	93 1f       	adc	r25, r19
    2bbc:	fc 01       	movw	r30, r24
    2bbe:	ed 5c       	subi	r30, 0xCD	; 205
    2bc0:	f8 4f       	sbci	r31, 0xF8	; 248
    2bc2:	80 81       	ld	r24, Z
    2bc4:	81 30       	cpi	r24, 0x01	; 1
    2bc6:	71 f4       	brne	.+28     	; 0x2be4 <move_snake_output_task+0x2a6>
    2bc8:	8c 89       	ldd	r24, Y+20	; 0x14
    2bca:	28 2f       	mov	r18, r24
    2bcc:	30 e0       	ldi	r19, 0x00	; 0
    2bce:	c9 01       	movw	r24, r18
    2bd0:	88 0f       	add	r24, r24
    2bd2:	99 1f       	adc	r25, r25
    2bd4:	82 0f       	add	r24, r18
    2bd6:	93 1f       	adc	r25, r19
    2bd8:	fc 01       	movw	r30, r24
    2bda:	ed 5c       	subi	r30, 0xCD	; 205
    2bdc:	f8 4f       	sbci	r31, 0xF8	; 248
    2bde:	82 e0       	ldi	r24, 0x02	; 2
    2be0:	80 83       	st	Z, r24
    2be2:	54 c0       	rjmp	.+168    	; 0x2c8c <move_snake_output_task+0x34e>
				else if(global_snake[i].x == 2) global_snake[i].x = 1;
    2be4:	8c 89       	ldd	r24, Y+20	; 0x14
    2be6:	28 2f       	mov	r18, r24
    2be8:	30 e0       	ldi	r19, 0x00	; 0
    2bea:	c9 01       	movw	r24, r18
    2bec:	88 0f       	add	r24, r24
    2bee:	99 1f       	adc	r25, r25
    2bf0:	82 0f       	add	r24, r18
    2bf2:	93 1f       	adc	r25, r19
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	ed 5c       	subi	r30, 0xCD	; 205
    2bf8:	f8 4f       	sbci	r31, 0xF8	; 248
    2bfa:	80 81       	ld	r24, Z
    2bfc:	82 30       	cpi	r24, 0x02	; 2
    2bfe:	09 f0       	breq	.+2      	; 0x2c02 <move_snake_output_task+0x2c4>
    2c00:	45 c0       	rjmp	.+138    	; 0x2c8c <move_snake_output_task+0x34e>
    2c02:	8c 89       	ldd	r24, Y+20	; 0x14
    2c04:	28 2f       	mov	r18, r24
    2c06:	30 e0       	ldi	r19, 0x00	; 0
    2c08:	c9 01       	movw	r24, r18
    2c0a:	88 0f       	add	r24, r24
    2c0c:	99 1f       	adc	r25, r25
    2c0e:	82 0f       	add	r24, r18
    2c10:	93 1f       	adc	r25, r19
    2c12:	fc 01       	movw	r30, r24
    2c14:	ed 5c       	subi	r30, 0xCD	; 205
    2c16:	f8 4f       	sbci	r31, 0xF8	; 248
    2c18:	81 e0       	ldi	r24, 0x01	; 1
    2c1a:	80 83       	st	Z, r24
    2c1c:	37 c0       	rjmp	.+110    	; 0x2c8c <move_snake_output_task+0x34e>
				break;
			}
			case snake_direction_down:{
				if(global_snake[i].x == 1) global_snake[i].x = 2;
    2c1e:	8c 89       	ldd	r24, Y+20	; 0x14
    2c20:	28 2f       	mov	r18, r24
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	c9 01       	movw	r24, r18
    2c26:	88 0f       	add	r24, r24
    2c28:	99 1f       	adc	r25, r25
    2c2a:	82 0f       	add	r24, r18
    2c2c:	93 1f       	adc	r25, r19
    2c2e:	fc 01       	movw	r30, r24
    2c30:	ed 5c       	subi	r30, 0xCD	; 205
    2c32:	f8 4f       	sbci	r31, 0xF8	; 248
    2c34:	80 81       	ld	r24, Z
    2c36:	81 30       	cpi	r24, 0x01	; 1
    2c38:	71 f4       	brne	.+28     	; 0x2c56 <move_snake_output_task+0x318>
    2c3a:	8c 89       	ldd	r24, Y+20	; 0x14
    2c3c:	28 2f       	mov	r18, r24
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	c9 01       	movw	r24, r18
    2c42:	88 0f       	add	r24, r24
    2c44:	99 1f       	adc	r25, r25
    2c46:	82 0f       	add	r24, r18
    2c48:	93 1f       	adc	r25, r19
    2c4a:	fc 01       	movw	r30, r24
    2c4c:	ed 5c       	subi	r30, 0xCD	; 205
    2c4e:	f8 4f       	sbci	r31, 0xF8	; 248
    2c50:	82 e0       	ldi	r24, 0x02	; 2
    2c52:	80 83       	st	Z, r24
    2c54:	1b c0       	rjmp	.+54     	; 0x2c8c <move_snake_output_task+0x34e>
				else if(global_snake[i].x == 2) global_snake[i].x = 1;
    2c56:	8c 89       	ldd	r24, Y+20	; 0x14
    2c58:	28 2f       	mov	r18, r24
    2c5a:	30 e0       	ldi	r19, 0x00	; 0
    2c5c:	c9 01       	movw	r24, r18
    2c5e:	88 0f       	add	r24, r24
    2c60:	99 1f       	adc	r25, r25
    2c62:	82 0f       	add	r24, r18
    2c64:	93 1f       	adc	r25, r19
    2c66:	fc 01       	movw	r30, r24
    2c68:	ed 5c       	subi	r30, 0xCD	; 205
    2c6a:	f8 4f       	sbci	r31, 0xF8	; 248
    2c6c:	80 81       	ld	r24, Z
    2c6e:	82 30       	cpi	r24, 0x02	; 2
    2c70:	69 f4       	brne	.+26     	; 0x2c8c <move_snake_output_task+0x34e>
    2c72:	8c 89       	ldd	r24, Y+20	; 0x14
    2c74:	28 2f       	mov	r18, r24
    2c76:	30 e0       	ldi	r19, 0x00	; 0
    2c78:	c9 01       	movw	r24, r18
    2c7a:	88 0f       	add	r24, r24
    2c7c:	99 1f       	adc	r25, r25
    2c7e:	82 0f       	add	r24, r18
    2c80:	93 1f       	adc	r25, r19
    2c82:	fc 01       	movw	r30, r24
    2c84:	ed 5c       	subi	r30, 0xCD	; 205
    2c86:	f8 4f       	sbci	r31, 0xF8	; 248
    2c88:	81 e0       	ldi	r24, 0x01	; 1
    2c8a:	80 83       	st	Z, r24
				break;
			}
		}
		/*update lcd global array to not make food overwrite the snake */
		lcd[global_snake[i].x -1][global_snake[i].y] = 1;
    2c8c:	8c 89       	ldd	r24, Y+20	; 0x14
    2c8e:	28 2f       	mov	r18, r24
    2c90:	30 e0       	ldi	r19, 0x00	; 0
    2c92:	c9 01       	movw	r24, r18
    2c94:	88 0f       	add	r24, r24
    2c96:	99 1f       	adc	r25, r25
    2c98:	82 0f       	add	r24, r18
    2c9a:	93 1f       	adc	r25, r19
    2c9c:	fc 01       	movw	r30, r24
    2c9e:	ed 5c       	subi	r30, 0xCD	; 205
    2ca0:	f8 4f       	sbci	r31, 0xF8	; 248
    2ca2:	80 81       	ld	r24, Z
    2ca4:	88 2f       	mov	r24, r24
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	ac 01       	movw	r20, r24
    2caa:	41 50       	subi	r20, 0x01	; 1
    2cac:	50 40       	sbci	r21, 0x00	; 0
    2cae:	8c 89       	ldd	r24, Y+20	; 0x14
    2cb0:	28 2f       	mov	r18, r24
    2cb2:	30 e0       	ldi	r19, 0x00	; 0
    2cb4:	c9 01       	movw	r24, r18
    2cb6:	88 0f       	add	r24, r24
    2cb8:	99 1f       	adc	r25, r25
    2cba:	82 0f       	add	r24, r18
    2cbc:	93 1f       	adc	r25, r19
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	ec 5c       	subi	r30, 0xCC	; 204
    2cc2:	f8 4f       	sbci	r31, 0xF8	; 248
    2cc4:	80 81       	ld	r24, Z
    2cc6:	28 2f       	mov	r18, r24
    2cc8:	30 e0       	ldi	r19, 0x00	; 0
    2cca:	ca 01       	movw	r24, r20
    2ccc:	82 95       	swap	r24
    2cce:	92 95       	swap	r25
    2cd0:	90 7f       	andi	r25, 0xF0	; 240
    2cd2:	98 27       	eor	r25, r24
    2cd4:	80 7f       	andi	r24, 0xF0	; 240
    2cd6:	98 27       	eor	r25, r24
    2cd8:	82 0f       	add	r24, r18
    2cda:	93 1f       	adc	r25, r19
    2cdc:	fc 01       	movw	r30, r24
    2cde:	e5 5f       	subi	r30, 0xF5	; 245
    2ce0:	f8 4f       	sbci	r31, 0xF8	; 248
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	80 83       	st	Z, r24
	global_snake[0].direction = global_direction;
	/*update the tail of the snake for the growth*/
	snake_tail = global_snake[global_snake_length - 1];

	/*update each point coordinate */
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2ce6:	8c 89       	ldd	r24, Y+20	; 0x14
    2ce8:	8f 5f       	subi	r24, 0xFF	; 255
    2cea:	8c 8b       	std	Y+20, r24	; 0x14
    2cec:	90 91 e0 00 	lds	r25, 0x00E0
    2cf0:	8c 89       	ldd	r24, Y+20	; 0x14
    2cf2:	89 17       	cp	r24, r25
    2cf4:	08 f4       	brcc	.+2      	; 0x2cf8 <move_snake_output_task+0x3ba>
    2cf6:	c7 ce       	rjmp	.-626    	; 0x2a86 <move_snake_output_task+0x148>
		/*update lcd global array to not make food overwrite the snake */
		lcd[global_snake[i].x -1][global_snake[i].y] = 1;
	}

	/*check there is an apple on the lcd or not*/
	if(snake_food.x == EMPTY || snake_food.y == EMPTY){
    2cf8:	80 91 dd 00 	lds	r24, 0x00DD
    2cfc:	8f 3f       	cpi	r24, 0xFF	; 255
    2cfe:	21 f0       	breq	.+8      	; 0x2d08 <move_snake_output_task+0x3ca>
    2d00:	80 91 de 00 	lds	r24, 0x00DE
    2d04:	8f 3f       	cpi	r24, 0xFF	; 255
    2d06:	c1 f5       	brne	.+112    	; 0x2d78 <move_snake_output_task+0x43a>
		/*create new apple for the snake*/
		snake_food.y = generateRandomNumbers(16);
    2d08:	80 e1       	ldi	r24, 0x10	; 16
    2d0a:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    2d0e:	80 93 de 00 	sts	0x00DE, r24
		snake_food.x = generateRandomNumbers(2) + 1 ;
    2d12:	82 e0       	ldi	r24, 0x02	; 2
    2d14:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    2d18:	8f 5f       	subi	r24, 0xFF	; 255
    2d1a:	80 93 dd 00 	sts	0x00DD, r24
    2d1e:	0b c0       	rjmp	.+22     	; 0x2d36 <move_snake_output_task+0x3f8>
		/*make sure to not overwrite the snake*/
		while(lcd[snake_food.x][snake_food.y] != 0){
			snake_food.y = generateRandomNumbers(16);
    2d20:	80 e1       	ldi	r24, 0x10	; 16
    2d22:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    2d26:	80 93 de 00 	sts	0x00DE, r24
			snake_food.x = generateRandomNumbers(2) + 1 ;
    2d2a:	82 e0       	ldi	r24, 0x02	; 2
    2d2c:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    2d30:	8f 5f       	subi	r24, 0xFF	; 255
    2d32:	80 93 dd 00 	sts	0x00DD, r24
	if(snake_food.x == EMPTY || snake_food.y == EMPTY){
		/*create new apple for the snake*/
		snake_food.y = generateRandomNumbers(16);
		snake_food.x = generateRandomNumbers(2) + 1 ;
		/*make sure to not overwrite the snake*/
		while(lcd[snake_food.x][snake_food.y] != 0){
    2d36:	80 91 dd 00 	lds	r24, 0x00DD
    2d3a:	48 2f       	mov	r20, r24
    2d3c:	50 e0       	ldi	r21, 0x00	; 0
    2d3e:	80 91 de 00 	lds	r24, 0x00DE
    2d42:	28 2f       	mov	r18, r24
    2d44:	30 e0       	ldi	r19, 0x00	; 0
    2d46:	ca 01       	movw	r24, r20
    2d48:	82 95       	swap	r24
    2d4a:	92 95       	swap	r25
    2d4c:	90 7f       	andi	r25, 0xF0	; 240
    2d4e:	98 27       	eor	r25, r24
    2d50:	80 7f       	andi	r24, 0xF0	; 240
    2d52:	98 27       	eor	r25, r24
    2d54:	82 0f       	add	r24, r18
    2d56:	93 1f       	adc	r25, r19
    2d58:	fc 01       	movw	r30, r24
    2d5a:	e5 5f       	subi	r30, 0xF5	; 245
    2d5c:	f8 4f       	sbci	r31, 0xF8	; 248
    2d5e:	80 81       	ld	r24, Z
    2d60:	88 23       	and	r24, r24
    2d62:	f1 f6       	brne	.-68     	; 0x2d20 <move_snake_output_task+0x3e2>
			snake_food.y = generateRandomNumbers(16);
			snake_food.x = generateRandomNumbers(2) + 1 ;
		}
		HLCD_u8SetCursor(snake_food.x , snake_food.y );
    2d64:	80 91 dd 00 	lds	r24, 0x00DD
    2d68:	90 91 de 00 	lds	r25, 0x00DE
    2d6c:	69 2f       	mov	r22, r25
    2d6e:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendChar('X');
    2d72:	88 e5       	ldi	r24, 0x58	; 88
    2d74:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
	}

	/*make all element of lcd array = 0 for new position */

	for(u8 i = 0 ; i < 2 ;  i++){
    2d78:	1b 8a       	std	Y+19, r1	; 0x13
    2d7a:	1e c0       	rjmp	.+60     	; 0x2db8 <move_snake_output_task+0x47a>
		for(u8 j = 0 ; j < 16 ; j++){
    2d7c:	1a 8a       	std	Y+18, r1	; 0x12
    2d7e:	16 c0       	rjmp	.+44     	; 0x2dac <move_snake_output_task+0x46e>
			lcd[i][j] = 0;
    2d80:	8b 89       	ldd	r24, Y+19	; 0x13
    2d82:	48 2f       	mov	r20, r24
    2d84:	50 e0       	ldi	r21, 0x00	; 0
    2d86:	8a 89       	ldd	r24, Y+18	; 0x12
    2d88:	28 2f       	mov	r18, r24
    2d8a:	30 e0       	ldi	r19, 0x00	; 0
    2d8c:	ca 01       	movw	r24, r20
    2d8e:	82 95       	swap	r24
    2d90:	92 95       	swap	r25
    2d92:	90 7f       	andi	r25, 0xF0	; 240
    2d94:	98 27       	eor	r25, r24
    2d96:	80 7f       	andi	r24, 0xF0	; 240
    2d98:	98 27       	eor	r25, r24
    2d9a:	82 0f       	add	r24, r18
    2d9c:	93 1f       	adc	r25, r19
    2d9e:	fc 01       	movw	r30, r24
    2da0:	e5 5f       	subi	r30, 0xF5	; 245
    2da2:	f8 4f       	sbci	r31, 0xF8	; 248
    2da4:	10 82       	st	Z, r1
	}

	/*make all element of lcd array = 0 for new position */

	for(u8 i = 0 ; i < 2 ;  i++){
		for(u8 j = 0 ; j < 16 ; j++){
    2da6:	8a 89       	ldd	r24, Y+18	; 0x12
    2da8:	8f 5f       	subi	r24, 0xFF	; 255
    2daa:	8a 8b       	std	Y+18, r24	; 0x12
    2dac:	8a 89       	ldd	r24, Y+18	; 0x12
    2dae:	80 31       	cpi	r24, 0x10	; 16
    2db0:	38 f3       	brcs	.-50     	; 0x2d80 <move_snake_output_task+0x442>
		HLCD_u8SendChar('X');
	}

	/*make all element of lcd array = 0 for new position */

	for(u8 i = 0 ; i < 2 ;  i++){
    2db2:	8b 89       	ldd	r24, Y+19	; 0x13
    2db4:	8f 5f       	subi	r24, 0xFF	; 255
    2db6:	8b 8b       	std	Y+19, r24	; 0x13
    2db8:	8b 89       	ldd	r24, Y+19	; 0x13
    2dba:	82 30       	cpi	r24, 0x02	; 2
    2dbc:	f8 f2       	brcs	.-66     	; 0x2d7c <move_snake_output_task+0x43e>
		}
	}

	static u8 foodFlag = 0;
	/*display the snake*/
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2dbe:	19 8a       	std	Y+17, r1	; 0x11
    2dc0:	50 c0       	rjmp	.+160    	; 0x2e62 <move_snake_output_task+0x524>
		HLCD_u8GenerateSpecialCharacter(snake , 0);
    2dc2:	81 ee       	ldi	r24, 0xE1	; 225
    2dc4:	90 e0       	ldi	r25, 0x00	; 0
    2dc6:	60 e0       	ldi	r22, 0x00	; 0
    2dc8:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
		HLCD_u8DisplaySpecialCharacter(0 , global_snake[i].x , global_snake[i].y);
    2dcc:	89 89       	ldd	r24, Y+17	; 0x11
    2dce:	28 2f       	mov	r18, r24
    2dd0:	30 e0       	ldi	r19, 0x00	; 0
    2dd2:	c9 01       	movw	r24, r18
    2dd4:	88 0f       	add	r24, r24
    2dd6:	99 1f       	adc	r25, r25
    2dd8:	82 0f       	add	r24, r18
    2dda:	93 1f       	adc	r25, r19
    2ddc:	fc 01       	movw	r30, r24
    2dde:	ed 5c       	subi	r30, 0xCD	; 205
    2de0:	f8 4f       	sbci	r31, 0xF8	; 248
    2de2:	40 81       	ld	r20, Z
    2de4:	89 89       	ldd	r24, Y+17	; 0x11
    2de6:	28 2f       	mov	r18, r24
    2de8:	30 e0       	ldi	r19, 0x00	; 0
    2dea:	c9 01       	movw	r24, r18
    2dec:	88 0f       	add	r24, r24
    2dee:	99 1f       	adc	r25, r25
    2df0:	82 0f       	add	r24, r18
    2df2:	93 1f       	adc	r25, r19
    2df4:	fc 01       	movw	r30, r24
    2df6:	ec 5c       	subi	r30, 0xCC	; 204
    2df8:	f8 4f       	sbci	r31, 0xF8	; 248
    2dfa:	90 81       	ld	r25, Z
    2dfc:	80 e0       	ldi	r24, 0x00	; 0
    2dfe:	64 2f       	mov	r22, r20
    2e00:	49 2f       	mov	r20, r25
    2e02:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
		/*check if the snake ate the apple or not*/
		if(global_snake[global_snake_length - 1].x == snake_food.x  && global_snake[global_snake_length -1].y == snake_food.y){
    2e06:	80 91 e0 00 	lds	r24, 0x00E0
    2e0a:	88 2f       	mov	r24, r24
    2e0c:	90 e0       	ldi	r25, 0x00	; 0
    2e0e:	9c 01       	movw	r18, r24
    2e10:	21 50       	subi	r18, 0x01	; 1
    2e12:	30 40       	sbci	r19, 0x00	; 0
    2e14:	c9 01       	movw	r24, r18
    2e16:	88 0f       	add	r24, r24
    2e18:	99 1f       	adc	r25, r25
    2e1a:	82 0f       	add	r24, r18
    2e1c:	93 1f       	adc	r25, r19
    2e1e:	fc 01       	movw	r30, r24
    2e20:	ed 5c       	subi	r30, 0xCD	; 205
    2e22:	f8 4f       	sbci	r31, 0xF8	; 248
    2e24:	90 81       	ld	r25, Z
    2e26:	80 91 dd 00 	lds	r24, 0x00DD
    2e2a:	98 17       	cp	r25, r24
    2e2c:	b9 f4       	brne	.+46     	; 0x2e5c <move_snake_output_task+0x51e>
    2e2e:	80 91 e0 00 	lds	r24, 0x00E0
    2e32:	88 2f       	mov	r24, r24
    2e34:	90 e0       	ldi	r25, 0x00	; 0
    2e36:	9c 01       	movw	r18, r24
    2e38:	21 50       	subi	r18, 0x01	; 1
    2e3a:	30 40       	sbci	r19, 0x00	; 0
    2e3c:	c9 01       	movw	r24, r18
    2e3e:	88 0f       	add	r24, r24
    2e40:	99 1f       	adc	r25, r25
    2e42:	82 0f       	add	r24, r18
    2e44:	93 1f       	adc	r25, r19
    2e46:	fc 01       	movw	r30, r24
    2e48:	ec 5c       	subi	r30, 0xCC	; 204
    2e4a:	f8 4f       	sbci	r31, 0xF8	; 248
    2e4c:	90 81       	ld	r25, Z
    2e4e:	80 91 de 00 	lds	r24, 0x00DE
    2e52:	98 17       	cp	r25, r24
    2e54:	19 f4       	brne	.+6      	; 0x2e5c <move_snake_output_task+0x51e>
			foodFlag = 1;
    2e56:	81 e0       	ldi	r24, 0x01	; 1
    2e58:	80 93 46 01 	sts	0x0146, r24
		}
	}

	static u8 foodFlag = 0;
	/*display the snake*/
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2e5c:	89 89       	ldd	r24, Y+17	; 0x11
    2e5e:	8f 5f       	subi	r24, 0xFF	; 255
    2e60:	89 8b       	std	Y+17, r24	; 0x11
    2e62:	90 91 e0 00 	lds	r25, 0x00E0
    2e66:	89 89       	ldd	r24, Y+17	; 0x11
    2e68:	89 17       	cp	r24, r25
    2e6a:	08 f4       	brcc	.+2      	; 0x2e6e <move_snake_output_task+0x530>
    2e6c:	aa cf       	rjmp	.-172    	; 0x2dc2 <move_snake_output_task+0x484>
		/*check if the snake ate the apple or not*/
		if(global_snake[global_snake_length - 1].x == snake_food.x  && global_snake[global_snake_length -1].y == snake_food.y){
			foodFlag = 1;
		}
	}
		HLCD_u8SetCursor(snake_tail.x , snake_tail.y);
    2e6e:	80 91 30 07 	lds	r24, 0x0730
    2e72:	90 91 31 07 	lds	r25, 0x0731
    2e76:	69 2f       	mov	r22, r25
    2e78:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendChar(' ');
    2e7c:	80 e2       	ldi	r24, 0x20	; 32
    2e7e:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>

		/*update snake after eating the apple*/

		if(foodFlag){
    2e82:	80 91 46 01 	lds	r24, 0x0146
    2e86:	88 23       	and	r24, r24
    2e88:	09 f4       	brne	.+2      	; 0x2e8c <move_snake_output_task+0x54e>
    2e8a:	40 c0       	rjmp	.+128    	; 0x2f0c <move_snake_output_task+0x5ce>
			foodFlag = 0;
    2e8c:	10 92 46 01 	sts	0x0146, r1
			global_snake_length++;
    2e90:	80 91 e0 00 	lds	r24, 0x00E0
    2e94:	8f 5f       	subi	r24, 0xFF	; 255
    2e96:	80 93 e0 00 	sts	0x00E0, r24
			snakeScore++;
    2e9a:	80 91 42 01 	lds	r24, 0x0142
    2e9e:	8f 5f       	subi	r24, 0xFF	; 255
    2ea0:	80 93 42 01 	sts	0x0142, r24
			global_snake[global_snake_length - 1] = snake_tail;
    2ea4:	80 91 e0 00 	lds	r24, 0x00E0
    2ea8:	88 2f       	mov	r24, r24
    2eaa:	90 e0       	ldi	r25, 0x00	; 0
    2eac:	9c 01       	movw	r18, r24
    2eae:	21 50       	subi	r18, 0x01	; 1
    2eb0:	30 40       	sbci	r19, 0x00	; 0
    2eb2:	c9 01       	movw	r24, r18
    2eb4:	88 0f       	add	r24, r24
    2eb6:	99 1f       	adc	r25, r25
    2eb8:	82 0f       	add	r24, r18
    2eba:	93 1f       	adc	r25, r19
    2ebc:	8d 5c       	subi	r24, 0xCD	; 205
    2ebe:	98 4f       	sbci	r25, 0xF8	; 248
    2ec0:	9b a3       	std	Y+35, r25	; 0x23
    2ec2:	8a a3       	std	Y+34, r24	; 0x22
    2ec4:	e0 e3       	ldi	r30, 0x30	; 48
    2ec6:	f7 e0       	ldi	r31, 0x07	; 7
    2ec8:	fd a3       	std	Y+37, r31	; 0x25
    2eca:	ec a3       	std	Y+36, r30	; 0x24
    2ecc:	f3 e0       	ldi	r31, 0x03	; 3
    2ece:	fe a3       	std	Y+38, r31	; 0x26
    2ed0:	ec a1       	ldd	r30, Y+36	; 0x24
    2ed2:	fd a1       	ldd	r31, Y+37	; 0x25
    2ed4:	00 80       	ld	r0, Z
    2ed6:	2c a1       	ldd	r18, Y+36	; 0x24
    2ed8:	3d a1       	ldd	r19, Y+37	; 0x25
    2eda:	2f 5f       	subi	r18, 0xFF	; 255
    2edc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ede:	3d a3       	std	Y+37, r19	; 0x25
    2ee0:	2c a3       	std	Y+36, r18	; 0x24
    2ee2:	ea a1       	ldd	r30, Y+34	; 0x22
    2ee4:	fb a1       	ldd	r31, Y+35	; 0x23
    2ee6:	00 82       	st	Z, r0
    2ee8:	2a a1       	ldd	r18, Y+34	; 0x22
    2eea:	3b a1       	ldd	r19, Y+35	; 0x23
    2eec:	2f 5f       	subi	r18, 0xFF	; 255
    2eee:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef0:	3b a3       	std	Y+35, r19	; 0x23
    2ef2:	2a a3       	std	Y+34, r18	; 0x22
    2ef4:	3e a1       	ldd	r19, Y+38	; 0x26
    2ef6:	31 50       	subi	r19, 0x01	; 1
    2ef8:	3e a3       	std	Y+38, r19	; 0x26
    2efa:	4e a1       	ldd	r20, Y+38	; 0x26
    2efc:	44 23       	and	r20, r20
    2efe:	41 f7       	brne	.-48     	; 0x2ed0 <move_snake_output_task+0x592>
			snake_food.x = EMPTY;
    2f00:	8f ef       	ldi	r24, 0xFF	; 255
    2f02:	80 93 dd 00 	sts	0x00DD, r24
			snake_food.y = EMPTY;
    2f06:	8f ef       	ldi	r24, 0xFF	; 255
    2f08:	80 93 de 00 	sts	0x00DE, r24
		}

		/* check game over*/
		u8 end_game = 0;
    2f0c:	1f 8a       	std	Y+23, r1	; 0x17
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2f0e:	18 8a       	std	Y+16, r1	; 0x10
    2f10:	48 c0       	rjmp	.+144    	; 0x2fa2 <move_snake_output_task+0x664>
		for(u8 j = 0 ; j < global_snake_length ; j++){
    2f12:	1f 86       	std	Y+15, r1	; 0x0f
    2f14:	3d c0       	rjmp	.+122    	; 0x2f90 <move_snake_output_task+0x652>
			if(i != j){
    2f16:	98 89       	ldd	r25, Y+16	; 0x10
    2f18:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f1a:	98 17       	cp	r25, r24
    2f1c:	b1 f1       	breq	.+108    	; 0x2f8a <move_snake_output_task+0x64c>
			  if(global_snake[i].x == global_snake[j].x && global_snake[i].y == global_snake[j].y){
    2f1e:	88 89       	ldd	r24, Y+16	; 0x10
    2f20:	28 2f       	mov	r18, r24
    2f22:	30 e0       	ldi	r19, 0x00	; 0
    2f24:	c9 01       	movw	r24, r18
    2f26:	88 0f       	add	r24, r24
    2f28:	99 1f       	adc	r25, r25
    2f2a:	82 0f       	add	r24, r18
    2f2c:	93 1f       	adc	r25, r19
    2f2e:	fc 01       	movw	r30, r24
    2f30:	ed 5c       	subi	r30, 0xCD	; 205
    2f32:	f8 4f       	sbci	r31, 0xF8	; 248
    2f34:	40 81       	ld	r20, Z
    2f36:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f38:	28 2f       	mov	r18, r24
    2f3a:	30 e0       	ldi	r19, 0x00	; 0
    2f3c:	c9 01       	movw	r24, r18
    2f3e:	88 0f       	add	r24, r24
    2f40:	99 1f       	adc	r25, r25
    2f42:	82 0f       	add	r24, r18
    2f44:	93 1f       	adc	r25, r19
    2f46:	fc 01       	movw	r30, r24
    2f48:	ed 5c       	subi	r30, 0xCD	; 205
    2f4a:	f8 4f       	sbci	r31, 0xF8	; 248
    2f4c:	80 81       	ld	r24, Z
    2f4e:	48 17       	cp	r20, r24
    2f50:	e1 f4       	brne	.+56     	; 0x2f8a <move_snake_output_task+0x64c>
    2f52:	88 89       	ldd	r24, Y+16	; 0x10
    2f54:	28 2f       	mov	r18, r24
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	c9 01       	movw	r24, r18
    2f5a:	88 0f       	add	r24, r24
    2f5c:	99 1f       	adc	r25, r25
    2f5e:	82 0f       	add	r24, r18
    2f60:	93 1f       	adc	r25, r19
    2f62:	fc 01       	movw	r30, r24
    2f64:	ec 5c       	subi	r30, 0xCC	; 204
    2f66:	f8 4f       	sbci	r31, 0xF8	; 248
    2f68:	40 81       	ld	r20, Z
    2f6a:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f6c:	28 2f       	mov	r18, r24
    2f6e:	30 e0       	ldi	r19, 0x00	; 0
    2f70:	c9 01       	movw	r24, r18
    2f72:	88 0f       	add	r24, r24
    2f74:	99 1f       	adc	r25, r25
    2f76:	82 0f       	add	r24, r18
    2f78:	93 1f       	adc	r25, r19
    2f7a:	fc 01       	movw	r30, r24
    2f7c:	ec 5c       	subi	r30, 0xCC	; 204
    2f7e:	f8 4f       	sbci	r31, 0xF8	; 248
    2f80:	80 81       	ld	r24, Z
    2f82:	48 17       	cp	r20, r24
    2f84:	11 f4       	brne	.+4      	; 0x2f8a <move_snake_output_task+0x64c>
				  end_game = 1;
    2f86:	81 e0       	ldi	r24, 0x01	; 1
    2f88:	8f 8b       	std	Y+23, r24	; 0x17
		}

		/* check game over*/
		u8 end_game = 0;
	for(u8 i = 0 ; i < global_snake_length ; i++){
		for(u8 j = 0 ; j < global_snake_length ; j++){
    2f8a:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f8c:	8f 5f       	subi	r24, 0xFF	; 255
    2f8e:	8f 87       	std	Y+15, r24	; 0x0f
    2f90:	90 91 e0 00 	lds	r25, 0x00E0
    2f94:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f96:	89 17       	cp	r24, r25
    2f98:	08 f4       	brcc	.+2      	; 0x2f9c <move_snake_output_task+0x65e>
    2f9a:	bd cf       	rjmp	.-134    	; 0x2f16 <move_snake_output_task+0x5d8>
			snake_food.y = EMPTY;
		}

		/* check game over*/
		u8 end_game = 0;
	for(u8 i = 0 ; i < global_snake_length ; i++){
    2f9c:	88 89       	ldd	r24, Y+16	; 0x10
    2f9e:	8f 5f       	subi	r24, 0xFF	; 255
    2fa0:	88 8b       	std	Y+16, r24	; 0x10
    2fa2:	90 91 e0 00 	lds	r25, 0x00E0
    2fa6:	88 89       	ldd	r24, Y+16	; 0x10
    2fa8:	89 17       	cp	r24, r25
    2faa:	08 f4       	brcc	.+2      	; 0x2fae <move_snake_output_task+0x670>
    2fac:	b2 cf       	rjmp	.-156    	; 0x2f12 <move_snake_output_task+0x5d4>
		}
	}

	/*check losing*/

	if(end_game){
    2fae:	8f 89       	ldd	r24, Y+23	; 0x17
    2fb0:	88 23       	and	r24, r24
    2fb2:	09 f4       	brne	.+2      	; 0x2fb6 <move_snake_output_task+0x678>
    2fb4:	9b c0       	rjmp	.+310    	; 0x30ec <move_snake_output_task+0x7ae>
		/*game over*/
		endSnakeFlag = 1;
    2fb6:	81 e0       	ldi	r24, 0x01	; 1
    2fb8:	80 93 41 01 	sts	0x0141, r24
		HLCD_u8ClearDisplay();
    2fbc:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <HLCD_u8ClearDisplay>
		HLCD_u8SetCursor(HLCD_u8_LINE_1 , HLCD_u8_Position_4);
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
    2fc2:	64 e0       	ldi	r22, 0x04	; 4
    2fc4:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendString("Game over",0);
    2fc8:	8e e7       	ldi	r24, 0x7E	; 126
    2fca:	90 e0       	ldi	r25, 0x00	; 0
    2fcc:	60 e0       	ldi	r22, 0x00	; 0
    2fce:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
		HLCD_u8SetCursor(HLCD_u8_LINE_2 , HLCD_u8_Position_4);
    2fd2:	82 e0       	ldi	r24, 0x02	; 2
    2fd4:	64 e0       	ldi	r22, 0x04	; 4
    2fd6:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendString("score : ",0);
    2fda:	88 e8       	ldi	r24, 0x88	; 136
    2fdc:	90 e0       	ldi	r25, 0x00	; 0
    2fde:	60 e0       	ldi	r22, 0x00	; 0
    2fe0:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
		HLCD_u8SendNumber(snakeScore);
    2fe4:	80 91 42 01 	lds	r24, 0x0142
    2fe8:	88 2f       	mov	r24, r24
    2fea:	90 e0       	ldi	r25, 0x00	; 0
    2fec:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <HLCD_u8SendNumber>
    2ff0:	80 e0       	ldi	r24, 0x00	; 0
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	aa ef       	ldi	r26, 0xFA	; 250
    2ff6:	b4 e4       	ldi	r27, 0x44	; 68
    2ff8:	8b 87       	std	Y+11, r24	; 0x0b
    2ffa:	9c 87       	std	Y+12, r25	; 0x0c
    2ffc:	ad 87       	std	Y+13, r26	; 0x0d
    2ffe:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3000:	6b 85       	ldd	r22, Y+11	; 0x0b
    3002:	7c 85       	ldd	r23, Y+12	; 0x0c
    3004:	8d 85       	ldd	r24, Y+13	; 0x0d
    3006:	9e 85       	ldd	r25, Y+14	; 0x0e
    3008:	20 e0       	ldi	r18, 0x00	; 0
    300a:	30 e0       	ldi	r19, 0x00	; 0
    300c:	4a ef       	ldi	r20, 0xFA	; 250
    300e:	54 e4       	ldi	r21, 0x44	; 68
    3010:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3014:	dc 01       	movw	r26, r24
    3016:	cb 01       	movw	r24, r22
    3018:	8f 83       	std	Y+7, r24	; 0x07
    301a:	98 87       	std	Y+8, r25	; 0x08
    301c:	a9 87       	std	Y+9, r26	; 0x09
    301e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3020:	6f 81       	ldd	r22, Y+7	; 0x07
    3022:	78 85       	ldd	r23, Y+8	; 0x08
    3024:	89 85       	ldd	r24, Y+9	; 0x09
    3026:	9a 85       	ldd	r25, Y+10	; 0x0a
    3028:	20 e0       	ldi	r18, 0x00	; 0
    302a:	30 e0       	ldi	r19, 0x00	; 0
    302c:	40 e8       	ldi	r20, 0x80	; 128
    302e:	5f e3       	ldi	r21, 0x3F	; 63
    3030:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3034:	88 23       	and	r24, r24
    3036:	2c f4       	brge	.+10     	; 0x3042 <move_snake_output_task+0x704>
		__ticks = 1;
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	9e 83       	std	Y+6, r25	; 0x06
    303e:	8d 83       	std	Y+5, r24	; 0x05
    3040:	3f c0       	rjmp	.+126    	; 0x30c0 <move_snake_output_task+0x782>
	else if (__tmp > 65535)
    3042:	6f 81       	ldd	r22, Y+7	; 0x07
    3044:	78 85       	ldd	r23, Y+8	; 0x08
    3046:	89 85       	ldd	r24, Y+9	; 0x09
    3048:	9a 85       	ldd	r25, Y+10	; 0x0a
    304a:	20 e0       	ldi	r18, 0x00	; 0
    304c:	3f ef       	ldi	r19, 0xFF	; 255
    304e:	4f e7       	ldi	r20, 0x7F	; 127
    3050:	57 e4       	ldi	r21, 0x47	; 71
    3052:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3056:	18 16       	cp	r1, r24
    3058:	4c f5       	brge	.+82     	; 0x30ac <move_snake_output_task+0x76e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    305a:	6b 85       	ldd	r22, Y+11	; 0x0b
    305c:	7c 85       	ldd	r23, Y+12	; 0x0c
    305e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3060:	9e 85       	ldd	r25, Y+14	; 0x0e
    3062:	20 e0       	ldi	r18, 0x00	; 0
    3064:	30 e0       	ldi	r19, 0x00	; 0
    3066:	40 e2       	ldi	r20, 0x20	; 32
    3068:	51 e4       	ldi	r21, 0x41	; 65
    306a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    306e:	dc 01       	movw	r26, r24
    3070:	cb 01       	movw	r24, r22
    3072:	bc 01       	movw	r22, r24
    3074:	cd 01       	movw	r24, r26
    3076:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    307a:	dc 01       	movw	r26, r24
    307c:	cb 01       	movw	r24, r22
    307e:	9e 83       	std	Y+6, r25	; 0x06
    3080:	8d 83       	std	Y+5, r24	; 0x05
    3082:	0f c0       	rjmp	.+30     	; 0x30a2 <move_snake_output_task+0x764>
    3084:	88 ec       	ldi	r24, 0xC8	; 200
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	9c 83       	std	Y+4, r25	; 0x04
    308a:	8b 83       	std	Y+3, r24	; 0x03
    308c:	8b 81       	ldd	r24, Y+3	; 0x03
    308e:	9c 81       	ldd	r25, Y+4	; 0x04
    3090:	01 97       	sbiw	r24, 0x01	; 1
    3092:	f1 f7       	brne	.-4      	; 0x3090 <move_snake_output_task+0x752>
    3094:	9c 83       	std	Y+4, r25	; 0x04
    3096:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3098:	8d 81       	ldd	r24, Y+5	; 0x05
    309a:	9e 81       	ldd	r25, Y+6	; 0x06
    309c:	01 97       	sbiw	r24, 0x01	; 1
    309e:	9e 83       	std	Y+6, r25	; 0x06
    30a0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    30a2:	8d 81       	ldd	r24, Y+5	; 0x05
    30a4:	9e 81       	ldd	r25, Y+6	; 0x06
    30a6:	00 97       	sbiw	r24, 0x00	; 0
    30a8:	69 f7       	brne	.-38     	; 0x3084 <move_snake_output_task+0x746>
    30aa:	14 c0       	rjmp	.+40     	; 0x30d4 <move_snake_output_task+0x796>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    30ac:	6f 81       	ldd	r22, Y+7	; 0x07
    30ae:	78 85       	ldd	r23, Y+8	; 0x08
    30b0:	89 85       	ldd	r24, Y+9	; 0x09
    30b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    30b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    30b8:	dc 01       	movw	r26, r24
    30ba:	cb 01       	movw	r24, r22
    30bc:	9e 83       	std	Y+6, r25	; 0x06
    30be:	8d 83       	std	Y+5, r24	; 0x05
    30c0:	8d 81       	ldd	r24, Y+5	; 0x05
    30c2:	9e 81       	ldd	r25, Y+6	; 0x06
    30c4:	9a 83       	std	Y+2, r25	; 0x02
    30c6:	89 83       	std	Y+1, r24	; 0x01
    30c8:	89 81       	ldd	r24, Y+1	; 0x01
    30ca:	9a 81       	ldd	r25, Y+2	; 0x02
    30cc:	01 97       	sbiw	r24, 0x01	; 1
    30ce:	f1 f7       	brne	.-4      	; 0x30cc <move_snake_output_task+0x78e>
    30d0:	9a 83       	std	Y+2, r25	; 0x02
    30d2:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2000);
		global_snake_length = 3;
    30d4:	83 e0       	ldi	r24, 0x03	; 3
    30d6:	80 93 e0 00 	sts	0x00E0, r24
		break;
	}
	vTaskDelay(300);

  }
}
    30da:	a6 96       	adiw	r28, 0x26	; 38
    30dc:	0f b6       	in	r0, 0x3f	; 63
    30de:	f8 94       	cli
    30e0:	de bf       	out	0x3e, r29	; 62
    30e2:	0f be       	out	0x3f, r0	; 63
    30e4:	cd bf       	out	0x3d, r28	; 61
    30e6:	cf 91       	pop	r28
    30e8:	df 91       	pop	r29
    30ea:	08 95       	ret
		HLCD_u8SendNumber(snakeScore);
		_delay_ms(2000);
		global_snake_length = 3;
		break;
	}
	vTaskDelay(300);
    30ec:	8c e2       	ldi	r24, 0x2C	; 44
    30ee:	91 e0       	ldi	r25, 0x01	; 1
    30f0:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    30f4:	69 cc       	rjmp	.-1838   	; 0x29c8 <move_snake_output_task+0x8a>

000030f6 <pacman_input_task>:
 *  start hangman game tasks
 *
 *
 *  ***/

void pacman_input_task(void * Copy_Pv){
    30f6:	df 93       	push	r29
    30f8:	cf 93       	push	r28
    30fa:	00 d0       	rcall	.+0      	; 0x30fc <pacman_input_task+0x6>
    30fc:	0f 92       	push	r0
    30fe:	cd b7       	in	r28, 0x3d	; 61
    3100:	de b7       	in	r29, 0x3e	; 62
    3102:	9b 83       	std	Y+3, r25	; 0x03
    3104:	8a 83       	std	Y+2, r24	; 0x02
	/* get input from the player and send it using queue buffer*/
	while(1){
		u8 move = Get_Pressed();
    3106:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <Get_Pressed>
    310a:	89 83       	std	Y+1, r24	; 0x01

		/*send the move using queue message to pacman_eating_output_task */
		xQueueSend(pacman_buffer , &move , portMAX_DELAY);
    310c:	80 91 66 07 	lds	r24, 0x0766
    3110:	90 91 67 07 	lds	r25, 0x0767
    3114:	9e 01       	movw	r18, r28
    3116:	2f 5f       	subi	r18, 0xFF	; 255
    3118:	3f 4f       	sbci	r19, 0xFF	; 255
    311a:	b9 01       	movw	r22, r18
    311c:	4f ef       	ldi	r20, 0xFF	; 255
    311e:	5f ef       	ldi	r21, 0xFF	; 255
    3120:	20 e0       	ldi	r18, 0x00	; 0
    3122:	0e 94 f7 26 	call	0x4dee	; 0x4dee <xQueueGenericSend>
		if(pacman_end_game){
    3126:	80 91 65 07 	lds	r24, 0x0765
    312a:	88 23       	and	r24, r24
    312c:	41 f0       	breq	.+16     	; 0x313e <pacman_input_task+0x48>
			pacman_end_game = 0;
    312e:	10 92 65 07 	sts	0x0765, r1
			break;
		}
		vTaskDelay(100);
	}
}
    3132:	0f 90       	pop	r0
    3134:	0f 90       	pop	r0
    3136:	0f 90       	pop	r0
    3138:	cf 91       	pop	r28
    313a:	df 91       	pop	r29
    313c:	08 95       	ret
		xQueueSend(pacman_buffer , &move , portMAX_DELAY);
		if(pacman_end_game){
			pacman_end_game = 0;
			break;
		}
		vTaskDelay(100);
    313e:	84 e6       	ldi	r24, 0x64	; 100
    3140:	90 e0       	ldi	r25, 0x00	; 0
    3142:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    3146:	df cf       	rjmp	.-66     	; 0x3106 <pacman_input_task+0x10>

00003148 <pacman_eating_output_task>:
	}
}

void pacman_eating_output_task(void * Copy_Pv){
    3148:	df 93       	push	r29
    314a:	cf 93       	push	r28
    314c:	cd b7       	in	r28, 0x3d	; 61
    314e:	de b7       	in	r29, 0x3e	; 62
    3150:	a4 97       	sbiw	r28, 0x24	; 36
    3152:	0f b6       	in	r0, 0x3f	; 63
    3154:	f8 94       	cli
    3156:	de bf       	out	0x3e, r29	; 62
    3158:	0f be       	out	0x3f, r0	; 63
    315a:	cd bf       	out	0x3d, r28	; 61
    315c:	9a a3       	std	Y+34, r25	; 0x22
    315e:	89 a3       	std	Y+33, r24	; 0x21
 /*init the start position of the game*/

	pacman_init();
    3160:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <pacman_init>

	while(1){
		u8 move;

		/*get move from pacman_input_task*/
		xQueueReceive(pacman_buffer , &move , portMAX_DELAY);
    3164:	80 91 66 07 	lds	r24, 0x0766
    3168:	90 91 67 07 	lds	r25, 0x0767
    316c:	9e 01       	movw	r18, r28
    316e:	20 5e       	subi	r18, 0xE0	; 224
    3170:	3f 4f       	sbci	r19, 0xFF	; 255
    3172:	b9 01       	movw	r22, r18
    3174:	4f ef       	ldi	r20, 0xFF	; 255
    3176:	5f ef       	ldi	r21, 0xFF	; 255
    3178:	20 e0       	ldi	r18, 0x00	; 0
    317a:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <xQueueGenericReceive>

		/*start position*/
		HLCD_u8SetCursor(global_pacman.x , global_pacman.y);
    317e:	80 91 2d 07 	lds	r24, 0x072D
    3182:	90 91 2e 07 	lds	r25, 0x072E
    3186:	69 2f       	mov	r22, r25
    3188:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendChar(' ');
    318c:	80 e2       	ldi	r24, 0x20	; 32
    318e:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>

		/*update pacman direction according to recieved move*/

		switch(move){
    3192:	88 a1       	ldd	r24, Y+32	; 0x20
    3194:	28 2f       	mov	r18, r24
    3196:	30 e0       	ldi	r19, 0x00	; 0
    3198:	3c a3       	std	Y+36, r19	; 0x24
    319a:	2b a3       	std	Y+35, r18	; 0x23
    319c:	8b a1       	ldd	r24, Y+35	; 0x23
    319e:	9c a1       	ldd	r25, Y+36	; 0x24
    31a0:	85 33       	cpi	r24, 0x35	; 53
    31a2:	91 05       	cpc	r25, r1
    31a4:	b1 f1       	breq	.+108    	; 0x3212 <pacman_eating_output_task+0xca>
    31a6:	2b a1       	ldd	r18, Y+35	; 0x23
    31a8:	3c a1       	ldd	r19, Y+36	; 0x24
    31aa:	26 33       	cpi	r18, 0x36	; 54
    31ac:	31 05       	cpc	r19, r1
    31ae:	34 f4       	brge	.+12     	; 0x31bc <pacman_eating_output_task+0x74>
    31b0:	8b a1       	ldd	r24, Y+35	; 0x23
    31b2:	9c a1       	ldd	r25, Y+36	; 0x24
    31b4:	84 33       	cpi	r24, 0x34	; 52
    31b6:	91 05       	cpc	r25, r1
    31b8:	b1 f0       	breq	.+44     	; 0x31e6 <pacman_eating_output_task+0x9e>
    31ba:	36 c0       	rjmp	.+108    	; 0x3228 <pacman_eating_output_task+0xe0>
    31bc:	2b a1       	ldd	r18, Y+35	; 0x23
    31be:	3c a1       	ldd	r19, Y+36	; 0x24
    31c0:	26 33       	cpi	r18, 0x36	; 54
    31c2:	31 05       	cpc	r19, r1
    31c4:	31 f0       	breq	.+12     	; 0x31d2 <pacman_eating_output_task+0x8a>
    31c6:	8b a1       	ldd	r24, Y+35	; 0x23
    31c8:	9c a1       	ldd	r25, Y+36	; 0x24
    31ca:	88 33       	cpi	r24, 0x38	; 56
    31cc:	91 05       	cpc	r25, r1
    31ce:	a9 f0       	breq	.+42     	; 0x31fa <pacman_eating_output_task+0xb2>
    31d0:	2b c0       	rjmp	.+86     	; 0x3228 <pacman_eating_output_task+0xe0>
			case RIGHT :{
			  if(global_pacman.y < 15 ) global_pacman.y++;
    31d2:	80 91 2e 07 	lds	r24, 0x072E
    31d6:	8f 30       	cpi	r24, 0x0F	; 15
    31d8:	38 f5       	brcc	.+78     	; 0x3228 <pacman_eating_output_task+0xe0>
    31da:	80 91 2e 07 	lds	r24, 0x072E
    31de:	8f 5f       	subi	r24, 0xFF	; 255
    31e0:	80 93 2e 07 	sts	0x072E, r24
    31e4:	21 c0       	rjmp	.+66     	; 0x3228 <pacman_eating_output_task+0xe0>
			  break;
			}
			case LEFT :{
				if(global_pacman.y != 0) global_pacman.y--;
    31e6:	80 91 2e 07 	lds	r24, 0x072E
    31ea:	88 23       	and	r24, r24
    31ec:	e9 f0       	breq	.+58     	; 0x3228 <pacman_eating_output_task+0xe0>
    31ee:	80 91 2e 07 	lds	r24, 0x072E
    31f2:	81 50       	subi	r24, 0x01	; 1
    31f4:	80 93 2e 07 	sts	0x072E, r24
    31f8:	17 c0       	rjmp	.+46     	; 0x3228 <pacman_eating_output_task+0xe0>
				break;
			}
			case UP :{
				if(global_pacman.x == HLCD_u8_LINE_2) global_pacman.x = HLCD_u8_LINE_1;
    31fa:	80 91 2d 07 	lds	r24, 0x072D
    31fe:	82 30       	cpi	r24, 0x02	; 2
    3200:	21 f4       	brne	.+8      	; 0x320a <pacman_eating_output_task+0xc2>
    3202:	81 e0       	ldi	r24, 0x01	; 1
    3204:	80 93 2d 07 	sts	0x072D, r24
    3208:	0f c0       	rjmp	.+30     	; 0x3228 <pacman_eating_output_task+0xe0>
				else global_pacman.x = HLCD_u8_LINE_1;
    320a:	81 e0       	ldi	r24, 0x01	; 1
    320c:	80 93 2d 07 	sts	0x072D, r24
    3210:	0b c0       	rjmp	.+22     	; 0x3228 <pacman_eating_output_task+0xe0>
				break;
			}
			case DOWN:{
				if(global_pacman.x == HLCD_u8_LINE_1) global_pacman.x = HLCD_u8_LINE_2;
    3212:	80 91 2d 07 	lds	r24, 0x072D
    3216:	81 30       	cpi	r24, 0x01	; 1
    3218:	21 f4       	brne	.+8      	; 0x3222 <pacman_eating_output_task+0xda>
    321a:	82 e0       	ldi	r24, 0x02	; 2
    321c:	80 93 2d 07 	sts	0x072D, r24
    3220:	03 c0       	rjmp	.+6      	; 0x3228 <pacman_eating_output_task+0xe0>
				else global_pacman.x = HLCD_u8_LINE_2;
    3222:	82 e0       	ldi	r24, 0x02	; 2
    3224:	80 93 2d 07 	sts	0x072D, r24
				break;
			}
		}

		/*display the pacman position*/
		HLCD_u8GenerateSpecialCharacter(pacman_player , 0);
    3228:	89 ee       	ldi	r24, 0xE9	; 233
    322a:	90 e0       	ldi	r25, 0x00	; 0
    322c:	60 e0       	ldi	r22, 0x00	; 0
    322e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
		HLCD_u8DisplaySpecialCharacter(0 , global_pacman.x , global_pacman.y);
    3232:	90 91 2d 07 	lds	r25, 0x072D
    3236:	20 91 2e 07 	lds	r18, 0x072E
    323a:	80 e0       	ldi	r24, 0x00	; 0
    323c:	69 2f       	mov	r22, r25
    323e:	42 2f       	mov	r20, r18
    3240:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>

		/*update the lcd array if pacman eat the food*/
		xSemaphoreTake(pacman_sema , portMAX_DELAY);
    3244:	80 91 68 07 	lds	r24, 0x0768
    3248:	90 91 69 07 	lds	r25, 0x0769
    324c:	60 e0       	ldi	r22, 0x00	; 0
    324e:	70 e0       	ldi	r23, 0x00	; 0
    3250:	4f ef       	ldi	r20, 0xFF	; 255
    3252:	5f ef       	ldi	r21, 0xFF	; 255
    3254:	20 e0       	ldi	r18, 0x00	; 0
    3256:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <xQueueGenericReceive>
		if(lcd[global_pacman.x -1][global_pacman.y] == 1) lcd[global_pacman.x -1][global_pacman.y] = 0;
    325a:	80 91 2d 07 	lds	r24, 0x072D
    325e:	88 2f       	mov	r24, r24
    3260:	90 e0       	ldi	r25, 0x00	; 0
    3262:	ac 01       	movw	r20, r24
    3264:	41 50       	subi	r20, 0x01	; 1
    3266:	50 40       	sbci	r21, 0x00	; 0
    3268:	80 91 2e 07 	lds	r24, 0x072E
    326c:	28 2f       	mov	r18, r24
    326e:	30 e0       	ldi	r19, 0x00	; 0
    3270:	ca 01       	movw	r24, r20
    3272:	82 95       	swap	r24
    3274:	92 95       	swap	r25
    3276:	90 7f       	andi	r25, 0xF0	; 240
    3278:	98 27       	eor	r25, r24
    327a:	80 7f       	andi	r24, 0xF0	; 240
    327c:	98 27       	eor	r25, r24
    327e:	82 0f       	add	r24, r18
    3280:	93 1f       	adc	r25, r19
    3282:	fc 01       	movw	r30, r24
    3284:	e5 5f       	subi	r30, 0xF5	; 245
    3286:	f8 4f       	sbci	r31, 0xF8	; 248
    3288:	80 81       	ld	r24, Z
    328a:	81 30       	cpi	r24, 0x01	; 1
    328c:	c1 f4       	brne	.+48     	; 0x32be <pacman_eating_output_task+0x176>
    328e:	80 91 2d 07 	lds	r24, 0x072D
    3292:	88 2f       	mov	r24, r24
    3294:	90 e0       	ldi	r25, 0x00	; 0
    3296:	ac 01       	movw	r20, r24
    3298:	41 50       	subi	r20, 0x01	; 1
    329a:	50 40       	sbci	r21, 0x00	; 0
    329c:	80 91 2e 07 	lds	r24, 0x072E
    32a0:	28 2f       	mov	r18, r24
    32a2:	30 e0       	ldi	r19, 0x00	; 0
    32a4:	ca 01       	movw	r24, r20
    32a6:	82 95       	swap	r24
    32a8:	92 95       	swap	r25
    32aa:	90 7f       	andi	r25, 0xF0	; 240
    32ac:	98 27       	eor	r25, r24
    32ae:	80 7f       	andi	r24, 0xF0	; 240
    32b0:	98 27       	eor	r25, r24
    32b2:	82 0f       	add	r24, r18
    32b4:	93 1f       	adc	r25, r19
    32b6:	fc 01       	movw	r30, r24
    32b8:	e5 5f       	subi	r30, 0xF5	; 245
    32ba:	f8 4f       	sbci	r31, 0xF8	; 248
    32bc:	10 82       	st	Z, r1
		xSemaphoreGive(pacman_sema);
    32be:	80 91 68 07 	lds	r24, 0x0768
    32c2:	90 91 69 07 	lds	r25, 0x0769
    32c6:	60 e0       	ldi	r22, 0x00	; 0
    32c8:	70 e0       	ldi	r23, 0x00	; 0
    32ca:	40 e0       	ldi	r20, 0x00	; 0
    32cc:	50 e0       	ldi	r21, 0x00	; 0
    32ce:	20 e0       	ldi	r18, 0x00	; 0
    32d0:	0e 94 f7 26 	call	0x4dee	; 0x4dee <xQueueGenericSend>

		/* check if pacman ate all food*/
		u8 not_yet = 0;
    32d4:	1f 8e       	std	Y+31, r1	; 0x1f
		for(u8 i = 0 ; i < 2 ; i++){
    32d6:	1e 8e       	std	Y+30, r1	; 0x1e
    32d8:	22 c0       	rjmp	.+68     	; 0x331e <pacman_eating_output_task+0x1d6>
			for(u8 j = 0 ; j < 16 ; j++){
    32da:	1d 8e       	std	Y+29, r1	; 0x1d
    32dc:	1a c0       	rjmp	.+52     	; 0x3312 <pacman_eating_output_task+0x1ca>
				if(lcd[i][j] == 1) not_yet = 1;
    32de:	8e 8d       	ldd	r24, Y+30	; 0x1e
    32e0:	48 2f       	mov	r20, r24
    32e2:	50 e0       	ldi	r21, 0x00	; 0
    32e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    32e6:	28 2f       	mov	r18, r24
    32e8:	30 e0       	ldi	r19, 0x00	; 0
    32ea:	ca 01       	movw	r24, r20
    32ec:	82 95       	swap	r24
    32ee:	92 95       	swap	r25
    32f0:	90 7f       	andi	r25, 0xF0	; 240
    32f2:	98 27       	eor	r25, r24
    32f4:	80 7f       	andi	r24, 0xF0	; 240
    32f6:	98 27       	eor	r25, r24
    32f8:	82 0f       	add	r24, r18
    32fa:	93 1f       	adc	r25, r19
    32fc:	fc 01       	movw	r30, r24
    32fe:	e5 5f       	subi	r30, 0xF5	; 245
    3300:	f8 4f       	sbci	r31, 0xF8	; 248
    3302:	80 81       	ld	r24, Z
    3304:	81 30       	cpi	r24, 0x01	; 1
    3306:	11 f4       	brne	.+4      	; 0x330c <pacman_eating_output_task+0x1c4>
    3308:	81 e0       	ldi	r24, 0x01	; 1
    330a:	8f 8f       	std	Y+31, r24	; 0x1f
		xSemaphoreGive(pacman_sema);

		/* check if pacman ate all food*/
		u8 not_yet = 0;
		for(u8 i = 0 ; i < 2 ; i++){
			for(u8 j = 0 ; j < 16 ; j++){
    330c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    330e:	8f 5f       	subi	r24, 0xFF	; 255
    3310:	8d 8f       	std	Y+29, r24	; 0x1d
    3312:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3314:	80 31       	cpi	r24, 0x10	; 16
    3316:	18 f3       	brcs	.-58     	; 0x32de <pacman_eating_output_task+0x196>
		if(lcd[global_pacman.x -1][global_pacman.y] == 1) lcd[global_pacman.x -1][global_pacman.y] = 0;
		xSemaphoreGive(pacman_sema);

		/* check if pacman ate all food*/
		u8 not_yet = 0;
		for(u8 i = 0 ; i < 2 ; i++){
    3318:	8e 8d       	ldd	r24, Y+30	; 0x1e
    331a:	8f 5f       	subi	r24, 0xFF	; 255
    331c:	8e 8f       	std	Y+30, r24	; 0x1e
    331e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3320:	82 30       	cpi	r24, 0x02	; 2
    3322:	d8 f2       	brcs	.-74     	; 0x32da <pacman_eating_output_task+0x192>
				if(lcd[i][j] == 1) not_yet = 1;
			}
		}

		/*check winning*/
		if(!not_yet){
    3324:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3326:	88 23       	and	r24, r24
    3328:	09 f0       	breq	.+2      	; 0x332c <pacman_eating_output_task+0x1e4>
    332a:	80 c0       	rjmp	.+256    	; 0x342c <pacman_eating_output_task+0x2e4>
			pacman_end_game = 1;
    332c:	81 e0       	ldi	r24, 0x01	; 1
    332e:	80 93 65 07 	sts	0x0765, r24
			HLCD_u8ClearDisplay();
    3332:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <HLCD_u8ClearDisplay>
			HLCD_u8SetCursor(1,5);
    3336:	81 e0       	ldi	r24, 0x01	; 1
    3338:	65 e0       	ldi	r22, 0x05	; 5
    333a:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			HLCD_u8SendString("you won",0);
    333e:	81 e9       	ldi	r24, 0x91	; 145
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	60 e0       	ldi	r22, 0x00	; 0
    3344:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
    3348:	80 e0       	ldi	r24, 0x00	; 0
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	aa ef       	ldi	r26, 0xFA	; 250
    334e:	b4 e4       	ldi	r27, 0x44	; 68
    3350:	89 8f       	std	Y+25, r24	; 0x19
    3352:	9a 8f       	std	Y+26, r25	; 0x1a
    3354:	ab 8f       	std	Y+27, r26	; 0x1b
    3356:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3358:	69 8d       	ldd	r22, Y+25	; 0x19
    335a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    335c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    335e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3360:	20 e0       	ldi	r18, 0x00	; 0
    3362:	30 e0       	ldi	r19, 0x00	; 0
    3364:	4a ef       	ldi	r20, 0xFA	; 250
    3366:	54 e4       	ldi	r21, 0x44	; 68
    3368:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    336c:	dc 01       	movw	r26, r24
    336e:	cb 01       	movw	r24, r22
    3370:	8d 8b       	std	Y+21, r24	; 0x15
    3372:	9e 8b       	std	Y+22, r25	; 0x16
    3374:	af 8b       	std	Y+23, r26	; 0x17
    3376:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3378:	6d 89       	ldd	r22, Y+21	; 0x15
    337a:	7e 89       	ldd	r23, Y+22	; 0x16
    337c:	8f 89       	ldd	r24, Y+23	; 0x17
    337e:	98 8d       	ldd	r25, Y+24	; 0x18
    3380:	20 e0       	ldi	r18, 0x00	; 0
    3382:	30 e0       	ldi	r19, 0x00	; 0
    3384:	40 e8       	ldi	r20, 0x80	; 128
    3386:	5f e3       	ldi	r21, 0x3F	; 63
    3388:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    338c:	88 23       	and	r24, r24
    338e:	2c f4       	brge	.+10     	; 0x339a <pacman_eating_output_task+0x252>
		__ticks = 1;
    3390:	81 e0       	ldi	r24, 0x01	; 1
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	9c 8b       	std	Y+20, r25	; 0x14
    3396:	8b 8b       	std	Y+19, r24	; 0x13
    3398:	3f c0       	rjmp	.+126    	; 0x3418 <pacman_eating_output_task+0x2d0>
	else if (__tmp > 65535)
    339a:	6d 89       	ldd	r22, Y+21	; 0x15
    339c:	7e 89       	ldd	r23, Y+22	; 0x16
    339e:	8f 89       	ldd	r24, Y+23	; 0x17
    33a0:	98 8d       	ldd	r25, Y+24	; 0x18
    33a2:	20 e0       	ldi	r18, 0x00	; 0
    33a4:	3f ef       	ldi	r19, 0xFF	; 255
    33a6:	4f e7       	ldi	r20, 0x7F	; 127
    33a8:	57 e4       	ldi	r21, 0x47	; 71
    33aa:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    33ae:	18 16       	cp	r1, r24
    33b0:	4c f5       	brge	.+82     	; 0x3404 <pacman_eating_output_task+0x2bc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33b2:	69 8d       	ldd	r22, Y+25	; 0x19
    33b4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    33b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    33b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    33ba:	20 e0       	ldi	r18, 0x00	; 0
    33bc:	30 e0       	ldi	r19, 0x00	; 0
    33be:	40 e2       	ldi	r20, 0x20	; 32
    33c0:	51 e4       	ldi	r21, 0x41	; 65
    33c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33c6:	dc 01       	movw	r26, r24
    33c8:	cb 01       	movw	r24, r22
    33ca:	bc 01       	movw	r22, r24
    33cc:	cd 01       	movw	r24, r26
    33ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33d2:	dc 01       	movw	r26, r24
    33d4:	cb 01       	movw	r24, r22
    33d6:	9c 8b       	std	Y+20, r25	; 0x14
    33d8:	8b 8b       	std	Y+19, r24	; 0x13
    33da:	0f c0       	rjmp	.+30     	; 0x33fa <pacman_eating_output_task+0x2b2>
    33dc:	88 ec       	ldi	r24, 0xC8	; 200
    33de:	90 e0       	ldi	r25, 0x00	; 0
    33e0:	9a 8b       	std	Y+18, r25	; 0x12
    33e2:	89 8b       	std	Y+17, r24	; 0x11
    33e4:	89 89       	ldd	r24, Y+17	; 0x11
    33e6:	9a 89       	ldd	r25, Y+18	; 0x12
    33e8:	01 97       	sbiw	r24, 0x01	; 1
    33ea:	f1 f7       	brne	.-4      	; 0x33e8 <pacman_eating_output_task+0x2a0>
    33ec:	9a 8b       	std	Y+18, r25	; 0x12
    33ee:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    33f0:	8b 89       	ldd	r24, Y+19	; 0x13
    33f2:	9c 89       	ldd	r25, Y+20	; 0x14
    33f4:	01 97       	sbiw	r24, 0x01	; 1
    33f6:	9c 8b       	std	Y+20, r25	; 0x14
    33f8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    33fa:	8b 89       	ldd	r24, Y+19	; 0x13
    33fc:	9c 89       	ldd	r25, Y+20	; 0x14
    33fe:	00 97       	sbiw	r24, 0x00	; 0
    3400:	69 f7       	brne	.-38     	; 0x33dc <pacman_eating_output_task+0x294>
    3402:	14 c0       	rjmp	.+40     	; 0x342c <pacman_eating_output_task+0x2e4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3404:	6d 89       	ldd	r22, Y+21	; 0x15
    3406:	7e 89       	ldd	r23, Y+22	; 0x16
    3408:	8f 89       	ldd	r24, Y+23	; 0x17
    340a:	98 8d       	ldd	r25, Y+24	; 0x18
    340c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3410:	dc 01       	movw	r26, r24
    3412:	cb 01       	movw	r24, r22
    3414:	9c 8b       	std	Y+20, r25	; 0x14
    3416:	8b 8b       	std	Y+19, r24	; 0x13
    3418:	8b 89       	ldd	r24, Y+19	; 0x13
    341a:	9c 89       	ldd	r25, Y+20	; 0x14
    341c:	98 8b       	std	Y+16, r25	; 0x10
    341e:	8f 87       	std	Y+15, r24	; 0x0f
    3420:	8f 85       	ldd	r24, Y+15	; 0x0f
    3422:	98 89       	ldd	r25, Y+16	; 0x10
    3424:	01 97       	sbiw	r24, 0x01	; 1
    3426:	f1 f7       	brne	.-4      	; 0x3424 <pacman_eating_output_task+0x2dc>
    3428:	98 8b       	std	Y+16, r25	; 0x10
    342a:	8f 87       	std	Y+15, r24	; 0x0f
			_delay_ms(2000);
		}

		/*check losing*/
		if(global_pacman.x == global_pacman_moster.x && global_pacman.y == global_pacman_moster.y){
    342c:	90 91 2d 07 	lds	r25, 0x072D
    3430:	80 91 60 07 	lds	r24, 0x0760
    3434:	98 17       	cp	r25, r24
    3436:	09 f0       	breq	.+2      	; 0x343a <pacman_eating_output_task+0x2f2>
    3438:	88 c0       	rjmp	.+272    	; 0x354a <pacman_eating_output_task+0x402>
    343a:	90 91 2e 07 	lds	r25, 0x072E
    343e:	80 91 61 07 	lds	r24, 0x0761
    3442:	98 17       	cp	r25, r24
    3444:	09 f0       	breq	.+2      	; 0x3448 <pacman_eating_output_task+0x300>
    3446:	81 c0       	rjmp	.+258    	; 0x354a <pacman_eating_output_task+0x402>
			pacman_end_game = 1;
    3448:	81 e0       	ldi	r24, 0x01	; 1
    344a:	80 93 65 07 	sts	0x0765, r24
			HLCD_u8ClearDisplay();
    344e:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <HLCD_u8ClearDisplay>
			HLCD_u8SetCursor(1,4);
    3452:	81 e0       	ldi	r24, 0x01	; 1
    3454:	64 e0       	ldi	r22, 0x04	; 4
    3456:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			HLCD_u8SendString("you lost",0);
    345a:	89 e9       	ldi	r24, 0x99	; 153
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	60 e0       	ldi	r22, 0x00	; 0
    3460:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
    3464:	80 e0       	ldi	r24, 0x00	; 0
    3466:	90 e0       	ldi	r25, 0x00	; 0
    3468:	aa ef       	ldi	r26, 0xFA	; 250
    346a:	b4 e4       	ldi	r27, 0x44	; 68
    346c:	8b 87       	std	Y+11, r24	; 0x0b
    346e:	9c 87       	std	Y+12, r25	; 0x0c
    3470:	ad 87       	std	Y+13, r26	; 0x0d
    3472:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3474:	6b 85       	ldd	r22, Y+11	; 0x0b
    3476:	7c 85       	ldd	r23, Y+12	; 0x0c
    3478:	8d 85       	ldd	r24, Y+13	; 0x0d
    347a:	9e 85       	ldd	r25, Y+14	; 0x0e
    347c:	20 e0       	ldi	r18, 0x00	; 0
    347e:	30 e0       	ldi	r19, 0x00	; 0
    3480:	4a ef       	ldi	r20, 0xFA	; 250
    3482:	54 e4       	ldi	r21, 0x44	; 68
    3484:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3488:	dc 01       	movw	r26, r24
    348a:	cb 01       	movw	r24, r22
    348c:	8f 83       	std	Y+7, r24	; 0x07
    348e:	98 87       	std	Y+8, r25	; 0x08
    3490:	a9 87       	std	Y+9, r26	; 0x09
    3492:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3494:	6f 81       	ldd	r22, Y+7	; 0x07
    3496:	78 85       	ldd	r23, Y+8	; 0x08
    3498:	89 85       	ldd	r24, Y+9	; 0x09
    349a:	9a 85       	ldd	r25, Y+10	; 0x0a
    349c:	20 e0       	ldi	r18, 0x00	; 0
    349e:	30 e0       	ldi	r19, 0x00	; 0
    34a0:	40 e8       	ldi	r20, 0x80	; 128
    34a2:	5f e3       	ldi	r21, 0x3F	; 63
    34a4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    34a8:	88 23       	and	r24, r24
    34aa:	2c f4       	brge	.+10     	; 0x34b6 <pacman_eating_output_task+0x36e>
		__ticks = 1;
    34ac:	81 e0       	ldi	r24, 0x01	; 1
    34ae:	90 e0       	ldi	r25, 0x00	; 0
    34b0:	9e 83       	std	Y+6, r25	; 0x06
    34b2:	8d 83       	std	Y+5, r24	; 0x05
    34b4:	3f c0       	rjmp	.+126    	; 0x3534 <pacman_eating_output_task+0x3ec>
	else if (__tmp > 65535)
    34b6:	6f 81       	ldd	r22, Y+7	; 0x07
    34b8:	78 85       	ldd	r23, Y+8	; 0x08
    34ba:	89 85       	ldd	r24, Y+9	; 0x09
    34bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    34be:	20 e0       	ldi	r18, 0x00	; 0
    34c0:	3f ef       	ldi	r19, 0xFF	; 255
    34c2:	4f e7       	ldi	r20, 0x7F	; 127
    34c4:	57 e4       	ldi	r21, 0x47	; 71
    34c6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    34ca:	18 16       	cp	r1, r24
    34cc:	4c f5       	brge	.+82     	; 0x3520 <pacman_eating_output_task+0x3d8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    34ce:	6b 85       	ldd	r22, Y+11	; 0x0b
    34d0:	7c 85       	ldd	r23, Y+12	; 0x0c
    34d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    34d4:	9e 85       	ldd	r25, Y+14	; 0x0e
    34d6:	20 e0       	ldi	r18, 0x00	; 0
    34d8:	30 e0       	ldi	r19, 0x00	; 0
    34da:	40 e2       	ldi	r20, 0x20	; 32
    34dc:	51 e4       	ldi	r21, 0x41	; 65
    34de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    34e2:	dc 01       	movw	r26, r24
    34e4:	cb 01       	movw	r24, r22
    34e6:	bc 01       	movw	r22, r24
    34e8:	cd 01       	movw	r24, r26
    34ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34ee:	dc 01       	movw	r26, r24
    34f0:	cb 01       	movw	r24, r22
    34f2:	9e 83       	std	Y+6, r25	; 0x06
    34f4:	8d 83       	std	Y+5, r24	; 0x05
    34f6:	0f c0       	rjmp	.+30     	; 0x3516 <pacman_eating_output_task+0x3ce>
    34f8:	88 ec       	ldi	r24, 0xC8	; 200
    34fa:	90 e0       	ldi	r25, 0x00	; 0
    34fc:	9c 83       	std	Y+4, r25	; 0x04
    34fe:	8b 83       	std	Y+3, r24	; 0x03
    3500:	8b 81       	ldd	r24, Y+3	; 0x03
    3502:	9c 81       	ldd	r25, Y+4	; 0x04
    3504:	01 97       	sbiw	r24, 0x01	; 1
    3506:	f1 f7       	brne	.-4      	; 0x3504 <pacman_eating_output_task+0x3bc>
    3508:	9c 83       	std	Y+4, r25	; 0x04
    350a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    350c:	8d 81       	ldd	r24, Y+5	; 0x05
    350e:	9e 81       	ldd	r25, Y+6	; 0x06
    3510:	01 97       	sbiw	r24, 0x01	; 1
    3512:	9e 83       	std	Y+6, r25	; 0x06
    3514:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3516:	8d 81       	ldd	r24, Y+5	; 0x05
    3518:	9e 81       	ldd	r25, Y+6	; 0x06
    351a:	00 97       	sbiw	r24, 0x00	; 0
    351c:	69 f7       	brne	.-38     	; 0x34f8 <pacman_eating_output_task+0x3b0>
    351e:	1a c0       	rjmp	.+52     	; 0x3554 <pacman_eating_output_task+0x40c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3520:	6f 81       	ldd	r22, Y+7	; 0x07
    3522:	78 85       	ldd	r23, Y+8	; 0x08
    3524:	89 85       	ldd	r24, Y+9	; 0x09
    3526:	9a 85       	ldd	r25, Y+10	; 0x0a
    3528:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    352c:	dc 01       	movw	r26, r24
    352e:	cb 01       	movw	r24, r22
    3530:	9e 83       	std	Y+6, r25	; 0x06
    3532:	8d 83       	std	Y+5, r24	; 0x05
    3534:	8d 81       	ldd	r24, Y+5	; 0x05
    3536:	9e 81       	ldd	r25, Y+6	; 0x06
    3538:	9a 83       	std	Y+2, r25	; 0x02
    353a:	89 83       	std	Y+1, r24	; 0x01
    353c:	89 81       	ldd	r24, Y+1	; 0x01
    353e:	9a 81       	ldd	r25, Y+2	; 0x02
    3540:	01 97       	sbiw	r24, 0x01	; 1
    3542:	f1 f7       	brne	.-4      	; 0x3540 <pacman_eating_output_task+0x3f8>
    3544:	9a 83       	std	Y+2, r25	; 0x02
    3546:	89 83       	std	Y+1, r24	; 0x01
    3548:	05 c0       	rjmp	.+10     	; 0x3554 <pacman_eating_output_task+0x40c>
			_delay_ms(2000);
			break;
		}
		vTaskDelay(100);
    354a:	84 e6       	ldi	r24, 0x64	; 100
    354c:	90 e0       	ldi	r25, 0x00	; 0
    354e:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    3552:	08 ce       	rjmp	.-1008   	; 0x3164 <pacman_eating_output_task+0x1c>
	}
}
    3554:	a4 96       	adiw	r28, 0x24	; 36
    3556:	0f b6       	in	r0, 0x3f	; 63
    3558:	f8 94       	cli
    355a:	de bf       	out	0x3e, r29	; 62
    355c:	0f be       	out	0x3f, r0	; 63
    355e:	cd bf       	out	0x3d, r28	; 61
    3560:	cf 91       	pop	r28
    3562:	df 91       	pop	r29
    3564:	08 95       	ret

00003566 <pacman_monster_task>:


void pacman_monster_task(void* Copy_Pv){
    3566:	df 93       	push	r29
    3568:	cf 93       	push	r28
    356a:	00 d0       	rcall	.+0      	; 0x356c <pacman_monster_task+0x6>
    356c:	00 d0       	rcall	.+0      	; 0x356e <pacman_monster_task+0x8>
    356e:	cd b7       	in	r28, 0x3d	; 61
    3570:	de b7       	in	r29, 0x3e	; 62
    3572:	9c 83       	std	Y+4, r25	; 0x04
    3574:	8b 83       	std	Y+3, r24	; 0x03

   /*start position of pacman monster*/
	global_pacman_moster.x = HLCD_u8_LINE_1;
    3576:	81 e0       	ldi	r24, 0x01	; 1
    3578:	80 93 60 07 	sts	0x0760, r24
	global_pacman_moster.y = HLCD_u8_Position_15;
    357c:	8f e0       	ldi	r24, 0x0F	; 15
    357e:	80 93 61 07 	sts	0x0761, r24
	global_pacman_moster.direction = pacman_direction_left;
    3582:	81 e0       	ldi	r24, 0x01	; 1
    3584:	80 93 62 07 	sts	0x0762, r24

	/*display pacman monster at the beginning*/
	HLCD_u8GenerateSpecialCharacter(pacman_monster , 8);
    3588:	81 ef       	ldi	r24, 0xF1	; 241
    358a:	90 e0       	ldi	r25, 0x00	; 0
    358c:	68 e0       	ldi	r22, 0x08	; 8
    358e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(1 , global_pacman_moster.x , global_pacman_moster.y);
    3592:	90 91 60 07 	lds	r25, 0x0760
    3596:	20 91 61 07 	lds	r18, 0x0761
    359a:	81 e0       	ldi	r24, 0x01	; 1
    359c:	69 2f       	mov	r22, r25
    359e:	42 2f       	mov	r20, r18
    35a0:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
	while(1){

		static u8 food_x , food_y , monster_overwrite_food = 0;

		/*get random move for pacman monster*/
		dir_x = generateRandomNumbers(2) + 1 ;
    35a4:	82 e0       	ldi	r24, 0x02	; 2
    35a6:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    35aa:	8f 5f       	subi	r24, 0xFF	; 255
    35ac:	8a 83       	std	Y+2, r24	; 0x02
		dir_y = generateRandomNumbers(3) ;
    35ae:	83 e0       	ldi	r24, 0x03	; 3
    35b0:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    35b4:	89 83       	std	Y+1, r24	; 0x01

		/*clear the previous position */
		HLCD_u8SetCursor(global_pacman_moster.x , global_pacman_moster.y);
    35b6:	80 91 60 07 	lds	r24, 0x0760
    35ba:	90 91 61 07 	lds	r25, 0x0761
    35be:	69 2f       	mov	r22, r25
    35c0:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendChar(' ');
    35c4:	80 e2       	ldi	r24, 0x20	; 32
    35c6:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>

		/*update pacman monster position according to random move
		 * in such way to prevent stuck in certain position
		 * */

		global_pacman_moster.x = dir_x;
    35ca:	8a 81       	ldd	r24, Y+2	; 0x02
    35cc:	80 93 60 07 	sts	0x0760, r24
		if(dir_y == 1){
    35d0:	89 81       	ldd	r24, Y+1	; 0x01
    35d2:	81 30       	cpi	r24, 0x01	; 1
    35d4:	c9 f4       	brne	.+50     	; 0x3608 <pacman_monster_task+0xa2>
			if(global_pacman_moster.y != 0 ){
    35d6:	80 91 61 07 	lds	r24, 0x0761
    35da:	88 23       	and	r24, r24
    35dc:	81 f1       	breq	.+96     	; 0x363e <pacman_monster_task+0xd8>
				static u8 flag = 0;
				if(!flag){
    35de:	80 91 48 01 	lds	r24, 0x0148
    35e2:	88 23       	and	r24, r24
    35e4:	49 f4       	brne	.+18     	; 0x35f8 <pacman_monster_task+0x92>
					flag = 1;
    35e6:	81 e0       	ldi	r24, 0x01	; 1
    35e8:	80 93 48 01 	sts	0x0148, r24
					global_pacman_moster.y--;
    35ec:	80 91 61 07 	lds	r24, 0x0761
    35f0:	81 50       	subi	r24, 0x01	; 1
    35f2:	80 93 61 07 	sts	0x0761, r24
    35f6:	23 c0       	rjmp	.+70     	; 0x363e <pacman_monster_task+0xd8>
				}
				else{
					flag = 0;
    35f8:	10 92 48 01 	sts	0x0148, r1
					global_pacman_moster.y -= 2;
    35fc:	80 91 61 07 	lds	r24, 0x0761
    3600:	82 50       	subi	r24, 0x02	; 2
    3602:	80 93 61 07 	sts	0x0761, r24
    3606:	1b c0       	rjmp	.+54     	; 0x363e <pacman_monster_task+0xd8>
				}
			}
		}else if(dir_y == 2){
    3608:	89 81       	ldd	r24, Y+1	; 0x01
    360a:	82 30       	cpi	r24, 0x02	; 2
    360c:	c1 f4       	brne	.+48     	; 0x363e <pacman_monster_task+0xd8>
			if(global_pacman_moster.y < 15 ){
    360e:	80 91 61 07 	lds	r24, 0x0761
    3612:	8f 30       	cpi	r24, 0x0F	; 15
    3614:	a0 f4       	brcc	.+40     	; 0x363e <pacman_monster_task+0xd8>
				static u8 flag = 0;
				if(!flag){
    3616:	80 91 47 01 	lds	r24, 0x0147
    361a:	88 23       	and	r24, r24
    361c:	49 f4       	brne	.+18     	; 0x3630 <pacman_monster_task+0xca>
					flag = 1;
    361e:	81 e0       	ldi	r24, 0x01	; 1
    3620:	80 93 47 01 	sts	0x0147, r24
					global_pacman_moster.y++;
    3624:	80 91 61 07 	lds	r24, 0x0761
    3628:	8f 5f       	subi	r24, 0xFF	; 255
    362a:	80 93 61 07 	sts	0x0761, r24
    362e:	07 c0       	rjmp	.+14     	; 0x363e <pacman_monster_task+0xd8>
				}
				else{
					flag = 0;
    3630:	10 92 47 01 	sts	0x0147, r1
					global_pacman_moster.y += 2;
    3634:	80 91 61 07 	lds	r24, 0x0761
    3638:	8e 5f       	subi	r24, 0xFE	; 254
    363a:	80 93 61 07 	sts	0x0761, r24
				}
			}
		}
		/*display the new position of pacman monster*/
		HLCD_u8GenerateSpecialCharacter(pacman_monster , 8);
    363e:	81 ef       	ldi	r24, 0xF1	; 241
    3640:	90 e0       	ldi	r25, 0x00	; 0
    3642:	68 e0       	ldi	r22, 0x08	; 8
    3644:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
		HLCD_u8DisplaySpecialCharacter(1 , global_pacman_moster.x , global_pacman_moster.y);
    3648:	90 91 60 07 	lds	r25, 0x0760
    364c:	20 91 61 07 	lds	r18, 0x0761
    3650:	81 e0       	ldi	r24, 0x01	; 1
    3652:	69 2f       	mov	r22, r25
    3654:	42 2f       	mov	r20, r18
    3656:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>

		/*check if pacman monster is at the same position of food and handle it*/
		if(monster_overwrite_food){
    365a:	80 91 49 01 	lds	r24, 0x0149
    365e:	88 23       	and	r24, r24
    3660:	81 f0       	breq	.+32     	; 0x3682 <pacman_monster_task+0x11c>
			HLCD_u8SetCursor(food_x , food_y);
    3662:	80 91 4b 01 	lds	r24, 0x014B
    3666:	90 91 4a 01 	lds	r25, 0x014A
    366a:	69 2f       	mov	r22, r25
    366c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			HLCD_u8SendChar('x');
    3670:	88 e7       	ldi	r24, 0x78	; 120
    3672:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
			food_x = 0 ;
    3676:	10 92 4b 01 	sts	0x014B, r1
			food_y = 0 ;
    367a:	10 92 4a 01 	sts	0x014A, r1
			monster_overwrite_food = 0;
    367e:	10 92 49 01 	sts	0x0149, r1
		}

		if(lcd[global_pacman_moster.x -1][global_pacman_moster.y] == 1) {
    3682:	80 91 60 07 	lds	r24, 0x0760
    3686:	88 2f       	mov	r24, r24
    3688:	90 e0       	ldi	r25, 0x00	; 0
    368a:	ac 01       	movw	r20, r24
    368c:	41 50       	subi	r20, 0x01	; 1
    368e:	50 40       	sbci	r21, 0x00	; 0
    3690:	80 91 61 07 	lds	r24, 0x0761
    3694:	28 2f       	mov	r18, r24
    3696:	30 e0       	ldi	r19, 0x00	; 0
    3698:	ca 01       	movw	r24, r20
    369a:	82 95       	swap	r24
    369c:	92 95       	swap	r25
    369e:	90 7f       	andi	r25, 0xF0	; 240
    36a0:	98 27       	eor	r25, r24
    36a2:	80 7f       	andi	r24, 0xF0	; 240
    36a4:	98 27       	eor	r25, r24
    36a6:	82 0f       	add	r24, r18
    36a8:	93 1f       	adc	r25, r19
    36aa:	fc 01       	movw	r30, r24
    36ac:	e5 5f       	subi	r30, 0xF5	; 245
    36ae:	f8 4f       	sbci	r31, 0xF8	; 248
    36b0:	80 81       	ld	r24, Z
    36b2:	81 30       	cpi	r24, 0x01	; 1
    36b4:	59 f4       	brne	.+22     	; 0x36cc <pacman_monster_task+0x166>
			food_x =  global_pacman_moster.x;
    36b6:	80 91 60 07 	lds	r24, 0x0760
    36ba:	80 93 4b 01 	sts	0x014B, r24
			food_y = global_pacman_moster.y ;
    36be:	80 91 61 07 	lds	r24, 0x0761
    36c2:	80 93 4a 01 	sts	0x014A, r24
			monster_overwrite_food = 1;
    36c6:	81 e0       	ldi	r24, 0x01	; 1
    36c8:	80 93 49 01 	sts	0x0149, r24
		}

		/*check if game over to break*/
		if(pacman_end_game){
    36cc:	80 91 65 07 	lds	r24, 0x0765
    36d0:	88 23       	and	r24, r24
    36d2:	49 f0       	breq	.+18     	; 0x36e6 <pacman_monster_task+0x180>
			pacman_end_game = 0;
    36d4:	10 92 65 07 	sts	0x0765, r1
			break;
		}
		vTaskDelay(300);
	}
}
    36d8:	0f 90       	pop	r0
    36da:	0f 90       	pop	r0
    36dc:	0f 90       	pop	r0
    36de:	0f 90       	pop	r0
    36e0:	cf 91       	pop	r28
    36e2:	df 91       	pop	r29
    36e4:	08 95       	ret
		/*check if game over to break*/
		if(pacman_end_game){
			pacman_end_game = 0;
			break;
		}
		vTaskDelay(300);
    36e6:	8c e2       	ldi	r24, 0x2C	; 44
    36e8:	91 e0       	ldi	r25, 0x01	; 1
    36ea:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    36ee:	5a cf       	rjmp	.-332    	; 0x35a4 <pacman_monster_task+0x3e>

000036f0 <pacman_init>:
	}
}


void pacman_init(void){
    36f0:	df 93       	push	r29
    36f2:	cf 93       	push	r28
    36f4:	00 d0       	rcall	.+0      	; 0x36f6 <pacman_init+0x6>
    36f6:	cd b7       	in	r28, 0x3d	; 61
    36f8:	de b7       	in	r29, 0x3e	; 62
	/*display the pacman at the start position*/

	global_pacman.x = HLCD_u8_LINE_1;
    36fa:	81 e0       	ldi	r24, 0x01	; 1
    36fc:	80 93 2d 07 	sts	0x072D, r24
	global_pacman.y = 0;
    3700:	10 92 2e 07 	sts	0x072E, r1
	global_pacman.direction = pacman_direction_right;
    3704:	10 92 2f 07 	sts	0x072F, r1
	HLCD_u8GenerateSpecialCharacter(pacman_player , 0);
    3708:	89 ee       	ldi	r24, 0xE9	; 233
    370a:	90 e0       	ldi	r25, 0x00	; 0
    370c:	60 e0       	ldi	r22, 0x00	; 0
    370e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(0 , global_pacman.x , global_pacman.y);
    3712:	90 91 2d 07 	lds	r25, 0x072D
    3716:	20 91 2e 07 	lds	r18, 0x072E
    371a:	80 e0       	ldi	r24, 0x00	; 0
    371c:	69 2f       	mov	r22, r25
    371e:	42 2f       	mov	r20, r18
    3720:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>

	/*print the food of the pacman*/
	for(u8 i = 1 ; i <= 2 ; i++){
    3724:	81 e0       	ldi	r24, 0x01	; 1
    3726:	8a 83       	std	Y+2, r24	; 0x02
    3728:	35 c0       	rjmp	.+106    	; 0x3794 <pacman_init+0xa4>
		for(u8 j = 0 ; j < 16 ; j++){
    372a:	19 82       	std	Y+1, r1	; 0x01
    372c:	2d c0       	rjmp	.+90     	; 0x3788 <pacman_init+0x98>
				if((i == 1 && j == 0) || (i == 1 && j == 15)) continue;
    372e:	8a 81       	ldd	r24, Y+2	; 0x02
    3730:	81 30       	cpi	r24, 0x01	; 1
    3732:	19 f4       	brne	.+6      	; 0x373a <pacman_init+0x4a>
    3734:	89 81       	ldd	r24, Y+1	; 0x01
    3736:	88 23       	and	r24, r24
    3738:	21 f1       	breq	.+72     	; 0x3782 <pacman_init+0x92>
    373a:	8a 81       	ldd	r24, Y+2	; 0x02
    373c:	81 30       	cpi	r24, 0x01	; 1
    373e:	19 f4       	brne	.+6      	; 0x3746 <pacman_init+0x56>
    3740:	89 81       	ldd	r24, Y+1	; 0x01
    3742:	8f 30       	cpi	r24, 0x0F	; 15
    3744:	f1 f0       	breq	.+60     	; 0x3782 <pacman_init+0x92>
				else{
					HLCD_u8SetCursor(i , j);
    3746:	8a 81       	ldd	r24, Y+2	; 0x02
    3748:	69 81       	ldd	r22, Y+1	; 0x01
    374a:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
					HLCD_u8SendChar('x');
    374e:	88 e7       	ldi	r24, 0x78	; 120
    3750:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
					lcd[i-1][j] = 1;
    3754:	8a 81       	ldd	r24, Y+2	; 0x02
    3756:	88 2f       	mov	r24, r24
    3758:	90 e0       	ldi	r25, 0x00	; 0
    375a:	ac 01       	movw	r20, r24
    375c:	41 50       	subi	r20, 0x01	; 1
    375e:	50 40       	sbci	r21, 0x00	; 0
    3760:	89 81       	ldd	r24, Y+1	; 0x01
    3762:	28 2f       	mov	r18, r24
    3764:	30 e0       	ldi	r19, 0x00	; 0
    3766:	ca 01       	movw	r24, r20
    3768:	82 95       	swap	r24
    376a:	92 95       	swap	r25
    376c:	90 7f       	andi	r25, 0xF0	; 240
    376e:	98 27       	eor	r25, r24
    3770:	80 7f       	andi	r24, 0xF0	; 240
    3772:	98 27       	eor	r25, r24
    3774:	82 0f       	add	r24, r18
    3776:	93 1f       	adc	r25, r19
    3778:	fc 01       	movw	r30, r24
    377a:	e5 5f       	subi	r30, 0xF5	; 245
    377c:	f8 4f       	sbci	r31, 0xF8	; 248
    377e:	81 e0       	ldi	r24, 0x01	; 1
    3780:	80 83       	st	Z, r24
	HLCD_u8GenerateSpecialCharacter(pacman_player , 0);
	HLCD_u8DisplaySpecialCharacter(0 , global_pacman.x , global_pacman.y);

	/*print the food of the pacman*/
	for(u8 i = 1 ; i <= 2 ; i++){
		for(u8 j = 0 ; j < 16 ; j++){
    3782:	89 81       	ldd	r24, Y+1	; 0x01
    3784:	8f 5f       	subi	r24, 0xFF	; 255
    3786:	89 83       	std	Y+1, r24	; 0x01
    3788:	89 81       	ldd	r24, Y+1	; 0x01
    378a:	80 31       	cpi	r24, 0x10	; 16
    378c:	80 f2       	brcs	.-96     	; 0x372e <pacman_init+0x3e>
	global_pacman.direction = pacman_direction_right;
	HLCD_u8GenerateSpecialCharacter(pacman_player , 0);
	HLCD_u8DisplaySpecialCharacter(0 , global_pacman.x , global_pacman.y);

	/*print the food of the pacman*/
	for(u8 i = 1 ; i <= 2 ; i++){
    378e:	8a 81       	ldd	r24, Y+2	; 0x02
    3790:	8f 5f       	subi	r24, 0xFF	; 255
    3792:	8a 83       	std	Y+2, r24	; 0x02
    3794:	8a 81       	ldd	r24, Y+2	; 0x02
    3796:	83 30       	cpi	r24, 0x03	; 3
    3798:	40 f2       	brcs	.-112    	; 0x372a <pacman_init+0x3a>
					HLCD_u8SendChar('x');
					lcd[i-1][j] = 1;
				}
			}
		}
}
    379a:	0f 90       	pop	r0
    379c:	0f 90       	pop	r0
    379e:	cf 91       	pop	r28
    37a0:	df 91       	pop	r29
    37a2:	08 95       	ret

000037a4 <headball_player_task>:



/*** start Head Ball game tasks ***/

void headball_player_task(void * Copy_Pv){
    37a4:	df 93       	push	r29
    37a6:	cf 93       	push	r28
    37a8:	00 d0       	rcall	.+0      	; 0x37aa <headball_player_task+0x6>
    37aa:	0f 92       	push	r0
    37ac:	cd b7       	in	r28, 0x3d	; 61
    37ae:	de b7       	in	r29, 0x3e	; 62
    37b0:	9b 83       	std	Y+3, r25	; 0x03
    37b2:	8a 83       	std	Y+2, r24	; 0x02

	while(1){
		u8 move;
		/*get the move from player up or down*/
		move = Get_Pressed();
    37b4:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <Get_Pressed>
    37b8:	89 83       	std	Y+1, r24	; 0x01

		/*check the move and update the new position*/
		if(move == HEADBALL_UP){
    37ba:	89 81       	ldd	r24, Y+1	; 0x01
    37bc:	88 33       	cpi	r24, 0x38	; 56
    37be:	99 f4       	brne	.+38     	; 0x37e6 <headball_player_task+0x42>
			 HLCD_u8SetCursor(HLCD_u8_LINE_2 , HLCD_u8_Position_1);
    37c0:	82 e0       	ldi	r24, 0x02	; 2
    37c2:	61 e0       	ldi	r22, 0x01	; 1
    37c4:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			 HLCD_u8SendChar(' ');
    37c8:	80 e2       	ldi	r24, 0x20	; 32
    37ca:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
			 HLCD_u8DisplaySpecialCharacter(4 , HLCD_u8_LINE_1 , HLCD_u8_Position_1);
    37ce:	84 e0       	ldi	r24, 0x04	; 4
    37d0:	61 e0       	ldi	r22, 0x01	; 1
    37d2:	41 e0       	ldi	r20, 0x01	; 1
    37d4:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
			 player.x = HLCD_u8_LINE_1;
    37d8:	81 e0       	ldi	r24, 0x01	; 1
    37da:	80 93 2b 07 	sts	0x072B, r24
			 player.y = HLCD_u8_Position_1;
    37de:	81 e0       	ldi	r24, 0x01	; 1
    37e0:	80 93 2c 07 	sts	0x072C, r24
    37e4:	15 c0       	rjmp	.+42     	; 0x3810 <headball_player_task+0x6c>
		}else if(move == HEADBALL_DOWN){
    37e6:	89 81       	ldd	r24, Y+1	; 0x01
    37e8:	85 33       	cpi	r24, 0x35	; 53
    37ea:	91 f4       	brne	.+36     	; 0x3810 <headball_player_task+0x6c>
			HLCD_u8SetCursor(HLCD_u8_LINE_1 , HLCD_u8_Position_1);
    37ec:	81 e0       	ldi	r24, 0x01	; 1
    37ee:	61 e0       	ldi	r22, 0x01	; 1
    37f0:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			HLCD_u8SendChar(' ');
    37f4:	80 e2       	ldi	r24, 0x20	; 32
    37f6:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
			HLCD_u8DisplaySpecialCharacter(4 , HLCD_u8_LINE_2 , HLCD_u8_Position_1);
    37fa:	84 e0       	ldi	r24, 0x04	; 4
    37fc:	62 e0       	ldi	r22, 0x02	; 2
    37fe:	41 e0       	ldi	r20, 0x01	; 1
    3800:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
			 player.x = HLCD_u8_LINE_2;
    3804:	82 e0       	ldi	r24, 0x02	; 2
    3806:	80 93 2b 07 	sts	0x072B, r24
			 player.y = HLCD_u8_Position_1;
    380a:	81 e0       	ldi	r24, 0x01	; 1
    380c:	80 93 2c 07 	sts	0x072C, r24
		}
		/*check if game over to break*/
		if(headball_end_game) break;
    3810:	80 91 45 01 	lds	r24, 0x0145
    3814:	88 23       	and	r24, r24
    3816:	29 f4       	brne	.+10     	; 0x3822 <headball_player_task+0x7e>
		vTaskDelay(100);
    3818:	84 e6       	ldi	r24, 0x64	; 100
    381a:	90 e0       	ldi	r25, 0x00	; 0
    381c:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    3820:	c9 cf       	rjmp	.-110    	; 0x37b4 <headball_player_task+0x10>
	}
}
    3822:	0f 90       	pop	r0
    3824:	0f 90       	pop	r0
    3826:	0f 90       	pop	r0
    3828:	cf 91       	pop	r28
    382a:	df 91       	pop	r29
    382c:	08 95       	ret

0000382e <headball_automated_player_task>:


void headball_automated_player_task(void * Copy_Pv){
    382e:	df 93       	push	r29
    3830:	cf 93       	push	r28
    3832:	00 d0       	rcall	.+0      	; 0x3834 <headball_automated_player_task+0x6>
    3834:	0f 92       	push	r0
    3836:	cd b7       	in	r28, 0x3d	; 61
    3838:	de b7       	in	r29, 0x3e	; 62
    383a:	9b 83       	std	Y+3, r25	; 0x03
    383c:	8a 83       	std	Y+2, r24	; 0x02
		static u8 flag1 = 0 , flag2 = 0;

		/*get random move
		 *
		 * it's implemented in such a way to prevent stuck in a certain position */
		move = generateRandomNumbers(4);
    383e:	84 e0       	ldi	r24, 0x04	; 4
    3840:	0e 94 e4 31 	call	0x63c8	; 0x63c8 <generateRandomNumbers>
    3844:	89 83       	std	Y+1, r24	; 0x01
		if(move != -1){

			/* flag used to prevent stuck if timer generate same number by chance alot */

			if(flag1 >= 3){
    3846:	80 91 4d 01 	lds	r24, 0x014D
    384a:	83 30       	cpi	r24, 0x03	; 3
    384c:	18 f0       	brcs	.+6      	; 0x3854 <headball_automated_player_task+0x26>
				flag1 = 0;
    384e:	10 92 4d 01 	sts	0x014D, r1
				move = 0;
    3852:	19 82       	std	Y+1, r1	; 0x01
			}
			if(flag2 >= 3){
    3854:	80 91 4c 01 	lds	r24, 0x014C
    3858:	83 30       	cpi	r24, 0x03	; 3
    385a:	20 f0       	brcs	.+8      	; 0x3864 <headball_automated_player_task+0x36>
				flag2 = 0;
    385c:	10 92 4c 01 	sts	0x014C, r1
				move = 1;
    3860:	81 e0       	ldi	r24, 0x01	; 1
    3862:	89 83       	std	Y+1, r24	; 0x01
			}
		  if(move == 0 || move == 2 ){
    3864:	89 81       	ldd	r24, Y+1	; 0x01
    3866:	88 23       	and	r24, r24
    3868:	19 f0       	breq	.+6      	; 0x3870 <headball_automated_player_task+0x42>
    386a:	89 81       	ldd	r24, Y+1	; 0x01
    386c:	82 30       	cpi	r24, 0x02	; 2
    386e:	c1 f4       	brne	.+48     	; 0x38a0 <headball_automated_player_task+0x72>

			  /*clear the old position*/
			  HLCD_u8SetCursor(HLCD_u8_LINE_1 , HLCD_u8_Position_14);
    3870:	81 e0       	ldi	r24, 0x01	; 1
    3872:	6e e0       	ldi	r22, 0x0E	; 14
    3874:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			  HLCD_u8SendChar(' ');
    3878:	80 e2       	ldi	r24, 0x20	; 32
    387a:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>

			  /*update and display the new position*/
			  HLCD_u8DisplaySpecialCharacter(4 , HLCD_u8_LINE_2 , HLCD_u8_Position_14 );
    387e:	84 e0       	ldi	r24, 0x04	; 4
    3880:	62 e0       	ldi	r22, 0x02	; 2
    3882:	4e e0       	ldi	r20, 0x0E	; 14
    3884:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
			  automated_player.x = HLCD_u8_LINE_2;
    3888:	82 e0       	ldi	r24, 0x02	; 2
    388a:	80 93 63 07 	sts	0x0763, r24
			  automated_player.y = HLCD_u8_Position_14;
    388e:	8e e0       	ldi	r24, 0x0E	; 14
    3890:	80 93 64 07 	sts	0x0764, r24
			  flag2++;
    3894:	80 91 4c 01 	lds	r24, 0x014C
    3898:	8f 5f       	subi	r24, 0xFF	; 255
    389a:	80 93 4c 01 	sts	0x014C, r24
    389e:	1d c0       	rjmp	.+58     	; 0x38da <headball_automated_player_task+0xac>

		  }else if(move == 1 || move == 3){
    38a0:	89 81       	ldd	r24, Y+1	; 0x01
    38a2:	81 30       	cpi	r24, 0x01	; 1
    38a4:	19 f0       	breq	.+6      	; 0x38ac <headball_automated_player_task+0x7e>
    38a6:	89 81       	ldd	r24, Y+1	; 0x01
    38a8:	83 30       	cpi	r24, 0x03	; 3
    38aa:	b9 f4       	brne	.+46     	; 0x38da <headball_automated_player_task+0xac>
			  /*clear the old position*/
			  HLCD_u8SetCursor(HLCD_u8_LINE_2 , HLCD_u8_Position_14);
    38ac:	82 e0       	ldi	r24, 0x02	; 2
    38ae:	6e e0       	ldi	r22, 0x0E	; 14
    38b0:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			  HLCD_u8SendChar(' ');
    38b4:	80 e2       	ldi	r24, 0x20	; 32
    38b6:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>

			  /*update and display the new position*/
			  HLCD_u8DisplaySpecialCharacter(4 , HLCD_u8_LINE_1 , HLCD_u8_Position_14 );
    38ba:	84 e0       	ldi	r24, 0x04	; 4
    38bc:	61 e0       	ldi	r22, 0x01	; 1
    38be:	4e e0       	ldi	r20, 0x0E	; 14
    38c0:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
			  automated_player.x = HLCD_u8_LINE_1;
    38c4:	81 e0       	ldi	r24, 0x01	; 1
    38c6:	80 93 63 07 	sts	0x0763, r24
			  automated_player.y = HLCD_u8_Position_14;
    38ca:	8e e0       	ldi	r24, 0x0E	; 14
    38cc:	80 93 64 07 	sts	0x0764, r24
			  flag1++;
    38d0:	80 91 4d 01 	lds	r24, 0x014D
    38d4:	8f 5f       	subi	r24, 0xFF	; 255
    38d6:	80 93 4d 01 	sts	0x014D, r24
		  }
		}

		/*check if game over to break*/
		if(headball_end_game) break;
    38da:	80 91 45 01 	lds	r24, 0x0145
    38de:	88 23       	and	r24, r24
    38e0:	29 f4       	brne	.+10     	; 0x38ec <headball_automated_player_task+0xbe>
		vTaskDelay(250);
    38e2:	8a ef       	ldi	r24, 0xFA	; 250
    38e4:	90 e0       	ldi	r25, 0x00	; 0
    38e6:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    38ea:	a9 cf       	rjmp	.-174    	; 0x383e <headball_automated_player_task+0x10>
	}
}
    38ec:	0f 90       	pop	r0
    38ee:	0f 90       	pop	r0
    38f0:	0f 90       	pop	r0
    38f2:	cf 91       	pop	r28
    38f4:	df 91       	pop	r29
    38f6:	08 95       	ret

000038f8 <headball_ball_task>:




void headball_ball_task(void * Copy_Pv){
    38f8:	df 93       	push	r29
    38fa:	cf 93       	push	r28
    38fc:	cd b7       	in	r28, 0x3d	; 61
    38fe:	de b7       	in	r29, 0x3e	; 62
    3900:	60 97       	sbiw	r28, 0x10	; 16
    3902:	0f b6       	in	r0, 0x3f	; 63
    3904:	f8 94       	cli
    3906:	de bf       	out	0x3e, r29	; 62
    3908:	0f be       	out	0x3f, r0	; 63
    390a:	cd bf       	out	0x3d, r28	; 61
    390c:	98 8b       	std	Y+16, r25	; 0x10
    390e:	8f 87       	std	Y+15, r24	; 0x0f

	/*init the headball game and the start position */
	 headball_init();
    3910:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <headball_init>
	while(1){

		/*flag to check if the player touch the ball or not*/
    static u8 flag = 0;

	if(automated_player.x == x && automated_player.y == y){
    3914:	90 91 63 07 	lds	r25, 0x0763
    3918:	80 91 31 01 	lds	r24, 0x0131
    391c:	98 17       	cp	r25, r24
    391e:	81 f4       	brne	.+32     	; 0x3940 <headball_ball_task+0x48>
    3920:	90 91 64 07 	lds	r25, 0x0764
    3924:	80 91 32 01 	lds	r24, 0x0132
    3928:	98 17       	cp	r25, r24
    392a:	51 f4       	brne	.+20     	; 0x3940 <headball_ball_task+0x48>
		/*if automated player touch the ball
		 * update the new position of ball*/
		flag = 1;
    392c:	81 e0       	ldi	r24, 0x01	; 1
    392e:	80 93 4e 01 	sts	0x014E, r24
		y = 13;
    3932:	8d e0       	ldi	r24, 0x0D	; 13
    3934:	80 93 32 01 	sts	0x0132, r24
		prev_y = 14;
    3938:	8e e0       	ldi	r24, 0x0E	; 14
    393a:	80 93 34 01 	sts	0x0134, r24
    393e:	14 c0       	rjmp	.+40     	; 0x3968 <headball_ball_task+0x70>
	}else if(player.x == x && player.y == y){
    3940:	90 91 2b 07 	lds	r25, 0x072B
    3944:	80 91 31 01 	lds	r24, 0x0131
    3948:	98 17       	cp	r25, r24
    394a:	71 f4       	brne	.+28     	; 0x3968 <headball_ball_task+0x70>
    394c:	90 91 2c 07 	lds	r25, 0x072C
    3950:	80 91 32 01 	lds	r24, 0x0132
    3954:	98 17       	cp	r25, r24
    3956:	41 f4       	brne	.+16     	; 0x3968 <headball_ball_task+0x70>
		/*if automated player didn't touch the ball
		 * player 1 will get the ball again*/
		y = 2;
    3958:	82 e0       	ldi	r24, 0x02	; 2
    395a:	80 93 32 01 	sts	0x0132, r24
		prev_y = 1;
    395e:	81 e0       	ldi	r24, 0x01	; 1
    3960:	80 93 34 01 	sts	0x0134, r24
		flag = 0;
    3964:	10 92 4e 01 	sts	0x014E, r1
	}
	if(flag == 0){
    3968:	80 91 4e 01 	lds	r24, 0x014E
    396c:	88 23       	and	r24, r24
    396e:	09 f0       	breq	.+2      	; 0x3972 <headball_ball_task+0x7a>
    3970:	52 c0       	rjmp	.+164    	; 0x3a16 <headball_ball_task+0x11e>
		/*update the position of the ball every time when the task
		 * be in the running state*/
		y++;
    3972:	80 91 32 01 	lds	r24, 0x0132
    3976:	8f 5f       	subi	r24, 0xFF	; 255
    3978:	80 93 32 01 	sts	0x0132, r24
        prev_y++;
    397c:	80 91 34 01 	lds	r24, 0x0134
    3980:	8f 5f       	subi	r24, 0xFF	; 255
    3982:	80 93 34 01 	sts	0x0134, r24

        /*check the ball enter the goal or the other player touched it*/
        if(y == 15){
    3986:	80 91 32 01 	lds	r24, 0x0132
    398a:	8f 30       	cpi	r24, 0x0F	; 15
    398c:	a1 f5       	brne	.+104    	; 0x39f6 <headball_ball_task+0xfe>
        	if(automated_player.x == x && automated_player.y == y){
    398e:	90 91 63 07 	lds	r25, 0x0763
    3992:	80 91 31 01 	lds	r24, 0x0131
    3996:	98 17       	cp	r25, r24
    3998:	d9 f4       	brne	.+54     	; 0x39d0 <headball_ball_task+0xd8>
    399a:	90 91 64 07 	lds	r25, 0x0764
    399e:	80 91 32 01 	lds	r24, 0x0132
    39a2:	98 17       	cp	r25, r24
    39a4:	a9 f4       	brne	.+42     	; 0x39d0 <headball_ball_task+0xd8>

        		/*update the position of ball*/
        		flag = 1;
    39a6:	81 e0       	ldi	r24, 0x01	; 1
    39a8:	80 93 4e 01 	sts	0x014E, r24
        		y = 13;
    39ac:	8d e0       	ldi	r24, 0x0D	; 13
    39ae:	80 93 32 01 	sts	0x0132, r24
        		prev_y = 14;
    39b2:	8e e0       	ldi	r24, 0x0E	; 14
    39b4:	80 93 34 01 	sts	0x0134, r24
        		if(automated_player.x == HLCD_u8_LINE_1) x = HLCD_u8_LINE_2;
    39b8:	80 91 63 07 	lds	r24, 0x0763
    39bc:	81 30       	cpi	r24, 0x01	; 1
    39be:	21 f4       	brne	.+8      	; 0x39c8 <headball_ball_task+0xd0>
    39c0:	82 e0       	ldi	r24, 0x02	; 2
    39c2:	80 93 31 01 	sts	0x0131, r24
    39c6:	13 c0       	rjmp	.+38     	; 0x39ee <headball_ball_task+0xf6>
        		else x = HLCD_u8_LINE_1;
    39c8:	81 e0       	ldi	r24, 0x01	; 1
    39ca:	80 93 31 01 	sts	0x0131, r24
    39ce:	0f c0       	rjmp	.+30     	; 0x39ee <headball_ball_task+0xf6>
        	}else{

        		/*ball entered the goal player1 points should increase by one*/
        		player_points++;
    39d0:	80 91 43 01 	lds	r24, 0x0143
    39d4:	8f 5f       	subi	r24, 0xFF	; 255
    39d6:	80 93 43 01 	sts	0x0143, r24
        		 y = 2;
    39da:	82 e0       	ldi	r24, 0x02	; 2
    39dc:	80 93 32 01 	sts	0x0132, r24
        		 prev_y = 1;
    39e0:	81 e0       	ldi	r24, 0x01	; 1
    39e2:	80 93 34 01 	sts	0x0134, r24
        		 x = player.x;
    39e6:	80 91 2b 07 	lds	r24, 0x072B
    39ea:	80 93 31 01 	sts	0x0131, r24
        	}
        	prev_x = x;
    39ee:	80 91 31 01 	lds	r24, 0x0131
    39f2:	80 93 33 01 	sts	0x0133, r24
        }
	 if(prev_y > 1){
    39f6:	80 91 34 01 	lds	r24, 0x0134
    39fa:	82 30       	cpi	r24, 0x02	; 2
    39fc:	08 f4       	brcc	.+2      	; 0x3a00 <headball_ball_task+0x108>
    39fe:	5a c0       	rjmp	.+180    	; 0x3ab4 <headball_ball_task+0x1bc>
		 /*remove the old position of ball*/
	       HLCD_u8SetCursor(prev_x , prev_y);
    3a00:	80 91 33 01 	lds	r24, 0x0133
    3a04:	90 91 34 01 	lds	r25, 0x0134
    3a08:	69 2f       	mov	r22, r25
    3a0a:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		   HLCD_u8SendChar(' ');
    3a0e:	80 e2       	ldi	r24, 0x20	; 32
    3a10:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
    3a14:	4f c0       	rjmp	.+158    	; 0x3ab4 <headball_ball_task+0x1bc>
	   }
	}else{

		/*now ball in the opposite direction from the automated player to player1 */
		/*update the position of the ball*/
		y--;
    3a16:	80 91 32 01 	lds	r24, 0x0132
    3a1a:	81 50       	subi	r24, 0x01	; 1
    3a1c:	80 93 32 01 	sts	0x0132, r24
		prev_y--;
    3a20:	80 91 34 01 	lds	r24, 0x0134
    3a24:	81 50       	subi	r24, 0x01	; 1
    3a26:	80 93 34 01 	sts	0x0134, r24

		/*remove the old position of the ball*/
		if(prev_y < 14){
    3a2a:	80 91 34 01 	lds	r24, 0x0134
    3a2e:	8e 30       	cpi	r24, 0x0E	; 14
    3a30:	50 f4       	brcc	.+20     	; 0x3a46 <headball_ball_task+0x14e>
			HLCD_u8SetCursor(prev_x , prev_y);
    3a32:	80 91 33 01 	lds	r24, 0x0133
    3a36:	90 91 34 01 	lds	r25, 0x0134
    3a3a:	69 2f       	mov	r22, r25
    3a3c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
			HLCD_u8SendChar(' ');
    3a40:	80 e2       	ldi	r24, 0x20	; 32
    3a42:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <HLCD_u8SendChar>
		}

		if(y == 1){
    3a46:	80 91 32 01 	lds	r24, 0x0132
    3a4a:	81 30       	cpi	r24, 0x01	; 1
    3a4c:	99 f5       	brne	.+102    	; 0x3ab4 <headball_ball_task+0x1bc>

			/*check the ball enter the goal or the other player touched it*/

		if(player.x == x && player.y == y){
    3a4e:	90 91 2b 07 	lds	r25, 0x072B
    3a52:	80 91 31 01 	lds	r24, 0x0131
    3a56:	98 17       	cp	r25, r24
    3a58:	d1 f4       	brne	.+52     	; 0x3a8e <headball_ball_task+0x196>
    3a5a:	90 91 2c 07 	lds	r25, 0x072C
    3a5e:	80 91 32 01 	lds	r24, 0x0132
    3a62:	98 17       	cp	r25, r24
    3a64:	a1 f4       	brne	.+40     	; 0x3a8e <headball_ball_task+0x196>
			/*player1 touched the ball and get it*/
			y = 2;
    3a66:	82 e0       	ldi	r24, 0x02	; 2
    3a68:	80 93 32 01 	sts	0x0132, r24
			prev_y = 1;
    3a6c:	81 e0       	ldi	r24, 0x01	; 1
    3a6e:	80 93 34 01 	sts	0x0134, r24
			flag = 0;
    3a72:	10 92 4e 01 	sts	0x014E, r1
			if(player.x == HLCD_u8_LINE_1) x = HLCD_u8_LINE_2;
    3a76:	80 91 2b 07 	lds	r24, 0x072B
    3a7a:	81 30       	cpi	r24, 0x01	; 1
    3a7c:	21 f4       	brne	.+8      	; 0x3a86 <headball_ball_task+0x18e>
    3a7e:	82 e0       	ldi	r24, 0x02	; 2
    3a80:	80 93 31 01 	sts	0x0131, r24
    3a84:	13 c0       	rjmp	.+38     	; 0x3aac <headball_ball_task+0x1b4>
			else x = HLCD_u8_LINE_1;
    3a86:	81 e0       	ldi	r24, 0x01	; 1
    3a88:	80 93 31 01 	sts	0x0131, r24
    3a8c:	0f c0       	rjmp	.+30     	; 0x3aac <headball_ball_task+0x1b4>
		}else{
			/*the ball entered the goal so automated player should increment by one*/
			automated_player_points++;
    3a8e:	80 91 44 01 	lds	r24, 0x0144
    3a92:	8f 5f       	subi	r24, 0xFF	; 255
    3a94:	80 93 44 01 	sts	0x0144, r24
			 y = 13;
    3a98:	8d e0       	ldi	r24, 0x0D	; 13
    3a9a:	80 93 32 01 	sts	0x0132, r24
			 prev_y = 14;
    3a9e:	8e e0       	ldi	r24, 0x0E	; 14
    3aa0:	80 93 34 01 	sts	0x0134, r24
			 x = automated_player.x;
    3aa4:	80 91 63 07 	lds	r24, 0x0763
    3aa8:	80 93 31 01 	sts	0x0131, r24
		}
		prev_x = x;
    3aac:	80 91 31 01 	lds	r24, 0x0131
    3ab0:	80 93 33 01 	sts	0x0133, r24
}
	}

	/*display the new position of the ball*/
	HLCD_u8GenerateSpecialCharacter(headball_ball , 56);
    3ab4:	89 e2       	ldi	r24, 0x29	; 41
    3ab6:	91 e0       	ldi	r25, 0x01	; 1
    3ab8:	68 e3       	ldi	r22, 0x38	; 56
    3aba:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(7 , x , y);
    3abe:	90 91 31 01 	lds	r25, 0x0131
    3ac2:	20 91 32 01 	lds	r18, 0x0132
    3ac6:	87 e0       	ldi	r24, 0x07	; 7
    3ac8:	69 2f       	mov	r22, r25
    3aca:	42 2f       	mov	r20, r18
    3acc:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>

	/*check the winner*/
	if(automated_player_points >=5 || player_points >= 5){
    3ad0:	80 91 44 01 	lds	r24, 0x0144
    3ad4:	85 30       	cpi	r24, 0x05	; 5
    3ad6:	28 f4       	brcc	.+10     	; 0x3ae2 <headball_ball_task+0x1ea>
    3ad8:	80 91 43 01 	lds	r24, 0x0143
    3adc:	85 30       	cpi	r24, 0x05	; 5
    3ade:	08 f4       	brcc	.+2      	; 0x3ae2 <headball_ball_task+0x1ea>
    3ae0:	96 c0       	rjmp	.+300    	; 0x3c0e <headball_ball_task+0x316>
		HLCD_u8ClearDisplay();
    3ae2:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <HLCD_u8ClearDisplay>
		HLCD_u8SetCursor(HLCD_u8_LINE_1 , HLCD_u8_Position_0);
    3ae6:	81 e0       	ldi	r24, 0x01	; 1
    3ae8:	60 e0       	ldi	r22, 0x00	; 0
    3aea:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendString("player1 : " , 0);
    3aee:	82 ea       	ldi	r24, 0xA2	; 162
    3af0:	90 e0       	ldi	r25, 0x00	; 0
    3af2:	60 e0       	ldi	r22, 0x00	; 0
    3af4:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
		HLCD_u8SendNumber(player_points);
    3af8:	80 91 43 01 	lds	r24, 0x0143
    3afc:	88 2f       	mov	r24, r24
    3afe:	90 e0       	ldi	r25, 0x00	; 0
    3b00:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <HLCD_u8SendNumber>
		HLCD_u8SetCursor(HLCD_u8_LINE_2 , HLCD_u8_Position_0);
    3b04:	82 e0       	ldi	r24, 0x02	; 2
    3b06:	60 e0       	ldi	r22, 0x00	; 0
    3b08:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <HLCD_u8SetCursor>
		HLCD_u8SendString("player2 : " , 0);
    3b0c:	8d ea       	ldi	r24, 0xAD	; 173
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	60 e0       	ldi	r22, 0x00	; 0
    3b12:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <HLCD_u8SendString>
		HLCD_u8SendNumber(automated_player_points);
    3b16:	80 91 44 01 	lds	r24, 0x0144
    3b1a:	88 2f       	mov	r24, r24
    3b1c:	90 e0       	ldi	r25, 0x00	; 0
    3b1e:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <HLCD_u8SendNumber>
		headball_end_game = 1;
    3b22:	81 e0       	ldi	r24, 0x01	; 1
    3b24:	80 93 45 01 	sts	0x0145, r24
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	90 e0       	ldi	r25, 0x00	; 0
    3b2c:	aa ef       	ldi	r26, 0xFA	; 250
    3b2e:	b4 e4       	ldi	r27, 0x44	; 68
    3b30:	8b 87       	std	Y+11, r24	; 0x0b
    3b32:	9c 87       	std	Y+12, r25	; 0x0c
    3b34:	ad 87       	std	Y+13, r26	; 0x0d
    3b36:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b38:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b3a:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b40:	20 e0       	ldi	r18, 0x00	; 0
    3b42:	30 e0       	ldi	r19, 0x00	; 0
    3b44:	4a ef       	ldi	r20, 0xFA	; 250
    3b46:	54 e4       	ldi	r21, 0x44	; 68
    3b48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b4c:	dc 01       	movw	r26, r24
    3b4e:	cb 01       	movw	r24, r22
    3b50:	8f 83       	std	Y+7, r24	; 0x07
    3b52:	98 87       	std	Y+8, r25	; 0x08
    3b54:	a9 87       	std	Y+9, r26	; 0x09
    3b56:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3b58:	6f 81       	ldd	r22, Y+7	; 0x07
    3b5a:	78 85       	ldd	r23, Y+8	; 0x08
    3b5c:	89 85       	ldd	r24, Y+9	; 0x09
    3b5e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b60:	20 e0       	ldi	r18, 0x00	; 0
    3b62:	30 e0       	ldi	r19, 0x00	; 0
    3b64:	40 e8       	ldi	r20, 0x80	; 128
    3b66:	5f e3       	ldi	r21, 0x3F	; 63
    3b68:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b6c:	88 23       	and	r24, r24
    3b6e:	2c f4       	brge	.+10     	; 0x3b7a <headball_ball_task+0x282>
		__ticks = 1;
    3b70:	81 e0       	ldi	r24, 0x01	; 1
    3b72:	90 e0       	ldi	r25, 0x00	; 0
    3b74:	9e 83       	std	Y+6, r25	; 0x06
    3b76:	8d 83       	std	Y+5, r24	; 0x05
    3b78:	3f c0       	rjmp	.+126    	; 0x3bf8 <headball_ball_task+0x300>
	else if (__tmp > 65535)
    3b7a:	6f 81       	ldd	r22, Y+7	; 0x07
    3b7c:	78 85       	ldd	r23, Y+8	; 0x08
    3b7e:	89 85       	ldd	r24, Y+9	; 0x09
    3b80:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b82:	20 e0       	ldi	r18, 0x00	; 0
    3b84:	3f ef       	ldi	r19, 0xFF	; 255
    3b86:	4f e7       	ldi	r20, 0x7F	; 127
    3b88:	57 e4       	ldi	r21, 0x47	; 71
    3b8a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b8e:	18 16       	cp	r1, r24
    3b90:	4c f5       	brge	.+82     	; 0x3be4 <headball_ball_task+0x2ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b92:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b94:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b96:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b98:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b9a:	20 e0       	ldi	r18, 0x00	; 0
    3b9c:	30 e0       	ldi	r19, 0x00	; 0
    3b9e:	40 e2       	ldi	r20, 0x20	; 32
    3ba0:	51 e4       	ldi	r21, 0x41	; 65
    3ba2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ba6:	dc 01       	movw	r26, r24
    3ba8:	cb 01       	movw	r24, r22
    3baa:	bc 01       	movw	r22, r24
    3bac:	cd 01       	movw	r24, r26
    3bae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bb2:	dc 01       	movw	r26, r24
    3bb4:	cb 01       	movw	r24, r22
    3bb6:	9e 83       	std	Y+6, r25	; 0x06
    3bb8:	8d 83       	std	Y+5, r24	; 0x05
    3bba:	0f c0       	rjmp	.+30     	; 0x3bda <headball_ball_task+0x2e2>
    3bbc:	88 ec       	ldi	r24, 0xC8	; 200
    3bbe:	90 e0       	ldi	r25, 0x00	; 0
    3bc0:	9c 83       	std	Y+4, r25	; 0x04
    3bc2:	8b 83       	std	Y+3, r24	; 0x03
    3bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    3bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    3bc8:	01 97       	sbiw	r24, 0x01	; 1
    3bca:	f1 f7       	brne	.-4      	; 0x3bc8 <headball_ball_task+0x2d0>
    3bcc:	9c 83       	std	Y+4, r25	; 0x04
    3bce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bd0:	8d 81       	ldd	r24, Y+5	; 0x05
    3bd2:	9e 81       	ldd	r25, Y+6	; 0x06
    3bd4:	01 97       	sbiw	r24, 0x01	; 1
    3bd6:	9e 83       	std	Y+6, r25	; 0x06
    3bd8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3bda:	8d 81       	ldd	r24, Y+5	; 0x05
    3bdc:	9e 81       	ldd	r25, Y+6	; 0x06
    3bde:	00 97       	sbiw	r24, 0x00	; 0
    3be0:	69 f7       	brne	.-38     	; 0x3bbc <headball_ball_task+0x2c4>
    3be2:	1a c0       	rjmp	.+52     	; 0x3c18 <headball_ball_task+0x320>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3be4:	6f 81       	ldd	r22, Y+7	; 0x07
    3be6:	78 85       	ldd	r23, Y+8	; 0x08
    3be8:	89 85       	ldd	r24, Y+9	; 0x09
    3bea:	9a 85       	ldd	r25, Y+10	; 0x0a
    3bec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bf0:	dc 01       	movw	r26, r24
    3bf2:	cb 01       	movw	r24, r22
    3bf4:	9e 83       	std	Y+6, r25	; 0x06
    3bf6:	8d 83       	std	Y+5, r24	; 0x05
    3bf8:	8d 81       	ldd	r24, Y+5	; 0x05
    3bfa:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfc:	9a 83       	std	Y+2, r25	; 0x02
    3bfe:	89 83       	std	Y+1, r24	; 0x01
    3c00:	89 81       	ldd	r24, Y+1	; 0x01
    3c02:	9a 81       	ldd	r25, Y+2	; 0x02
    3c04:	01 97       	sbiw	r24, 0x01	; 1
    3c06:	f1 f7       	brne	.-4      	; 0x3c04 <headball_ball_task+0x30c>
    3c08:	9a 83       	std	Y+2, r25	; 0x02
    3c0a:	89 83       	std	Y+1, r24	; 0x01
    3c0c:	05 c0       	rjmp	.+10     	; 0x3c18 <headball_ball_task+0x320>
		_delay_ms(2000);
		break;
	}
	vTaskDelay(100);
    3c0e:	84 e6       	ldi	r24, 0x64	; 100
    3c10:	90 e0       	ldi	r25, 0x00	; 0
    3c12:	0e 94 93 2c 	call	0x5926	; 0x5926 <vTaskDelay>
    3c16:	7e ce       	rjmp	.-772    	; 0x3914 <headball_ball_task+0x1c>
	}
}
    3c18:	60 96       	adiw	r28, 0x10	; 16
    3c1a:	0f b6       	in	r0, 0x3f	; 63
    3c1c:	f8 94       	cli
    3c1e:	de bf       	out	0x3e, r29	; 62
    3c20:	0f be       	out	0x3f, r0	; 63
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	cf 91       	pop	r28
    3c26:	df 91       	pop	r29
    3c28:	08 95       	ret

00003c2a <headball_init>:


void headball_init(void){
    3c2a:	df 93       	push	r29
    3c2c:	cf 93       	push	r28
    3c2e:	cd b7       	in	r28, 0x3d	; 61
    3c30:	de b7       	in	r29, 0x3e	; 62
    3c32:	2e 97       	sbiw	r28, 0x0e	; 14
    3c34:	0f b6       	in	r0, 0x3f	; 63
    3c36:	f8 94       	cli
    3c38:	de bf       	out	0x3e, r29	; 62
    3c3a:	0f be       	out	0x3f, r0	; 63
    3c3c:	cd bf       	out	0x3d, r28	; 61

	/*the goal of the player */
	HLCD_u8GenerateSpecialCharacter(headball_goal_keeping1 , 0);
    3c3e:	89 ef       	ldi	r24, 0xF9	; 249
    3c40:	90 e0       	ldi	r25, 0x00	; 0
    3c42:	60 e0       	ldi	r22, 0x00	; 0
    3c44:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(0,HLCD_u8_LINE_1 , HLCD_u8_Position_0);
    3c48:	80 e0       	ldi	r24, 0x00	; 0
    3c4a:	61 e0       	ldi	r22, 0x01	; 1
    3c4c:	40 e0       	ldi	r20, 0x00	; 0
    3c4e:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
	HLCD_u8GenerateSpecialCharacter(headball_goal_keeping2 , 8);
    3c52:	81 e0       	ldi	r24, 0x01	; 1
    3c54:	91 e0       	ldi	r25, 0x01	; 1
    3c56:	68 e0       	ldi	r22, 0x08	; 8
    3c58:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(1 , HLCD_u8_LINE_2 , HLCD_u8_Position_0);
    3c5c:	81 e0       	ldi	r24, 0x01	; 1
    3c5e:	62 e0       	ldi	r22, 0x02	; 2
    3c60:	40 e0       	ldi	r20, 0x00	; 0
    3c62:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>

	/*the goal of automated player*/
	HLCD_u8GenerateSpecialCharacter(headball_goal_keeping3 , 16);
    3c66:	89 e0       	ldi	r24, 0x09	; 9
    3c68:	91 e0       	ldi	r25, 0x01	; 1
    3c6a:	60 e1       	ldi	r22, 0x10	; 16
    3c6c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(2 , HLCD_u8_LINE_1 , HLCD_u8_Position_15);
    3c70:	82 e0       	ldi	r24, 0x02	; 2
    3c72:	61 e0       	ldi	r22, 0x01	; 1
    3c74:	4f e0       	ldi	r20, 0x0F	; 15
    3c76:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
	HLCD_u8GenerateSpecialCharacter(headball_goal_keeping4 , 24);
    3c7a:	81 e1       	ldi	r24, 0x11	; 17
    3c7c:	91 e0       	ldi	r25, 0x01	; 1
    3c7e:	68 e1       	ldi	r22, 0x18	; 24
    3c80:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(3 , HLCD_u8_LINE_2 , HLCD_u8_Position_15);
    3c84:	83 e0       	ldi	r24, 0x03	; 3
    3c86:	62 e0       	ldi	r22, 0x02	; 2
    3c88:	4f e0       	ldi	r20, 0x0F	; 15
    3c8a:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>

	/* display player 1 with ball*/
	HLCD_u8GenerateSpecialCharacter(headball_palyer_with_ball , 32);
    3c8e:	81 e2       	ldi	r24, 0x21	; 33
    3c90:	91 e0       	ldi	r25, 0x01	; 1
    3c92:	60 e2       	ldi	r22, 0x20	; 32
    3c94:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(4 , HLCD_u8_LINE_2 , HLCD_u8_Position_1);
    3c98:	84 e0       	ldi	r24, 0x04	; 4
    3c9a:	62 e0       	ldi	r22, 0x02	; 2
    3c9c:	41 e0       	ldi	r20, 0x01	; 1
    3c9e:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
	player.x = HLCD_u8_LINE_2;
    3ca2:	82 e0       	ldi	r24, 0x02	; 2
    3ca4:	80 93 2b 07 	sts	0x072B, r24
	player.y = HLCD_u8_Position_1;
    3ca8:	81 e0       	ldi	r24, 0x01	; 1
    3caa:	80 93 2c 07 	sts	0x072C, r24

	/* display automated player without ball */
	HLCD_u8GenerateSpecialCharacter(headball_player , 40);
    3cae:	89 e1       	ldi	r24, 0x19	; 25
    3cb0:	91 e0       	ldi	r25, 0x01	; 1
    3cb2:	68 e2       	ldi	r22, 0x28	; 40
    3cb4:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(5 , HLCD_u8_LINE_2 , HLCD_u8_Position_14);
    3cb8:	85 e0       	ldi	r24, 0x05	; 5
    3cba:	62 e0       	ldi	r22, 0x02	; 2
    3cbc:	4e e0       	ldi	r20, 0x0E	; 14
    3cbe:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
	automated_player.x = HLCD_u8_LINE_2;
    3cc2:	82 e0       	ldi	r24, 0x02	; 2
    3cc4:	80 93 63 07 	sts	0x0763, r24
	automated_player.y = HLCD_u8_Position_14;
    3cc8:	8e e0       	ldi	r24, 0x0E	; 14
    3cca:	80 93 64 07 	sts	0x0764, r24
    3cce:	80 e0       	ldi	r24, 0x00	; 0
    3cd0:	90 e0       	ldi	r25, 0x00	; 0
    3cd2:	aa ef       	ldi	r26, 0xFA	; 250
    3cd4:	b3 e4       	ldi	r27, 0x43	; 67
    3cd6:	8b 87       	std	Y+11, r24	; 0x0b
    3cd8:	9c 87       	std	Y+12, r25	; 0x0c
    3cda:	ad 87       	std	Y+13, r26	; 0x0d
    3cdc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3cde:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ce0:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ce2:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ce4:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ce6:	20 e0       	ldi	r18, 0x00	; 0
    3ce8:	30 e0       	ldi	r19, 0x00	; 0
    3cea:	4a ef       	ldi	r20, 0xFA	; 250
    3cec:	54 e4       	ldi	r21, 0x44	; 68
    3cee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3cf2:	dc 01       	movw	r26, r24
    3cf4:	cb 01       	movw	r24, r22
    3cf6:	8f 83       	std	Y+7, r24	; 0x07
    3cf8:	98 87       	std	Y+8, r25	; 0x08
    3cfa:	a9 87       	std	Y+9, r26	; 0x09
    3cfc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3cfe:	6f 81       	ldd	r22, Y+7	; 0x07
    3d00:	78 85       	ldd	r23, Y+8	; 0x08
    3d02:	89 85       	ldd	r24, Y+9	; 0x09
    3d04:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d06:	20 e0       	ldi	r18, 0x00	; 0
    3d08:	30 e0       	ldi	r19, 0x00	; 0
    3d0a:	40 e8       	ldi	r20, 0x80	; 128
    3d0c:	5f e3       	ldi	r21, 0x3F	; 63
    3d0e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3d12:	88 23       	and	r24, r24
    3d14:	2c f4       	brge	.+10     	; 0x3d20 <headball_init+0xf6>
		__ticks = 1;
    3d16:	81 e0       	ldi	r24, 0x01	; 1
    3d18:	90 e0       	ldi	r25, 0x00	; 0
    3d1a:	9e 83       	std	Y+6, r25	; 0x06
    3d1c:	8d 83       	std	Y+5, r24	; 0x05
    3d1e:	3f c0       	rjmp	.+126    	; 0x3d9e <headball_init+0x174>
	else if (__tmp > 65535)
    3d20:	6f 81       	ldd	r22, Y+7	; 0x07
    3d22:	78 85       	ldd	r23, Y+8	; 0x08
    3d24:	89 85       	ldd	r24, Y+9	; 0x09
    3d26:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d28:	20 e0       	ldi	r18, 0x00	; 0
    3d2a:	3f ef       	ldi	r19, 0xFF	; 255
    3d2c:	4f e7       	ldi	r20, 0x7F	; 127
    3d2e:	57 e4       	ldi	r21, 0x47	; 71
    3d30:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3d34:	18 16       	cp	r1, r24
    3d36:	4c f5       	brge	.+82     	; 0x3d8a <headball_init+0x160>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d38:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d3a:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d40:	20 e0       	ldi	r18, 0x00	; 0
    3d42:	30 e0       	ldi	r19, 0x00	; 0
    3d44:	40 e2       	ldi	r20, 0x20	; 32
    3d46:	51 e4       	ldi	r21, 0x41	; 65
    3d48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d4c:	dc 01       	movw	r26, r24
    3d4e:	cb 01       	movw	r24, r22
    3d50:	bc 01       	movw	r22, r24
    3d52:	cd 01       	movw	r24, r26
    3d54:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d58:	dc 01       	movw	r26, r24
    3d5a:	cb 01       	movw	r24, r22
    3d5c:	9e 83       	std	Y+6, r25	; 0x06
    3d5e:	8d 83       	std	Y+5, r24	; 0x05
    3d60:	0f c0       	rjmp	.+30     	; 0x3d80 <headball_init+0x156>
    3d62:	88 ec       	ldi	r24, 0xC8	; 200
    3d64:	90 e0       	ldi	r25, 0x00	; 0
    3d66:	9c 83       	std	Y+4, r25	; 0x04
    3d68:	8b 83       	std	Y+3, r24	; 0x03
    3d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d6e:	01 97       	sbiw	r24, 0x01	; 1
    3d70:	f1 f7       	brne	.-4      	; 0x3d6e <headball_init+0x144>
    3d72:	9c 83       	std	Y+4, r25	; 0x04
    3d74:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d76:	8d 81       	ldd	r24, Y+5	; 0x05
    3d78:	9e 81       	ldd	r25, Y+6	; 0x06
    3d7a:	01 97       	sbiw	r24, 0x01	; 1
    3d7c:	9e 83       	std	Y+6, r25	; 0x06
    3d7e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d80:	8d 81       	ldd	r24, Y+5	; 0x05
    3d82:	9e 81       	ldd	r25, Y+6	; 0x06
    3d84:	00 97       	sbiw	r24, 0x00	; 0
    3d86:	69 f7       	brne	.-38     	; 0x3d62 <headball_init+0x138>
    3d88:	14 c0       	rjmp	.+40     	; 0x3db2 <headball_init+0x188>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d8a:	6f 81       	ldd	r22, Y+7	; 0x07
    3d8c:	78 85       	ldd	r23, Y+8	; 0x08
    3d8e:	89 85       	ldd	r24, Y+9	; 0x09
    3d90:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d92:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d96:	dc 01       	movw	r26, r24
    3d98:	cb 01       	movw	r24, r22
    3d9a:	9e 83       	std	Y+6, r25	; 0x06
    3d9c:	8d 83       	std	Y+5, r24	; 0x05
    3d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    3da0:	9e 81       	ldd	r25, Y+6	; 0x06
    3da2:	9a 83       	std	Y+2, r25	; 0x02
    3da4:	89 83       	std	Y+1, r24	; 0x01
    3da6:	89 81       	ldd	r24, Y+1	; 0x01
    3da8:	9a 81       	ldd	r25, Y+2	; 0x02
    3daa:	01 97       	sbiw	r24, 0x01	; 1
    3dac:	f1 f7       	brne	.-4      	; 0x3daa <headball_init+0x180>
    3dae:	9a 83       	std	Y+2, r25	; 0x02
    3db0:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(500);
	/* display player 1 with ball*/
	HLCD_u8GenerateSpecialCharacter(headball_player , 32);
    3db2:	89 e1       	ldi	r24, 0x19	; 25
    3db4:	91 e0       	ldi	r25, 0x01	; 1
    3db6:	60 e2       	ldi	r22, 0x20	; 32
    3db8:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <HLCD_u8GenerateSpecialCharacter>
	HLCD_u8DisplaySpecialCharacter(4 , HLCD_u8_LINE_2 , HLCD_u8_Position_1);
    3dbc:	84 e0       	ldi	r24, 0x04	; 4
    3dbe:	62 e0       	ldi	r22, 0x02	; 2
    3dc0:	41 e0       	ldi	r20, 0x01	; 1
    3dc2:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <HLCD_u8DisplaySpecialCharacter>
}
    3dc6:	2e 96       	adiw	r28, 0x0e	; 14
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	f8 94       	cli
    3dcc:	de bf       	out	0x3e, r29	; 62
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	cd bf       	out	0x3d, r28	; 61
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	08 95       	ret

00003dd8 <Get_Pressed>:

/*** end Head Ball game tasks ***/


/* function/s used in all games */
u8 Get_Pressed(void){
    3dd8:	df 93       	push	r29
    3dda:	cf 93       	push	r28
    3ddc:	0f 92       	push	r0
    3dde:	cd b7       	in	r28, 0x3d	; 61
    3de0:	de b7       	in	r29, 0x3e	; 62
	u8 returnedValue;
	while(1){
		/*Get user input */
	  HKPD_u8GetKey(&returnedValue);
    3de2:	ce 01       	movw	r24, r28
    3de4:	01 96       	adiw	r24, 0x01	; 1
    3de6:	0e 94 4f 06 	call	0xc9e	; 0xc9e <HKPD_u8GetKey>
	  if(returnedValue != HKPD_u8_NO_KEY_PRESSED){
    3dea:	89 81       	ldd	r24, Y+1	; 0x01
    3dec:	8f 3f       	cpi	r24, 0xFF	; 255
    3dee:	c9 f3       	breq	.-14     	; 0x3de2 <Get_Pressed+0xa>
		  break;
	  }
	}
	  return returnedValue;
    3df0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3df2:	0f 90       	pop	r0
    3df4:	cf 91       	pop	r28
    3df6:	df 91       	pop	r29
    3df8:	08 95       	ret

00003dfa <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    3dfa:	df 93       	push	r29
    3dfc:	cf 93       	push	r28
    3dfe:	cd b7       	in	r28, 0x3d	; 61
    3e00:	de b7       	in	r29, 0x3e	; 62
    3e02:	27 97       	sbiw	r28, 0x07	; 7
    3e04:	0f b6       	in	r0, 0x3f	; 63
    3e06:	f8 94       	cli
    3e08:	de bf       	out	0x3e, r29	; 62
    3e0a:	0f be       	out	0x3f, r0	; 63
    3e0c:	cd bf       	out	0x3d, r28	; 61
    3e0e:	9d 83       	std	Y+5, r25	; 0x05
    3e10:	8c 83       	std	Y+4, r24	; 0x04
    3e12:	6e 83       	std	Y+6, r22	; 0x06
    3e14:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3e16:	8a e1       	ldi	r24, 0x1A	; 26
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	0e 94 d5 21 	call	0x43aa	; 0x43aa <pvPortMalloc>
    3e1e:	9a 83       	std	Y+2, r25	; 0x02
    3e20:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    3e22:	89 81       	ldd	r24, Y+1	; 0x01
    3e24:	9a 81       	ldd	r25, Y+2	; 0x02
    3e26:	00 97       	sbiw	r24, 0x00	; 0
    3e28:	09 f4       	brne	.+2      	; 0x3e2c <xCoRoutineCreate+0x32>
    3e2a:	6f c0       	rjmp	.+222    	; 0x3f0a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    3e2c:	80 91 4f 01 	lds	r24, 0x014F
    3e30:	90 91 50 01 	lds	r25, 0x0150
    3e34:	00 97       	sbiw	r24, 0x00	; 0
    3e36:	41 f4       	brne	.+16     	; 0x3e48 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    3e38:	89 81       	ldd	r24, Y+1	; 0x01
    3e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3c:	90 93 50 01 	sts	0x0150, r25
    3e40:	80 93 4f 01 	sts	0x014F, r24
			prvInitialiseCoRoutineLists();
    3e44:	0e 94 64 21 	call	0x42c8	; 0x42c8 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    3e48:	8e 81       	ldd	r24, Y+6	; 0x06
    3e4a:	82 30       	cpi	r24, 0x02	; 2
    3e4c:	10 f0       	brcs	.+4      	; 0x3e52 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    3e4e:	81 e0       	ldi	r24, 0x01	; 1
    3e50:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    3e52:	e9 81       	ldd	r30, Y+1	; 0x01
    3e54:	fa 81       	ldd	r31, Y+2	; 0x02
    3e56:	11 8e       	std	Z+25, r1	; 0x19
    3e58:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    3e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e5e:	8e 81       	ldd	r24, Y+6	; 0x06
    3e60:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    3e62:	e9 81       	ldd	r30, Y+1	; 0x01
    3e64:	fa 81       	ldd	r31, Y+2	; 0x02
    3e66:	8f 81       	ldd	r24, Y+7	; 0x07
    3e68:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    3e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e6e:	8c 81       	ldd	r24, Y+4	; 0x04
    3e70:	9d 81       	ldd	r25, Y+5	; 0x05
    3e72:	91 83       	std	Z+1, r25	; 0x01
    3e74:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    3e76:	89 81       	ldd	r24, Y+1	; 0x01
    3e78:	9a 81       	ldd	r25, Y+2	; 0x02
    3e7a:	02 96       	adiw	r24, 0x02	; 2
    3e7c:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    3e80:	89 81       	ldd	r24, Y+1	; 0x01
    3e82:	9a 81       	ldd	r25, Y+2	; 0x02
    3e84:	0c 96       	adiw	r24, 0x0c	; 12
    3e86:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    3e8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e8e:	89 81       	ldd	r24, Y+1	; 0x01
    3e90:	9a 81       	ldd	r25, Y+2	; 0x02
    3e92:	91 87       	std	Z+9, r25	; 0x09
    3e94:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3e96:	e9 81       	ldd	r30, Y+1	; 0x01
    3e98:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9a:	89 81       	ldd	r24, Y+1	; 0x01
    3e9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e9e:	93 8b       	std	Z+19, r25	; 0x13
    3ea0:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3ea2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ea4:	28 2f       	mov	r18, r24
    3ea6:	30 e0       	ldi	r19, 0x00	; 0
    3ea8:	86 e0       	ldi	r24, 0x06	; 6
    3eaa:	90 e0       	ldi	r25, 0x00	; 0
    3eac:	82 1b       	sub	r24, r18
    3eae:	93 0b       	sbc	r25, r19
    3eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb4:	95 87       	std	Z+13, r25	; 0x0d
    3eb6:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    3eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eba:	fa 81       	ldd	r31, Y+2	; 0x02
    3ebc:	96 89       	ldd	r25, Z+22	; 0x16
    3ebe:	80 91 51 01 	lds	r24, 0x0151
    3ec2:	89 17       	cp	r24, r25
    3ec4:	28 f4       	brcc	.+10     	; 0x3ed0 <xCoRoutineCreate+0xd6>
    3ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    3eca:	86 89       	ldd	r24, Z+22	; 0x16
    3ecc:	80 93 51 01 	sts	0x0151, r24
    3ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed4:	86 89       	ldd	r24, Z+22	; 0x16
    3ed6:	28 2f       	mov	r18, r24
    3ed8:	30 e0       	ldi	r19, 0x00	; 0
    3eda:	c9 01       	movw	r24, r18
    3edc:	88 0f       	add	r24, r24
    3ede:	99 1f       	adc	r25, r25
    3ee0:	88 0f       	add	r24, r24
    3ee2:	99 1f       	adc	r25, r25
    3ee4:	88 0f       	add	r24, r24
    3ee6:	99 1f       	adc	r25, r25
    3ee8:	82 0f       	add	r24, r18
    3eea:	93 1f       	adc	r25, r19
    3eec:	ac 01       	movw	r20, r24
    3eee:	48 5a       	subi	r20, 0xA8	; 168
    3ef0:	5e 4f       	sbci	r21, 0xFE	; 254
    3ef2:	89 81       	ldd	r24, Y+1	; 0x01
    3ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef6:	9c 01       	movw	r18, r24
    3ef8:	2e 5f       	subi	r18, 0xFE	; 254
    3efa:	3f 4f       	sbci	r19, 0xFF	; 255
    3efc:	ca 01       	movw	r24, r20
    3efe:	b9 01       	movw	r22, r18
    3f00:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>

		xReturn = pdPASS;
    3f04:	81 e0       	ldi	r24, 0x01	; 1
    3f06:	8b 83       	std	Y+3, r24	; 0x03
    3f08:	02 c0       	rjmp	.+4      	; 0x3f0e <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3f0a:	8f ef       	ldi	r24, 0xFF	; 255
    3f0c:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    3f0e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3f10:	27 96       	adiw	r28, 0x07	; 7
    3f12:	0f b6       	in	r0, 0x3f	; 63
    3f14:	f8 94       	cli
    3f16:	de bf       	out	0x3e, r29	; 62
    3f18:	0f be       	out	0x3f, r0	; 63
    3f1a:	cd bf       	out	0x3d, r28	; 61
    3f1c:	cf 91       	pop	r28
    3f1e:	df 91       	pop	r29
    3f20:	08 95       	ret

00003f22 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    3f22:	df 93       	push	r29
    3f24:	cf 93       	push	r28
    3f26:	00 d0       	rcall	.+0      	; 0x3f28 <vCoRoutineAddToDelayedList+0x6>
    3f28:	00 d0       	rcall	.+0      	; 0x3f2a <vCoRoutineAddToDelayedList+0x8>
    3f2a:	00 d0       	rcall	.+0      	; 0x3f2c <vCoRoutineAddToDelayedList+0xa>
    3f2c:	cd b7       	in	r28, 0x3d	; 61
    3f2e:	de b7       	in	r29, 0x3e	; 62
    3f30:	9c 83       	std	Y+4, r25	; 0x04
    3f32:	8b 83       	std	Y+3, r24	; 0x03
    3f34:	7e 83       	std	Y+6, r23	; 0x06
    3f36:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    3f38:	20 91 52 01 	lds	r18, 0x0152
    3f3c:	30 91 53 01 	lds	r19, 0x0153
    3f40:	8b 81       	ldd	r24, Y+3	; 0x03
    3f42:	9c 81       	ldd	r25, Y+4	; 0x04
    3f44:	82 0f       	add	r24, r18
    3f46:	93 1f       	adc	r25, r19
    3f48:	9a 83       	std	Y+2, r25	; 0x02
    3f4a:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3f4c:	80 91 4f 01 	lds	r24, 0x014F
    3f50:	90 91 50 01 	lds	r25, 0x0150
    3f54:	02 96       	adiw	r24, 0x02	; 2
    3f56:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    3f5a:	e0 91 4f 01 	lds	r30, 0x014F
    3f5e:	f0 91 50 01 	lds	r31, 0x0150
    3f62:	89 81       	ldd	r24, Y+1	; 0x01
    3f64:	9a 81       	ldd	r25, Y+2	; 0x02
    3f66:	93 83       	std	Z+3, r25	; 0x03
    3f68:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    3f6a:	20 91 52 01 	lds	r18, 0x0152
    3f6e:	30 91 53 01 	lds	r19, 0x0153
    3f72:	89 81       	ldd	r24, Y+1	; 0x01
    3f74:	9a 81       	ldd	r25, Y+2	; 0x02
    3f76:	82 17       	cp	r24, r18
    3f78:	93 07       	cpc	r25, r19
    3f7a:	70 f4       	brcc	.+28     	; 0x3f98 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3f7c:	80 91 7e 01 	lds	r24, 0x017E
    3f80:	90 91 7f 01 	lds	r25, 0x017F
    3f84:	20 91 4f 01 	lds	r18, 0x014F
    3f88:	30 91 50 01 	lds	r19, 0x0150
    3f8c:	2e 5f       	subi	r18, 0xFE	; 254
    3f8e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f90:	b9 01       	movw	r22, r18
    3f92:	0e 94 c7 22 	call	0x458e	; 0x458e <vListInsert>
    3f96:	0d c0       	rjmp	.+26     	; 0x3fb2 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3f98:	80 91 7c 01 	lds	r24, 0x017C
    3f9c:	90 91 7d 01 	lds	r25, 0x017D
    3fa0:	20 91 4f 01 	lds	r18, 0x014F
    3fa4:	30 91 50 01 	lds	r19, 0x0150
    3fa8:	2e 5f       	subi	r18, 0xFE	; 254
    3faa:	3f 4f       	sbci	r19, 0xFF	; 255
    3fac:	b9 01       	movw	r22, r18
    3fae:	0e 94 c7 22 	call	0x458e	; 0x458e <vListInsert>
	}

	if( pxEventList )
    3fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    3fb4:	9e 81       	ldd	r25, Y+6	; 0x06
    3fb6:	00 97       	sbiw	r24, 0x00	; 0
    3fb8:	61 f0       	breq	.+24     	; 0x3fd2 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    3fba:	80 91 4f 01 	lds	r24, 0x014F
    3fbe:	90 91 50 01 	lds	r25, 0x0150
    3fc2:	9c 01       	movw	r18, r24
    3fc4:	24 5f       	subi	r18, 0xF4	; 244
    3fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    3fca:	9e 81       	ldd	r25, Y+6	; 0x06
    3fcc:	b9 01       	movw	r22, r18
    3fce:	0e 94 c7 22 	call	0x458e	; 0x458e <vListInsert>
	}
}
    3fd2:	26 96       	adiw	r28, 0x06	; 6
    3fd4:	0f b6       	in	r0, 0x3f	; 63
    3fd6:	f8 94       	cli
    3fd8:	de bf       	out	0x3e, r29	; 62
    3fda:	0f be       	out	0x3f, r0	; 63
    3fdc:	cd bf       	out	0x3d, r28	; 61
    3fde:	cf 91       	pop	r28
    3fe0:	df 91       	pop	r29
    3fe2:	08 95       	ret

00003fe4 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    3fe4:	df 93       	push	r29
    3fe6:	cf 93       	push	r28
    3fe8:	00 d0       	rcall	.+0      	; 0x3fea <prvCheckPendingReadyList+0x6>
    3fea:	cd b7       	in	r28, 0x3d	; 61
    3fec:	de b7       	in	r29, 0x3e	; 62
    3fee:	3a c0       	rjmp	.+116    	; 0x4064 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    3ff0:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    3ff2:	e0 91 85 01 	lds	r30, 0x0185
    3ff6:	f0 91 86 01 	lds	r31, 0x0186
    3ffa:	86 81       	ldd	r24, Z+6	; 0x06
    3ffc:	97 81       	ldd	r25, Z+7	; 0x07
    3ffe:	9a 83       	std	Y+2, r25	; 0x02
    4000:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4002:	89 81       	ldd	r24, Y+1	; 0x01
    4004:	9a 81       	ldd	r25, Y+2	; 0x02
    4006:	0c 96       	adiw	r24, 0x0c	; 12
    4008:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    400c:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    400e:	89 81       	ldd	r24, Y+1	; 0x01
    4010:	9a 81       	ldd	r25, Y+2	; 0x02
    4012:	02 96       	adiw	r24, 0x02	; 2
    4014:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4018:	e9 81       	ldd	r30, Y+1	; 0x01
    401a:	fa 81       	ldd	r31, Y+2	; 0x02
    401c:	96 89       	ldd	r25, Z+22	; 0x16
    401e:	80 91 51 01 	lds	r24, 0x0151
    4022:	89 17       	cp	r24, r25
    4024:	28 f4       	brcc	.+10     	; 0x4030 <prvCheckPendingReadyList+0x4c>
    4026:	e9 81       	ldd	r30, Y+1	; 0x01
    4028:	fa 81       	ldd	r31, Y+2	; 0x02
    402a:	86 89       	ldd	r24, Z+22	; 0x16
    402c:	80 93 51 01 	sts	0x0151, r24
    4030:	e9 81       	ldd	r30, Y+1	; 0x01
    4032:	fa 81       	ldd	r31, Y+2	; 0x02
    4034:	86 89       	ldd	r24, Z+22	; 0x16
    4036:	28 2f       	mov	r18, r24
    4038:	30 e0       	ldi	r19, 0x00	; 0
    403a:	c9 01       	movw	r24, r18
    403c:	88 0f       	add	r24, r24
    403e:	99 1f       	adc	r25, r25
    4040:	88 0f       	add	r24, r24
    4042:	99 1f       	adc	r25, r25
    4044:	88 0f       	add	r24, r24
    4046:	99 1f       	adc	r25, r25
    4048:	82 0f       	add	r24, r18
    404a:	93 1f       	adc	r25, r19
    404c:	ac 01       	movw	r20, r24
    404e:	48 5a       	subi	r20, 0xA8	; 168
    4050:	5e 4f       	sbci	r21, 0xFE	; 254
    4052:	89 81       	ldd	r24, Y+1	; 0x01
    4054:	9a 81       	ldd	r25, Y+2	; 0x02
    4056:	9c 01       	movw	r18, r24
    4058:	2e 5f       	subi	r18, 0xFE	; 254
    405a:	3f 4f       	sbci	r19, 0xFF	; 255
    405c:	ca 01       	movw	r24, r20
    405e:	b9 01       	movw	r22, r18
    4060:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4064:	80 91 80 01 	lds	r24, 0x0180
    4068:	88 23       	and	r24, r24
    406a:	09 f0       	breq	.+2      	; 0x406e <prvCheckPendingReadyList+0x8a>
    406c:	c1 cf       	rjmp	.-126    	; 0x3ff0 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    406e:	0f 90       	pop	r0
    4070:	0f 90       	pop	r0
    4072:	cf 91       	pop	r28
    4074:	df 91       	pop	r29
    4076:	08 95       	ret

00004078 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    4078:	df 93       	push	r29
    407a:	cf 93       	push	r28
    407c:	00 d0       	rcall	.+0      	; 0x407e <prvCheckDelayedList+0x6>
    407e:	00 d0       	rcall	.+0      	; 0x4080 <prvCheckDelayedList+0x8>
    4080:	cd b7       	in	r28, 0x3d	; 61
    4082:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    4084:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <xTaskGetTickCount>
    4088:	20 91 54 01 	lds	r18, 0x0154
    408c:	30 91 55 01 	lds	r19, 0x0155
    4090:	82 1b       	sub	r24, r18
    4092:	93 0b       	sbc	r25, r19
    4094:	90 93 57 01 	sts	0x0157, r25
    4098:	80 93 56 01 	sts	0x0156, r24
    409c:	85 c0       	rjmp	.+266    	; 0x41a8 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    409e:	80 91 52 01 	lds	r24, 0x0152
    40a2:	90 91 53 01 	lds	r25, 0x0153
    40a6:	01 96       	adiw	r24, 0x01	; 1
    40a8:	90 93 53 01 	sts	0x0153, r25
    40ac:	80 93 52 01 	sts	0x0152, r24
		xPassedTicks--;
    40b0:	80 91 56 01 	lds	r24, 0x0156
    40b4:	90 91 57 01 	lds	r25, 0x0157
    40b8:	01 97       	sbiw	r24, 0x01	; 1
    40ba:	90 93 57 01 	sts	0x0157, r25
    40be:	80 93 56 01 	sts	0x0156, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    40c2:	80 91 52 01 	lds	r24, 0x0152
    40c6:	90 91 53 01 	lds	r25, 0x0153
    40ca:	00 97       	sbiw	r24, 0x00	; 0
    40cc:	09 f0       	breq	.+2      	; 0x40d0 <prvCheckDelayedList+0x58>
    40ce:	64 c0       	rjmp	.+200    	; 0x4198 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    40d0:	80 91 7c 01 	lds	r24, 0x017C
    40d4:	90 91 7d 01 	lds	r25, 0x017D
    40d8:	9a 83       	std	Y+2, r25	; 0x02
    40da:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    40dc:	80 91 7e 01 	lds	r24, 0x017E
    40e0:	90 91 7f 01 	lds	r25, 0x017F
    40e4:	90 93 7d 01 	sts	0x017D, r25
    40e8:	80 93 7c 01 	sts	0x017C, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    40ec:	89 81       	ldd	r24, Y+1	; 0x01
    40ee:	9a 81       	ldd	r25, Y+2	; 0x02
    40f0:	90 93 7f 01 	sts	0x017F, r25
    40f4:	80 93 7e 01 	sts	0x017E, r24
    40f8:	4f c0       	rjmp	.+158    	; 0x4198 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    40fa:	e0 91 7c 01 	lds	r30, 0x017C
    40fe:	f0 91 7d 01 	lds	r31, 0x017D
    4102:	05 80       	ldd	r0, Z+5	; 0x05
    4104:	f6 81       	ldd	r31, Z+6	; 0x06
    4106:	e0 2d       	mov	r30, r0
    4108:	86 81       	ldd	r24, Z+6	; 0x06
    410a:	97 81       	ldd	r25, Z+7	; 0x07
    410c:	9c 83       	std	Y+4, r25	; 0x04
    410e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    4110:	eb 81       	ldd	r30, Y+3	; 0x03
    4112:	fc 81       	ldd	r31, Y+4	; 0x04
    4114:	22 81       	ldd	r18, Z+2	; 0x02
    4116:	33 81       	ldd	r19, Z+3	; 0x03
    4118:	80 91 52 01 	lds	r24, 0x0152
    411c:	90 91 53 01 	lds	r25, 0x0153
    4120:	82 17       	cp	r24, r18
    4122:	93 07       	cpc	r25, r19
    4124:	08 f4       	brcc	.+2      	; 0x4128 <prvCheckDelayedList+0xb0>
    4126:	40 c0       	rjmp	.+128    	; 0x41a8 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4128:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    412a:	8b 81       	ldd	r24, Y+3	; 0x03
    412c:	9c 81       	ldd	r25, Y+4	; 0x04
    412e:	02 96       	adiw	r24, 0x02	; 2
    4130:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4134:	eb 81       	ldd	r30, Y+3	; 0x03
    4136:	fc 81       	ldd	r31, Y+4	; 0x04
    4138:	84 89       	ldd	r24, Z+20	; 0x14
    413a:	95 89       	ldd	r25, Z+21	; 0x15
    413c:	00 97       	sbiw	r24, 0x00	; 0
    413e:	29 f0       	breq	.+10     	; 0x414a <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    4140:	8b 81       	ldd	r24, Y+3	; 0x03
    4142:	9c 81       	ldd	r25, Y+4	; 0x04
    4144:	0c 96       	adiw	r24, 0x0c	; 12
    4146:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    414a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    414c:	eb 81       	ldd	r30, Y+3	; 0x03
    414e:	fc 81       	ldd	r31, Y+4	; 0x04
    4150:	96 89       	ldd	r25, Z+22	; 0x16
    4152:	80 91 51 01 	lds	r24, 0x0151
    4156:	89 17       	cp	r24, r25
    4158:	28 f4       	brcc	.+10     	; 0x4164 <prvCheckDelayedList+0xec>
    415a:	eb 81       	ldd	r30, Y+3	; 0x03
    415c:	fc 81       	ldd	r31, Y+4	; 0x04
    415e:	86 89       	ldd	r24, Z+22	; 0x16
    4160:	80 93 51 01 	sts	0x0151, r24
    4164:	eb 81       	ldd	r30, Y+3	; 0x03
    4166:	fc 81       	ldd	r31, Y+4	; 0x04
    4168:	86 89       	ldd	r24, Z+22	; 0x16
    416a:	28 2f       	mov	r18, r24
    416c:	30 e0       	ldi	r19, 0x00	; 0
    416e:	c9 01       	movw	r24, r18
    4170:	88 0f       	add	r24, r24
    4172:	99 1f       	adc	r25, r25
    4174:	88 0f       	add	r24, r24
    4176:	99 1f       	adc	r25, r25
    4178:	88 0f       	add	r24, r24
    417a:	99 1f       	adc	r25, r25
    417c:	82 0f       	add	r24, r18
    417e:	93 1f       	adc	r25, r19
    4180:	ac 01       	movw	r20, r24
    4182:	48 5a       	subi	r20, 0xA8	; 168
    4184:	5e 4f       	sbci	r21, 0xFE	; 254
    4186:	8b 81       	ldd	r24, Y+3	; 0x03
    4188:	9c 81       	ldd	r25, Y+4	; 0x04
    418a:	9c 01       	movw	r18, r24
    418c:	2e 5f       	subi	r18, 0xFE	; 254
    418e:	3f 4f       	sbci	r19, 0xFF	; 255
    4190:	ca 01       	movw	r24, r20
    4192:	b9 01       	movw	r22, r18
    4194:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4198:	e0 91 7c 01 	lds	r30, 0x017C
    419c:	f0 91 7d 01 	lds	r31, 0x017D
    41a0:	80 81       	ld	r24, Z
    41a2:	88 23       	and	r24, r24
    41a4:	09 f0       	breq	.+2      	; 0x41a8 <prvCheckDelayedList+0x130>
    41a6:	a9 cf       	rjmp	.-174    	; 0x40fa <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    41a8:	80 91 56 01 	lds	r24, 0x0156
    41ac:	90 91 57 01 	lds	r25, 0x0157
    41b0:	00 97       	sbiw	r24, 0x00	; 0
    41b2:	09 f0       	breq	.+2      	; 0x41b6 <prvCheckDelayedList+0x13e>
    41b4:	74 cf       	rjmp	.-280    	; 0x409e <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    41b6:	80 91 52 01 	lds	r24, 0x0152
    41ba:	90 91 53 01 	lds	r25, 0x0153
    41be:	90 93 55 01 	sts	0x0155, r25
    41c2:	80 93 54 01 	sts	0x0154, r24
}
    41c6:	0f 90       	pop	r0
    41c8:	0f 90       	pop	r0
    41ca:	0f 90       	pop	r0
    41cc:	0f 90       	pop	r0
    41ce:	cf 91       	pop	r28
    41d0:	df 91       	pop	r29
    41d2:	08 95       	ret

000041d4 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    41d4:	df 93       	push	r29
    41d6:	cf 93       	push	r28
    41d8:	00 d0       	rcall	.+0      	; 0x41da <vCoRoutineSchedule+0x6>
    41da:	cd b7       	in	r28, 0x3d	; 61
    41dc:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    41de:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    41e2:	0e 94 3c 20 	call	0x4078	; 0x4078 <prvCheckDelayedList>
    41e6:	0a c0       	rjmp	.+20     	; 0x41fc <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    41e8:	80 91 51 01 	lds	r24, 0x0151
    41ec:	88 23       	and	r24, r24
    41ee:	09 f4       	brne	.+2      	; 0x41f2 <vCoRoutineSchedule+0x1e>
    41f0:	66 c0       	rjmp	.+204    	; 0x42be <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    41f2:	80 91 51 01 	lds	r24, 0x0151
    41f6:	81 50       	subi	r24, 0x01	; 1
    41f8:	80 93 51 01 	sts	0x0151, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    41fc:	80 91 51 01 	lds	r24, 0x0151
    4200:	28 2f       	mov	r18, r24
    4202:	30 e0       	ldi	r19, 0x00	; 0
    4204:	c9 01       	movw	r24, r18
    4206:	88 0f       	add	r24, r24
    4208:	99 1f       	adc	r25, r25
    420a:	88 0f       	add	r24, r24
    420c:	99 1f       	adc	r25, r25
    420e:	88 0f       	add	r24, r24
    4210:	99 1f       	adc	r25, r25
    4212:	82 0f       	add	r24, r18
    4214:	93 1f       	adc	r25, r19
    4216:	fc 01       	movw	r30, r24
    4218:	e8 5a       	subi	r30, 0xA8	; 168
    421a:	fe 4f       	sbci	r31, 0xFE	; 254
    421c:	80 81       	ld	r24, Z
    421e:	88 23       	and	r24, r24
    4220:	19 f3       	breq	.-58     	; 0x41e8 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    4222:	80 91 51 01 	lds	r24, 0x0151
    4226:	28 2f       	mov	r18, r24
    4228:	30 e0       	ldi	r19, 0x00	; 0
    422a:	c9 01       	movw	r24, r18
    422c:	88 0f       	add	r24, r24
    422e:	99 1f       	adc	r25, r25
    4230:	88 0f       	add	r24, r24
    4232:	99 1f       	adc	r25, r25
    4234:	88 0f       	add	r24, r24
    4236:	99 1f       	adc	r25, r25
    4238:	82 0f       	add	r24, r18
    423a:	93 1f       	adc	r25, r19
    423c:	88 5a       	subi	r24, 0xA8	; 168
    423e:	9e 4f       	sbci	r25, 0xFE	; 254
    4240:	9a 83       	std	Y+2, r25	; 0x02
    4242:	89 83       	std	Y+1, r24	; 0x01
    4244:	e9 81       	ldd	r30, Y+1	; 0x01
    4246:	fa 81       	ldd	r31, Y+2	; 0x02
    4248:	01 80       	ldd	r0, Z+1	; 0x01
    424a:	f2 81       	ldd	r31, Z+2	; 0x02
    424c:	e0 2d       	mov	r30, r0
    424e:	82 81       	ldd	r24, Z+2	; 0x02
    4250:	93 81       	ldd	r25, Z+3	; 0x03
    4252:	e9 81       	ldd	r30, Y+1	; 0x01
    4254:	fa 81       	ldd	r31, Y+2	; 0x02
    4256:	92 83       	std	Z+2, r25	; 0x02
    4258:	81 83       	std	Z+1, r24	; 0x01
    425a:	e9 81       	ldd	r30, Y+1	; 0x01
    425c:	fa 81       	ldd	r31, Y+2	; 0x02
    425e:	21 81       	ldd	r18, Z+1	; 0x01
    4260:	32 81       	ldd	r19, Z+2	; 0x02
    4262:	89 81       	ldd	r24, Y+1	; 0x01
    4264:	9a 81       	ldd	r25, Y+2	; 0x02
    4266:	03 96       	adiw	r24, 0x03	; 3
    4268:	28 17       	cp	r18, r24
    426a:	39 07       	cpc	r19, r25
    426c:	59 f4       	brne	.+22     	; 0x4284 <vCoRoutineSchedule+0xb0>
    426e:	e9 81       	ldd	r30, Y+1	; 0x01
    4270:	fa 81       	ldd	r31, Y+2	; 0x02
    4272:	01 80       	ldd	r0, Z+1	; 0x01
    4274:	f2 81       	ldd	r31, Z+2	; 0x02
    4276:	e0 2d       	mov	r30, r0
    4278:	82 81       	ldd	r24, Z+2	; 0x02
    427a:	93 81       	ldd	r25, Z+3	; 0x03
    427c:	e9 81       	ldd	r30, Y+1	; 0x01
    427e:	fa 81       	ldd	r31, Y+2	; 0x02
    4280:	92 83       	std	Z+2, r25	; 0x02
    4282:	81 83       	std	Z+1, r24	; 0x01
    4284:	e9 81       	ldd	r30, Y+1	; 0x01
    4286:	fa 81       	ldd	r31, Y+2	; 0x02
    4288:	01 80       	ldd	r0, Z+1	; 0x01
    428a:	f2 81       	ldd	r31, Z+2	; 0x02
    428c:	e0 2d       	mov	r30, r0
    428e:	86 81       	ldd	r24, Z+6	; 0x06
    4290:	97 81       	ldd	r25, Z+7	; 0x07
    4292:	90 93 50 01 	sts	0x0150, r25
    4296:	80 93 4f 01 	sts	0x014F, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    429a:	e0 91 4f 01 	lds	r30, 0x014F
    429e:	f0 91 50 01 	lds	r31, 0x0150
    42a2:	40 81       	ld	r20, Z
    42a4:	51 81       	ldd	r21, Z+1	; 0x01
    42a6:	80 91 4f 01 	lds	r24, 0x014F
    42aa:	90 91 50 01 	lds	r25, 0x0150
    42ae:	e0 91 4f 01 	lds	r30, 0x014F
    42b2:	f0 91 50 01 	lds	r31, 0x0150
    42b6:	27 89       	ldd	r18, Z+23	; 0x17
    42b8:	62 2f       	mov	r22, r18
    42ba:	fa 01       	movw	r30, r20
    42bc:	09 95       	icall

	return;
}
    42be:	0f 90       	pop	r0
    42c0:	0f 90       	pop	r0
    42c2:	cf 91       	pop	r28
    42c4:	df 91       	pop	r29
    42c6:	08 95       	ret

000042c8 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    42c8:	df 93       	push	r29
    42ca:	cf 93       	push	r28
    42cc:	0f 92       	push	r0
    42ce:	cd b7       	in	r28, 0x3d	; 61
    42d0:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    42d2:	19 82       	std	Y+1, r1	; 0x01
    42d4:	13 c0       	rjmp	.+38     	; 0x42fc <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    42d6:	89 81       	ldd	r24, Y+1	; 0x01
    42d8:	28 2f       	mov	r18, r24
    42da:	30 e0       	ldi	r19, 0x00	; 0
    42dc:	c9 01       	movw	r24, r18
    42de:	88 0f       	add	r24, r24
    42e0:	99 1f       	adc	r25, r25
    42e2:	88 0f       	add	r24, r24
    42e4:	99 1f       	adc	r25, r25
    42e6:	88 0f       	add	r24, r24
    42e8:	99 1f       	adc	r25, r25
    42ea:	82 0f       	add	r24, r18
    42ec:	93 1f       	adc	r25, r19
    42ee:	88 5a       	subi	r24, 0xA8	; 168
    42f0:	9e 4f       	sbci	r25, 0xFE	; 254
    42f2:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    42f6:	89 81       	ldd	r24, Y+1	; 0x01
    42f8:	8f 5f       	subi	r24, 0xFF	; 255
    42fa:	89 83       	std	Y+1, r24	; 0x01
    42fc:	89 81       	ldd	r24, Y+1	; 0x01
    42fe:	82 30       	cpi	r24, 0x02	; 2
    4300:	50 f3       	brcs	.-44     	; 0x42d6 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    4302:	8a e6       	ldi	r24, 0x6A	; 106
    4304:	91 e0       	ldi	r25, 0x01	; 1
    4306:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    430a:	83 e7       	ldi	r24, 0x73	; 115
    430c:	91 e0       	ldi	r25, 0x01	; 1
    430e:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    4312:	80 e8       	ldi	r24, 0x80	; 128
    4314:	91 e0       	ldi	r25, 0x01	; 1
    4316:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    431a:	8a e6       	ldi	r24, 0x6A	; 106
    431c:	91 e0       	ldi	r25, 0x01	; 1
    431e:	90 93 7d 01 	sts	0x017D, r25
    4322:	80 93 7c 01 	sts	0x017C, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    4326:	83 e7       	ldi	r24, 0x73	; 115
    4328:	91 e0       	ldi	r25, 0x01	; 1
    432a:	90 93 7f 01 	sts	0x017F, r25
    432e:	80 93 7e 01 	sts	0x017E, r24
}
    4332:	0f 90       	pop	r0
    4334:	cf 91       	pop	r28
    4336:	df 91       	pop	r29
    4338:	08 95       	ret

0000433a <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    433a:	df 93       	push	r29
    433c:	cf 93       	push	r28
    433e:	00 d0       	rcall	.+0      	; 0x4340 <xCoRoutineRemoveFromEventList+0x6>
    4340:	00 d0       	rcall	.+0      	; 0x4342 <xCoRoutineRemoveFromEventList+0x8>
    4342:	0f 92       	push	r0
    4344:	cd b7       	in	r28, 0x3d	; 61
    4346:	de b7       	in	r29, 0x3e	; 62
    4348:	9d 83       	std	Y+5, r25	; 0x05
    434a:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    434c:	ec 81       	ldd	r30, Y+4	; 0x04
    434e:	fd 81       	ldd	r31, Y+5	; 0x05
    4350:	05 80       	ldd	r0, Z+5	; 0x05
    4352:	f6 81       	ldd	r31, Z+6	; 0x06
    4354:	e0 2d       	mov	r30, r0
    4356:	86 81       	ldd	r24, Z+6	; 0x06
    4358:	97 81       	ldd	r25, Z+7	; 0x07
    435a:	9b 83       	std	Y+3, r25	; 0x03
    435c:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    435e:	8a 81       	ldd	r24, Y+2	; 0x02
    4360:	9b 81       	ldd	r25, Y+3	; 0x03
    4362:	0c 96       	adiw	r24, 0x0c	; 12
    4364:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    4368:	8a 81       	ldd	r24, Y+2	; 0x02
    436a:	9b 81       	ldd	r25, Y+3	; 0x03
    436c:	9c 01       	movw	r18, r24
    436e:	24 5f       	subi	r18, 0xF4	; 244
    4370:	3f 4f       	sbci	r19, 0xFF	; 255
    4372:	80 e8       	ldi	r24, 0x80	; 128
    4374:	91 e0       	ldi	r25, 0x01	; 1
    4376:	b9 01       	movw	r22, r18
    4378:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    437c:	ea 81       	ldd	r30, Y+2	; 0x02
    437e:	fb 81       	ldd	r31, Y+3	; 0x03
    4380:	96 89       	ldd	r25, Z+22	; 0x16
    4382:	e0 91 4f 01 	lds	r30, 0x014F
    4386:	f0 91 50 01 	lds	r31, 0x0150
    438a:	86 89       	ldd	r24, Z+22	; 0x16
    438c:	98 17       	cp	r25, r24
    438e:	18 f0       	brcs	.+6      	; 0x4396 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    4390:	81 e0       	ldi	r24, 0x01	; 1
    4392:	89 83       	std	Y+1, r24	; 0x01
    4394:	01 c0       	rjmp	.+2      	; 0x4398 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    4396:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4398:	89 81       	ldd	r24, Y+1	; 0x01
}
    439a:	0f 90       	pop	r0
    439c:	0f 90       	pop	r0
    439e:	0f 90       	pop	r0
    43a0:	0f 90       	pop	r0
    43a2:	0f 90       	pop	r0
    43a4:	cf 91       	pop	r28
    43a6:	df 91       	pop	r29
    43a8:	08 95       	ret

000043aa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    43aa:	df 93       	push	r29
    43ac:	cf 93       	push	r28
    43ae:	00 d0       	rcall	.+0      	; 0x43b0 <pvPortMalloc+0x6>
    43b0:	00 d0       	rcall	.+0      	; 0x43b2 <pvPortMalloc+0x8>
    43b2:	cd b7       	in	r28, 0x3d	; 61
    43b4:	de b7       	in	r29, 0x3e	; 62
    43b6:	9c 83       	std	Y+4, r25	; 0x04
    43b8:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    43ba:	1a 82       	std	Y+2, r1	; 0x02
    43bc:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    43be:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    43c2:	80 91 89 01 	lds	r24, 0x0189
    43c6:	90 91 8a 01 	lds	r25, 0x018A
    43ca:	2b 81       	ldd	r18, Y+3	; 0x03
    43cc:	3c 81       	ldd	r19, Y+4	; 0x04
    43ce:	82 0f       	add	r24, r18
    43d0:	93 1f       	adc	r25, r19
    43d2:	25 e0       	ldi	r18, 0x05	; 5
    43d4:	84 31       	cpi	r24, 0x14	; 20
    43d6:	92 07       	cpc	r25, r18
    43d8:	18 f5       	brcc	.+70     	; 0x4420 <pvPortMalloc+0x76>
    43da:	20 91 89 01 	lds	r18, 0x0189
    43de:	30 91 8a 01 	lds	r19, 0x018A
    43e2:	8b 81       	ldd	r24, Y+3	; 0x03
    43e4:	9c 81       	ldd	r25, Y+4	; 0x04
    43e6:	28 0f       	add	r18, r24
    43e8:	39 1f       	adc	r19, r25
    43ea:	80 91 89 01 	lds	r24, 0x0189
    43ee:	90 91 8a 01 	lds	r25, 0x018A
    43f2:	82 17       	cp	r24, r18
    43f4:	93 07       	cpc	r25, r19
    43f6:	a0 f4       	brcc	.+40     	; 0x4420 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    43f8:	80 91 89 01 	lds	r24, 0x0189
    43fc:	90 91 8a 01 	lds	r25, 0x018A
    4400:	85 57       	subi	r24, 0x75	; 117
    4402:	9e 4f       	sbci	r25, 0xFE	; 254
    4404:	9a 83       	std	Y+2, r25	; 0x02
    4406:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    4408:	20 91 89 01 	lds	r18, 0x0189
    440c:	30 91 8a 01 	lds	r19, 0x018A
    4410:	8b 81       	ldd	r24, Y+3	; 0x03
    4412:	9c 81       	ldd	r25, Y+4	; 0x04
    4414:	82 0f       	add	r24, r18
    4416:	93 1f       	adc	r25, r19
    4418:	90 93 8a 01 	sts	0x018A, r25
    441c:	80 93 89 01 	sts	0x0189, r24
		}	
	}
	xTaskResumeAll();
    4420:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    4424:	89 81       	ldd	r24, Y+1	; 0x01
    4426:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4428:	0f 90       	pop	r0
    442a:	0f 90       	pop	r0
    442c:	0f 90       	pop	r0
    442e:	0f 90       	pop	r0
    4430:	cf 91       	pop	r28
    4432:	df 91       	pop	r29
    4434:	08 95       	ret

00004436 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4436:	df 93       	push	r29
    4438:	cf 93       	push	r28
    443a:	00 d0       	rcall	.+0      	; 0x443c <vPortFree+0x6>
    443c:	cd b7       	in	r28, 0x3d	; 61
    443e:	de b7       	in	r29, 0x3e	; 62
    4440:	9a 83       	std	Y+2, r25	; 0x02
    4442:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    4444:	0f 90       	pop	r0
    4446:	0f 90       	pop	r0
    4448:	cf 91       	pop	r28
    444a:	df 91       	pop	r29
    444c:	08 95       	ret

0000444e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    444e:	df 93       	push	r29
    4450:	cf 93       	push	r28
    4452:	cd b7       	in	r28, 0x3d	; 61
    4454:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    4456:	10 92 8a 01 	sts	0x018A, r1
    445a:	10 92 89 01 	sts	0x0189, r1
}
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	08 95       	ret

00004464 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	cd b7       	in	r28, 0x3d	; 61
    446a:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    446c:	20 91 89 01 	lds	r18, 0x0189
    4470:	30 91 8a 01 	lds	r19, 0x018A
    4474:	84 e1       	ldi	r24, 0x14	; 20
    4476:	95 e0       	ldi	r25, 0x05	; 5
    4478:	82 1b       	sub	r24, r18
    447a:	93 0b       	sbc	r25, r19
}
    447c:	cf 91       	pop	r28
    447e:	df 91       	pop	r29
    4480:	08 95       	ret

00004482 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    4482:	df 93       	push	r29
    4484:	cf 93       	push	r28
    4486:	00 d0       	rcall	.+0      	; 0x4488 <vListInitialise+0x6>
    4488:	cd b7       	in	r28, 0x3d	; 61
    448a:	de b7       	in	r29, 0x3e	; 62
    448c:	9a 83       	std	Y+2, r25	; 0x02
    448e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    4490:	89 81       	ldd	r24, Y+1	; 0x01
    4492:	9a 81       	ldd	r25, Y+2	; 0x02
    4494:	03 96       	adiw	r24, 0x03	; 3
    4496:	e9 81       	ldd	r30, Y+1	; 0x01
    4498:	fa 81       	ldd	r31, Y+2	; 0x02
    449a:	92 83       	std	Z+2, r25	; 0x02
    449c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    449e:	e9 81       	ldd	r30, Y+1	; 0x01
    44a0:	fa 81       	ldd	r31, Y+2	; 0x02
    44a2:	8f ef       	ldi	r24, 0xFF	; 255
    44a4:	9f ef       	ldi	r25, 0xFF	; 255
    44a6:	94 83       	std	Z+4, r25	; 0x04
    44a8:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    44aa:	89 81       	ldd	r24, Y+1	; 0x01
    44ac:	9a 81       	ldd	r25, Y+2	; 0x02
    44ae:	03 96       	adiw	r24, 0x03	; 3
    44b0:	e9 81       	ldd	r30, Y+1	; 0x01
    44b2:	fa 81       	ldd	r31, Y+2	; 0x02
    44b4:	96 83       	std	Z+6, r25	; 0x06
    44b6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    44b8:	89 81       	ldd	r24, Y+1	; 0x01
    44ba:	9a 81       	ldd	r25, Y+2	; 0x02
    44bc:	03 96       	adiw	r24, 0x03	; 3
    44be:	e9 81       	ldd	r30, Y+1	; 0x01
    44c0:	fa 81       	ldd	r31, Y+2	; 0x02
    44c2:	90 87       	std	Z+8, r25	; 0x08
    44c4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    44c6:	e9 81       	ldd	r30, Y+1	; 0x01
    44c8:	fa 81       	ldd	r31, Y+2	; 0x02
    44ca:	10 82       	st	Z, r1
}
    44cc:	0f 90       	pop	r0
    44ce:	0f 90       	pop	r0
    44d0:	cf 91       	pop	r28
    44d2:	df 91       	pop	r29
    44d4:	08 95       	ret

000044d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    44d6:	df 93       	push	r29
    44d8:	cf 93       	push	r28
    44da:	00 d0       	rcall	.+0      	; 0x44dc <vListInitialiseItem+0x6>
    44dc:	cd b7       	in	r28, 0x3d	; 61
    44de:	de b7       	in	r29, 0x3e	; 62
    44e0:	9a 83       	std	Y+2, r25	; 0x02
    44e2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    44e4:	e9 81       	ldd	r30, Y+1	; 0x01
    44e6:	fa 81       	ldd	r31, Y+2	; 0x02
    44e8:	11 86       	std	Z+9, r1	; 0x09
    44ea:	10 86       	std	Z+8, r1	; 0x08
}
    44ec:	0f 90       	pop	r0
    44ee:	0f 90       	pop	r0
    44f0:	cf 91       	pop	r28
    44f2:	df 91       	pop	r29
    44f4:	08 95       	ret

000044f6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    44f6:	df 93       	push	r29
    44f8:	cf 93       	push	r28
    44fa:	00 d0       	rcall	.+0      	; 0x44fc <vListInsertEnd+0x6>
    44fc:	00 d0       	rcall	.+0      	; 0x44fe <vListInsertEnd+0x8>
    44fe:	00 d0       	rcall	.+0      	; 0x4500 <vListInsertEnd+0xa>
    4500:	cd b7       	in	r28, 0x3d	; 61
    4502:	de b7       	in	r29, 0x3e	; 62
    4504:	9c 83       	std	Y+4, r25	; 0x04
    4506:	8b 83       	std	Y+3, r24	; 0x03
    4508:	7e 83       	std	Y+6, r23	; 0x06
    450a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    450c:	eb 81       	ldd	r30, Y+3	; 0x03
    450e:	fc 81       	ldd	r31, Y+4	; 0x04
    4510:	81 81       	ldd	r24, Z+1	; 0x01
    4512:	92 81       	ldd	r25, Z+2	; 0x02
    4514:	9a 83       	std	Y+2, r25	; 0x02
    4516:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    4518:	e9 81       	ldd	r30, Y+1	; 0x01
    451a:	fa 81       	ldd	r31, Y+2	; 0x02
    451c:	82 81       	ldd	r24, Z+2	; 0x02
    451e:	93 81       	ldd	r25, Z+3	; 0x03
    4520:	ed 81       	ldd	r30, Y+5	; 0x05
    4522:	fe 81       	ldd	r31, Y+6	; 0x06
    4524:	93 83       	std	Z+3, r25	; 0x03
    4526:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    4528:	eb 81       	ldd	r30, Y+3	; 0x03
    452a:	fc 81       	ldd	r31, Y+4	; 0x04
    452c:	81 81       	ldd	r24, Z+1	; 0x01
    452e:	92 81       	ldd	r25, Z+2	; 0x02
    4530:	ed 81       	ldd	r30, Y+5	; 0x05
    4532:	fe 81       	ldd	r31, Y+6	; 0x06
    4534:	95 83       	std	Z+5, r25	; 0x05
    4536:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4538:	e9 81       	ldd	r30, Y+1	; 0x01
    453a:	fa 81       	ldd	r31, Y+2	; 0x02
    453c:	02 80       	ldd	r0, Z+2	; 0x02
    453e:	f3 81       	ldd	r31, Z+3	; 0x03
    4540:	e0 2d       	mov	r30, r0
    4542:	8d 81       	ldd	r24, Y+5	; 0x05
    4544:	9e 81       	ldd	r25, Y+6	; 0x06
    4546:	95 83       	std	Z+5, r25	; 0x05
    4548:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    454a:	8d 81       	ldd	r24, Y+5	; 0x05
    454c:	9e 81       	ldd	r25, Y+6	; 0x06
    454e:	e9 81       	ldd	r30, Y+1	; 0x01
    4550:	fa 81       	ldd	r31, Y+2	; 0x02
    4552:	93 83       	std	Z+3, r25	; 0x03
    4554:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    4556:	8d 81       	ldd	r24, Y+5	; 0x05
    4558:	9e 81       	ldd	r25, Y+6	; 0x06
    455a:	eb 81       	ldd	r30, Y+3	; 0x03
    455c:	fc 81       	ldd	r31, Y+4	; 0x04
    455e:	92 83       	std	Z+2, r25	; 0x02
    4560:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4562:	ed 81       	ldd	r30, Y+5	; 0x05
    4564:	fe 81       	ldd	r31, Y+6	; 0x06
    4566:	8b 81       	ldd	r24, Y+3	; 0x03
    4568:	9c 81       	ldd	r25, Y+4	; 0x04
    456a:	91 87       	std	Z+9, r25	; 0x09
    456c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    456e:	eb 81       	ldd	r30, Y+3	; 0x03
    4570:	fc 81       	ldd	r31, Y+4	; 0x04
    4572:	80 81       	ld	r24, Z
    4574:	8f 5f       	subi	r24, 0xFF	; 255
    4576:	eb 81       	ldd	r30, Y+3	; 0x03
    4578:	fc 81       	ldd	r31, Y+4	; 0x04
    457a:	80 83       	st	Z, r24
}
    457c:	26 96       	adiw	r28, 0x06	; 6
    457e:	0f b6       	in	r0, 0x3f	; 63
    4580:	f8 94       	cli
    4582:	de bf       	out	0x3e, r29	; 62
    4584:	0f be       	out	0x3f, r0	; 63
    4586:	cd bf       	out	0x3d, r28	; 61
    4588:	cf 91       	pop	r28
    458a:	df 91       	pop	r29
    458c:	08 95       	ret

0000458e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    458e:	df 93       	push	r29
    4590:	cf 93       	push	r28
    4592:	cd b7       	in	r28, 0x3d	; 61
    4594:	de b7       	in	r29, 0x3e	; 62
    4596:	28 97       	sbiw	r28, 0x08	; 8
    4598:	0f b6       	in	r0, 0x3f	; 63
    459a:	f8 94       	cli
    459c:	de bf       	out	0x3e, r29	; 62
    459e:	0f be       	out	0x3f, r0	; 63
    45a0:	cd bf       	out	0x3d, r28	; 61
    45a2:	9e 83       	std	Y+6, r25	; 0x06
    45a4:	8d 83       	std	Y+5, r24	; 0x05
    45a6:	78 87       	std	Y+8, r23	; 0x08
    45a8:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    45aa:	ef 81       	ldd	r30, Y+7	; 0x07
    45ac:	f8 85       	ldd	r31, Y+8	; 0x08
    45ae:	80 81       	ld	r24, Z
    45b0:	91 81       	ldd	r25, Z+1	; 0x01
    45b2:	9a 83       	std	Y+2, r25	; 0x02
    45b4:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    45b6:	89 81       	ldd	r24, Y+1	; 0x01
    45b8:	9a 81       	ldd	r25, Y+2	; 0x02
    45ba:	2f ef       	ldi	r18, 0xFF	; 255
    45bc:	8f 3f       	cpi	r24, 0xFF	; 255
    45be:	92 07       	cpc	r25, r18
    45c0:	39 f4       	brne	.+14     	; 0x45d0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    45c2:	ed 81       	ldd	r30, Y+5	; 0x05
    45c4:	fe 81       	ldd	r31, Y+6	; 0x06
    45c6:	87 81       	ldd	r24, Z+7	; 0x07
    45c8:	90 85       	ldd	r25, Z+8	; 0x08
    45ca:	9c 83       	std	Y+4, r25	; 0x04
    45cc:	8b 83       	std	Y+3, r24	; 0x03
    45ce:	18 c0       	rjmp	.+48     	; 0x4600 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    45d0:	8d 81       	ldd	r24, Y+5	; 0x05
    45d2:	9e 81       	ldd	r25, Y+6	; 0x06
    45d4:	03 96       	adiw	r24, 0x03	; 3
    45d6:	9c 83       	std	Y+4, r25	; 0x04
    45d8:	8b 83       	std	Y+3, r24	; 0x03
    45da:	06 c0       	rjmp	.+12     	; 0x45e8 <vListInsert+0x5a>
    45dc:	eb 81       	ldd	r30, Y+3	; 0x03
    45de:	fc 81       	ldd	r31, Y+4	; 0x04
    45e0:	82 81       	ldd	r24, Z+2	; 0x02
    45e2:	93 81       	ldd	r25, Z+3	; 0x03
    45e4:	9c 83       	std	Y+4, r25	; 0x04
    45e6:	8b 83       	std	Y+3, r24	; 0x03
    45e8:	eb 81       	ldd	r30, Y+3	; 0x03
    45ea:	fc 81       	ldd	r31, Y+4	; 0x04
    45ec:	02 80       	ldd	r0, Z+2	; 0x02
    45ee:	f3 81       	ldd	r31, Z+3	; 0x03
    45f0:	e0 2d       	mov	r30, r0
    45f2:	20 81       	ld	r18, Z
    45f4:	31 81       	ldd	r19, Z+1	; 0x01
    45f6:	89 81       	ldd	r24, Y+1	; 0x01
    45f8:	9a 81       	ldd	r25, Y+2	; 0x02
    45fa:	82 17       	cp	r24, r18
    45fc:	93 07       	cpc	r25, r19
    45fe:	70 f7       	brcc	.-36     	; 0x45dc <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4600:	eb 81       	ldd	r30, Y+3	; 0x03
    4602:	fc 81       	ldd	r31, Y+4	; 0x04
    4604:	82 81       	ldd	r24, Z+2	; 0x02
    4606:	93 81       	ldd	r25, Z+3	; 0x03
    4608:	ef 81       	ldd	r30, Y+7	; 0x07
    460a:	f8 85       	ldd	r31, Y+8	; 0x08
    460c:	93 83       	std	Z+3, r25	; 0x03
    460e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    4610:	ef 81       	ldd	r30, Y+7	; 0x07
    4612:	f8 85       	ldd	r31, Y+8	; 0x08
    4614:	02 80       	ldd	r0, Z+2	; 0x02
    4616:	f3 81       	ldd	r31, Z+3	; 0x03
    4618:	e0 2d       	mov	r30, r0
    461a:	8f 81       	ldd	r24, Y+7	; 0x07
    461c:	98 85       	ldd	r25, Y+8	; 0x08
    461e:	95 83       	std	Z+5, r25	; 0x05
    4620:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4622:	ef 81       	ldd	r30, Y+7	; 0x07
    4624:	f8 85       	ldd	r31, Y+8	; 0x08
    4626:	8b 81       	ldd	r24, Y+3	; 0x03
    4628:	9c 81       	ldd	r25, Y+4	; 0x04
    462a:	95 83       	std	Z+5, r25	; 0x05
    462c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    462e:	8f 81       	ldd	r24, Y+7	; 0x07
    4630:	98 85       	ldd	r25, Y+8	; 0x08
    4632:	eb 81       	ldd	r30, Y+3	; 0x03
    4634:	fc 81       	ldd	r31, Y+4	; 0x04
    4636:	93 83       	std	Z+3, r25	; 0x03
    4638:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    463a:	ef 81       	ldd	r30, Y+7	; 0x07
    463c:	f8 85       	ldd	r31, Y+8	; 0x08
    463e:	8d 81       	ldd	r24, Y+5	; 0x05
    4640:	9e 81       	ldd	r25, Y+6	; 0x06
    4642:	91 87       	std	Z+9, r25	; 0x09
    4644:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4646:	ed 81       	ldd	r30, Y+5	; 0x05
    4648:	fe 81       	ldd	r31, Y+6	; 0x06
    464a:	80 81       	ld	r24, Z
    464c:	8f 5f       	subi	r24, 0xFF	; 255
    464e:	ed 81       	ldd	r30, Y+5	; 0x05
    4650:	fe 81       	ldd	r31, Y+6	; 0x06
    4652:	80 83       	st	Z, r24
}
    4654:	28 96       	adiw	r28, 0x08	; 8
    4656:	0f b6       	in	r0, 0x3f	; 63
    4658:	f8 94       	cli
    465a:	de bf       	out	0x3e, r29	; 62
    465c:	0f be       	out	0x3f, r0	; 63
    465e:	cd bf       	out	0x3d, r28	; 61
    4660:	cf 91       	pop	r28
    4662:	df 91       	pop	r29
    4664:	08 95       	ret

00004666 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    4666:	df 93       	push	r29
    4668:	cf 93       	push	r28
    466a:	00 d0       	rcall	.+0      	; 0x466c <vListRemove+0x6>
    466c:	00 d0       	rcall	.+0      	; 0x466e <vListRemove+0x8>
    466e:	cd b7       	in	r28, 0x3d	; 61
    4670:	de b7       	in	r29, 0x3e	; 62
    4672:	9c 83       	std	Y+4, r25	; 0x04
    4674:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4676:	eb 81       	ldd	r30, Y+3	; 0x03
    4678:	fc 81       	ldd	r31, Y+4	; 0x04
    467a:	a2 81       	ldd	r26, Z+2	; 0x02
    467c:	b3 81       	ldd	r27, Z+3	; 0x03
    467e:	eb 81       	ldd	r30, Y+3	; 0x03
    4680:	fc 81       	ldd	r31, Y+4	; 0x04
    4682:	84 81       	ldd	r24, Z+4	; 0x04
    4684:	95 81       	ldd	r25, Z+5	; 0x05
    4686:	15 96       	adiw	r26, 0x05	; 5
    4688:	9c 93       	st	X, r25
    468a:	8e 93       	st	-X, r24
    468c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    468e:	eb 81       	ldd	r30, Y+3	; 0x03
    4690:	fc 81       	ldd	r31, Y+4	; 0x04
    4692:	a4 81       	ldd	r26, Z+4	; 0x04
    4694:	b5 81       	ldd	r27, Z+5	; 0x05
    4696:	eb 81       	ldd	r30, Y+3	; 0x03
    4698:	fc 81       	ldd	r31, Y+4	; 0x04
    469a:	82 81       	ldd	r24, Z+2	; 0x02
    469c:	93 81       	ldd	r25, Z+3	; 0x03
    469e:	13 96       	adiw	r26, 0x03	; 3
    46a0:	9c 93       	st	X, r25
    46a2:	8e 93       	st	-X, r24
    46a4:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    46a6:	eb 81       	ldd	r30, Y+3	; 0x03
    46a8:	fc 81       	ldd	r31, Y+4	; 0x04
    46aa:	80 85       	ldd	r24, Z+8	; 0x08
    46ac:	91 85       	ldd	r25, Z+9	; 0x09
    46ae:	9a 83       	std	Y+2, r25	; 0x02
    46b0:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    46b2:	e9 81       	ldd	r30, Y+1	; 0x01
    46b4:	fa 81       	ldd	r31, Y+2	; 0x02
    46b6:	21 81       	ldd	r18, Z+1	; 0x01
    46b8:	32 81       	ldd	r19, Z+2	; 0x02
    46ba:	8b 81       	ldd	r24, Y+3	; 0x03
    46bc:	9c 81       	ldd	r25, Y+4	; 0x04
    46be:	28 17       	cp	r18, r24
    46c0:	39 07       	cpc	r19, r25
    46c2:	41 f4       	brne	.+16     	; 0x46d4 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    46c4:	eb 81       	ldd	r30, Y+3	; 0x03
    46c6:	fc 81       	ldd	r31, Y+4	; 0x04
    46c8:	84 81       	ldd	r24, Z+4	; 0x04
    46ca:	95 81       	ldd	r25, Z+5	; 0x05
    46cc:	e9 81       	ldd	r30, Y+1	; 0x01
    46ce:	fa 81       	ldd	r31, Y+2	; 0x02
    46d0:	92 83       	std	Z+2, r25	; 0x02
    46d2:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    46d4:	eb 81       	ldd	r30, Y+3	; 0x03
    46d6:	fc 81       	ldd	r31, Y+4	; 0x04
    46d8:	11 86       	std	Z+9, r1	; 0x09
    46da:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    46dc:	e9 81       	ldd	r30, Y+1	; 0x01
    46de:	fa 81       	ldd	r31, Y+2	; 0x02
    46e0:	80 81       	ld	r24, Z
    46e2:	81 50       	subi	r24, 0x01	; 1
    46e4:	e9 81       	ldd	r30, Y+1	; 0x01
    46e6:	fa 81       	ldd	r31, Y+2	; 0x02
    46e8:	80 83       	st	Z, r24
}
    46ea:	0f 90       	pop	r0
    46ec:	0f 90       	pop	r0
    46ee:	0f 90       	pop	r0
    46f0:	0f 90       	pop	r0
    46f2:	cf 91       	pop	r28
    46f4:	df 91       	pop	r29
    46f6:	08 95       	ret

000046f8 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    46f8:	df 93       	push	r29
    46fa:	cf 93       	push	r28
    46fc:	cd b7       	in	r28, 0x3d	; 61
    46fe:	de b7       	in	r29, 0x3e	; 62
    4700:	28 97       	sbiw	r28, 0x08	; 8
    4702:	0f b6       	in	r0, 0x3f	; 63
    4704:	f8 94       	cli
    4706:	de bf       	out	0x3e, r29	; 62
    4708:	0f be       	out	0x3f, r0	; 63
    470a:	cd bf       	out	0x3d, r28	; 61
    470c:	9c 83       	std	Y+4, r25	; 0x04
    470e:	8b 83       	std	Y+3, r24	; 0x03
    4710:	7e 83       	std	Y+6, r23	; 0x06
    4712:	6d 83       	std	Y+5, r22	; 0x05
    4714:	58 87       	std	Y+8, r21	; 0x08
    4716:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    4718:	eb 81       	ldd	r30, Y+3	; 0x03
    471a:	fc 81       	ldd	r31, Y+4	; 0x04
    471c:	81 e1       	ldi	r24, 0x11	; 17
    471e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4720:	8b 81       	ldd	r24, Y+3	; 0x03
    4722:	9c 81       	ldd	r25, Y+4	; 0x04
    4724:	01 97       	sbiw	r24, 0x01	; 1
    4726:	9c 83       	std	Y+4, r25	; 0x04
    4728:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    472a:	eb 81       	ldd	r30, Y+3	; 0x03
    472c:	fc 81       	ldd	r31, Y+4	; 0x04
    472e:	82 e2       	ldi	r24, 0x22	; 34
    4730:	80 83       	st	Z, r24
	pxTopOfStack--;
    4732:	8b 81       	ldd	r24, Y+3	; 0x03
    4734:	9c 81       	ldd	r25, Y+4	; 0x04
    4736:	01 97       	sbiw	r24, 0x01	; 1
    4738:	9c 83       	std	Y+4, r25	; 0x04
    473a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    473c:	eb 81       	ldd	r30, Y+3	; 0x03
    473e:	fc 81       	ldd	r31, Y+4	; 0x04
    4740:	83 e3       	ldi	r24, 0x33	; 51
    4742:	80 83       	st	Z, r24
	pxTopOfStack--;
    4744:	8b 81       	ldd	r24, Y+3	; 0x03
    4746:	9c 81       	ldd	r25, Y+4	; 0x04
    4748:	01 97       	sbiw	r24, 0x01	; 1
    474a:	9c 83       	std	Y+4, r25	; 0x04
    474c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    474e:	8d 81       	ldd	r24, Y+5	; 0x05
    4750:	9e 81       	ldd	r25, Y+6	; 0x06
    4752:	9a 83       	std	Y+2, r25	; 0x02
    4754:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4756:	89 81       	ldd	r24, Y+1	; 0x01
    4758:	eb 81       	ldd	r30, Y+3	; 0x03
    475a:	fc 81       	ldd	r31, Y+4	; 0x04
    475c:	80 83       	st	Z, r24
	pxTopOfStack--;
    475e:	8b 81       	ldd	r24, Y+3	; 0x03
    4760:	9c 81       	ldd	r25, Y+4	; 0x04
    4762:	01 97       	sbiw	r24, 0x01	; 1
    4764:	9c 83       	std	Y+4, r25	; 0x04
    4766:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4768:	89 81       	ldd	r24, Y+1	; 0x01
    476a:	9a 81       	ldd	r25, Y+2	; 0x02
    476c:	89 2f       	mov	r24, r25
    476e:	99 27       	eor	r25, r25
    4770:	9a 83       	std	Y+2, r25	; 0x02
    4772:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    4774:	89 81       	ldd	r24, Y+1	; 0x01
    4776:	eb 81       	ldd	r30, Y+3	; 0x03
    4778:	fc 81       	ldd	r31, Y+4	; 0x04
    477a:	80 83       	st	Z, r24
	pxTopOfStack--;
    477c:	8b 81       	ldd	r24, Y+3	; 0x03
    477e:	9c 81       	ldd	r25, Y+4	; 0x04
    4780:	01 97       	sbiw	r24, 0x01	; 1
    4782:	9c 83       	std	Y+4, r25	; 0x04
    4784:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    4786:	eb 81       	ldd	r30, Y+3	; 0x03
    4788:	fc 81       	ldd	r31, Y+4	; 0x04
    478a:	10 82       	st	Z, r1
	pxTopOfStack--;
    478c:	8b 81       	ldd	r24, Y+3	; 0x03
    478e:	9c 81       	ldd	r25, Y+4	; 0x04
    4790:	01 97       	sbiw	r24, 0x01	; 1
    4792:	9c 83       	std	Y+4, r25	; 0x04
    4794:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    4796:	eb 81       	ldd	r30, Y+3	; 0x03
    4798:	fc 81       	ldd	r31, Y+4	; 0x04
    479a:	80 e8       	ldi	r24, 0x80	; 128
    479c:	80 83       	st	Z, r24
	pxTopOfStack--;
    479e:	8b 81       	ldd	r24, Y+3	; 0x03
    47a0:	9c 81       	ldd	r25, Y+4	; 0x04
    47a2:	01 97       	sbiw	r24, 0x01	; 1
    47a4:	9c 83       	std	Y+4, r25	; 0x04
    47a6:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    47a8:	eb 81       	ldd	r30, Y+3	; 0x03
    47aa:	fc 81       	ldd	r31, Y+4	; 0x04
    47ac:	10 82       	st	Z, r1
	pxTopOfStack--;
    47ae:	8b 81       	ldd	r24, Y+3	; 0x03
    47b0:	9c 81       	ldd	r25, Y+4	; 0x04
    47b2:	01 97       	sbiw	r24, 0x01	; 1
    47b4:	9c 83       	std	Y+4, r25	; 0x04
    47b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    47b8:	eb 81       	ldd	r30, Y+3	; 0x03
    47ba:	fc 81       	ldd	r31, Y+4	; 0x04
    47bc:	82 e0       	ldi	r24, 0x02	; 2
    47be:	80 83       	st	Z, r24
	pxTopOfStack--;
    47c0:	8b 81       	ldd	r24, Y+3	; 0x03
    47c2:	9c 81       	ldd	r25, Y+4	; 0x04
    47c4:	01 97       	sbiw	r24, 0x01	; 1
    47c6:	9c 83       	std	Y+4, r25	; 0x04
    47c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    47ca:	eb 81       	ldd	r30, Y+3	; 0x03
    47cc:	fc 81       	ldd	r31, Y+4	; 0x04
    47ce:	83 e0       	ldi	r24, 0x03	; 3
    47d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    47d2:	8b 81       	ldd	r24, Y+3	; 0x03
    47d4:	9c 81       	ldd	r25, Y+4	; 0x04
    47d6:	01 97       	sbiw	r24, 0x01	; 1
    47d8:	9c 83       	std	Y+4, r25	; 0x04
    47da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    47dc:	eb 81       	ldd	r30, Y+3	; 0x03
    47de:	fc 81       	ldd	r31, Y+4	; 0x04
    47e0:	84 e0       	ldi	r24, 0x04	; 4
    47e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    47e4:	8b 81       	ldd	r24, Y+3	; 0x03
    47e6:	9c 81       	ldd	r25, Y+4	; 0x04
    47e8:	01 97       	sbiw	r24, 0x01	; 1
    47ea:	9c 83       	std	Y+4, r25	; 0x04
    47ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    47ee:	eb 81       	ldd	r30, Y+3	; 0x03
    47f0:	fc 81       	ldd	r31, Y+4	; 0x04
    47f2:	85 e0       	ldi	r24, 0x05	; 5
    47f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    47f6:	8b 81       	ldd	r24, Y+3	; 0x03
    47f8:	9c 81       	ldd	r25, Y+4	; 0x04
    47fa:	01 97       	sbiw	r24, 0x01	; 1
    47fc:	9c 83       	std	Y+4, r25	; 0x04
    47fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    4800:	eb 81       	ldd	r30, Y+3	; 0x03
    4802:	fc 81       	ldd	r31, Y+4	; 0x04
    4804:	86 e0       	ldi	r24, 0x06	; 6
    4806:	80 83       	st	Z, r24
	pxTopOfStack--;
    4808:	8b 81       	ldd	r24, Y+3	; 0x03
    480a:	9c 81       	ldd	r25, Y+4	; 0x04
    480c:	01 97       	sbiw	r24, 0x01	; 1
    480e:	9c 83       	std	Y+4, r25	; 0x04
    4810:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    4812:	eb 81       	ldd	r30, Y+3	; 0x03
    4814:	fc 81       	ldd	r31, Y+4	; 0x04
    4816:	87 e0       	ldi	r24, 0x07	; 7
    4818:	80 83       	st	Z, r24
	pxTopOfStack--;
    481a:	8b 81       	ldd	r24, Y+3	; 0x03
    481c:	9c 81       	ldd	r25, Y+4	; 0x04
    481e:	01 97       	sbiw	r24, 0x01	; 1
    4820:	9c 83       	std	Y+4, r25	; 0x04
    4822:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    4824:	eb 81       	ldd	r30, Y+3	; 0x03
    4826:	fc 81       	ldd	r31, Y+4	; 0x04
    4828:	88 e0       	ldi	r24, 0x08	; 8
    482a:	80 83       	st	Z, r24
	pxTopOfStack--;
    482c:	8b 81       	ldd	r24, Y+3	; 0x03
    482e:	9c 81       	ldd	r25, Y+4	; 0x04
    4830:	01 97       	sbiw	r24, 0x01	; 1
    4832:	9c 83       	std	Y+4, r25	; 0x04
    4834:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    4836:	eb 81       	ldd	r30, Y+3	; 0x03
    4838:	fc 81       	ldd	r31, Y+4	; 0x04
    483a:	89 e0       	ldi	r24, 0x09	; 9
    483c:	80 83       	st	Z, r24
	pxTopOfStack--;
    483e:	8b 81       	ldd	r24, Y+3	; 0x03
    4840:	9c 81       	ldd	r25, Y+4	; 0x04
    4842:	01 97       	sbiw	r24, 0x01	; 1
    4844:	9c 83       	std	Y+4, r25	; 0x04
    4846:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    4848:	eb 81       	ldd	r30, Y+3	; 0x03
    484a:	fc 81       	ldd	r31, Y+4	; 0x04
    484c:	80 e1       	ldi	r24, 0x10	; 16
    484e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4850:	8b 81       	ldd	r24, Y+3	; 0x03
    4852:	9c 81       	ldd	r25, Y+4	; 0x04
    4854:	01 97       	sbiw	r24, 0x01	; 1
    4856:	9c 83       	std	Y+4, r25	; 0x04
    4858:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    485a:	eb 81       	ldd	r30, Y+3	; 0x03
    485c:	fc 81       	ldd	r31, Y+4	; 0x04
    485e:	81 e1       	ldi	r24, 0x11	; 17
    4860:	80 83       	st	Z, r24
	pxTopOfStack--;
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
    4864:	9c 81       	ldd	r25, Y+4	; 0x04
    4866:	01 97       	sbiw	r24, 0x01	; 1
    4868:	9c 83       	std	Y+4, r25	; 0x04
    486a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    486c:	eb 81       	ldd	r30, Y+3	; 0x03
    486e:	fc 81       	ldd	r31, Y+4	; 0x04
    4870:	82 e1       	ldi	r24, 0x12	; 18
    4872:	80 83       	st	Z, r24
	pxTopOfStack--;
    4874:	8b 81       	ldd	r24, Y+3	; 0x03
    4876:	9c 81       	ldd	r25, Y+4	; 0x04
    4878:	01 97       	sbiw	r24, 0x01	; 1
    487a:	9c 83       	std	Y+4, r25	; 0x04
    487c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    487e:	eb 81       	ldd	r30, Y+3	; 0x03
    4880:	fc 81       	ldd	r31, Y+4	; 0x04
    4882:	83 e1       	ldi	r24, 0x13	; 19
    4884:	80 83       	st	Z, r24
	pxTopOfStack--;
    4886:	8b 81       	ldd	r24, Y+3	; 0x03
    4888:	9c 81       	ldd	r25, Y+4	; 0x04
    488a:	01 97       	sbiw	r24, 0x01	; 1
    488c:	9c 83       	std	Y+4, r25	; 0x04
    488e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    4890:	eb 81       	ldd	r30, Y+3	; 0x03
    4892:	fc 81       	ldd	r31, Y+4	; 0x04
    4894:	84 e1       	ldi	r24, 0x14	; 20
    4896:	80 83       	st	Z, r24
	pxTopOfStack--;
    4898:	8b 81       	ldd	r24, Y+3	; 0x03
    489a:	9c 81       	ldd	r25, Y+4	; 0x04
    489c:	01 97       	sbiw	r24, 0x01	; 1
    489e:	9c 83       	std	Y+4, r25	; 0x04
    48a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    48a2:	eb 81       	ldd	r30, Y+3	; 0x03
    48a4:	fc 81       	ldd	r31, Y+4	; 0x04
    48a6:	85 e1       	ldi	r24, 0x15	; 21
    48a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    48aa:	8b 81       	ldd	r24, Y+3	; 0x03
    48ac:	9c 81       	ldd	r25, Y+4	; 0x04
    48ae:	01 97       	sbiw	r24, 0x01	; 1
    48b0:	9c 83       	std	Y+4, r25	; 0x04
    48b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    48b4:	eb 81       	ldd	r30, Y+3	; 0x03
    48b6:	fc 81       	ldd	r31, Y+4	; 0x04
    48b8:	86 e1       	ldi	r24, 0x16	; 22
    48ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    48bc:	8b 81       	ldd	r24, Y+3	; 0x03
    48be:	9c 81       	ldd	r25, Y+4	; 0x04
    48c0:	01 97       	sbiw	r24, 0x01	; 1
    48c2:	9c 83       	std	Y+4, r25	; 0x04
    48c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    48c6:	eb 81       	ldd	r30, Y+3	; 0x03
    48c8:	fc 81       	ldd	r31, Y+4	; 0x04
    48ca:	87 e1       	ldi	r24, 0x17	; 23
    48cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    48ce:	8b 81       	ldd	r24, Y+3	; 0x03
    48d0:	9c 81       	ldd	r25, Y+4	; 0x04
    48d2:	01 97       	sbiw	r24, 0x01	; 1
    48d4:	9c 83       	std	Y+4, r25	; 0x04
    48d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    48d8:	eb 81       	ldd	r30, Y+3	; 0x03
    48da:	fc 81       	ldd	r31, Y+4	; 0x04
    48dc:	88 e1       	ldi	r24, 0x18	; 24
    48de:	80 83       	st	Z, r24
	pxTopOfStack--;
    48e0:	8b 81       	ldd	r24, Y+3	; 0x03
    48e2:	9c 81       	ldd	r25, Y+4	; 0x04
    48e4:	01 97       	sbiw	r24, 0x01	; 1
    48e6:	9c 83       	std	Y+4, r25	; 0x04
    48e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    48ea:	eb 81       	ldd	r30, Y+3	; 0x03
    48ec:	fc 81       	ldd	r31, Y+4	; 0x04
    48ee:	89 e1       	ldi	r24, 0x19	; 25
    48f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    48f2:	8b 81       	ldd	r24, Y+3	; 0x03
    48f4:	9c 81       	ldd	r25, Y+4	; 0x04
    48f6:	01 97       	sbiw	r24, 0x01	; 1
    48f8:	9c 83       	std	Y+4, r25	; 0x04
    48fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    48fc:	eb 81       	ldd	r30, Y+3	; 0x03
    48fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4900:	80 e2       	ldi	r24, 0x20	; 32
    4902:	80 83       	st	Z, r24
	pxTopOfStack--;
    4904:	8b 81       	ldd	r24, Y+3	; 0x03
    4906:	9c 81       	ldd	r25, Y+4	; 0x04
    4908:	01 97       	sbiw	r24, 0x01	; 1
    490a:	9c 83       	std	Y+4, r25	; 0x04
    490c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    490e:	eb 81       	ldd	r30, Y+3	; 0x03
    4910:	fc 81       	ldd	r31, Y+4	; 0x04
    4912:	81 e2       	ldi	r24, 0x21	; 33
    4914:	80 83       	st	Z, r24
	pxTopOfStack--;
    4916:	8b 81       	ldd	r24, Y+3	; 0x03
    4918:	9c 81       	ldd	r25, Y+4	; 0x04
    491a:	01 97       	sbiw	r24, 0x01	; 1
    491c:	9c 83       	std	Y+4, r25	; 0x04
    491e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    4920:	eb 81       	ldd	r30, Y+3	; 0x03
    4922:	fc 81       	ldd	r31, Y+4	; 0x04
    4924:	82 e2       	ldi	r24, 0x22	; 34
    4926:	80 83       	st	Z, r24
	pxTopOfStack--;
    4928:	8b 81       	ldd	r24, Y+3	; 0x03
    492a:	9c 81       	ldd	r25, Y+4	; 0x04
    492c:	01 97       	sbiw	r24, 0x01	; 1
    492e:	9c 83       	std	Y+4, r25	; 0x04
    4930:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    4932:	eb 81       	ldd	r30, Y+3	; 0x03
    4934:	fc 81       	ldd	r31, Y+4	; 0x04
    4936:	83 e2       	ldi	r24, 0x23	; 35
    4938:	80 83       	st	Z, r24
	pxTopOfStack--;
    493a:	8b 81       	ldd	r24, Y+3	; 0x03
    493c:	9c 81       	ldd	r25, Y+4	; 0x04
    493e:	01 97       	sbiw	r24, 0x01	; 1
    4940:	9c 83       	std	Y+4, r25	; 0x04
    4942:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    4944:	8f 81       	ldd	r24, Y+7	; 0x07
    4946:	98 85       	ldd	r25, Y+8	; 0x08
    4948:	9a 83       	std	Y+2, r25	; 0x02
    494a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    494c:	89 81       	ldd	r24, Y+1	; 0x01
    494e:	eb 81       	ldd	r30, Y+3	; 0x03
    4950:	fc 81       	ldd	r31, Y+4	; 0x04
    4952:	80 83       	st	Z, r24
	pxTopOfStack--;
    4954:	8b 81       	ldd	r24, Y+3	; 0x03
    4956:	9c 81       	ldd	r25, Y+4	; 0x04
    4958:	01 97       	sbiw	r24, 0x01	; 1
    495a:	9c 83       	std	Y+4, r25	; 0x04
    495c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    495e:	89 81       	ldd	r24, Y+1	; 0x01
    4960:	9a 81       	ldd	r25, Y+2	; 0x02
    4962:	89 2f       	mov	r24, r25
    4964:	99 27       	eor	r25, r25
    4966:	9a 83       	std	Y+2, r25	; 0x02
    4968:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    496a:	89 81       	ldd	r24, Y+1	; 0x01
    496c:	eb 81       	ldd	r30, Y+3	; 0x03
    496e:	fc 81       	ldd	r31, Y+4	; 0x04
    4970:	80 83       	st	Z, r24
	pxTopOfStack--;
    4972:	8b 81       	ldd	r24, Y+3	; 0x03
    4974:	9c 81       	ldd	r25, Y+4	; 0x04
    4976:	01 97       	sbiw	r24, 0x01	; 1
    4978:	9c 83       	std	Y+4, r25	; 0x04
    497a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    497c:	eb 81       	ldd	r30, Y+3	; 0x03
    497e:	fc 81       	ldd	r31, Y+4	; 0x04
    4980:	86 e2       	ldi	r24, 0x26	; 38
    4982:	80 83       	st	Z, r24
	pxTopOfStack--;
    4984:	8b 81       	ldd	r24, Y+3	; 0x03
    4986:	9c 81       	ldd	r25, Y+4	; 0x04
    4988:	01 97       	sbiw	r24, 0x01	; 1
    498a:	9c 83       	std	Y+4, r25	; 0x04
    498c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    498e:	eb 81       	ldd	r30, Y+3	; 0x03
    4990:	fc 81       	ldd	r31, Y+4	; 0x04
    4992:	87 e2       	ldi	r24, 0x27	; 39
    4994:	80 83       	st	Z, r24
	pxTopOfStack--;
    4996:	8b 81       	ldd	r24, Y+3	; 0x03
    4998:	9c 81       	ldd	r25, Y+4	; 0x04
    499a:	01 97       	sbiw	r24, 0x01	; 1
    499c:	9c 83       	std	Y+4, r25	; 0x04
    499e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    49a0:	eb 81       	ldd	r30, Y+3	; 0x03
    49a2:	fc 81       	ldd	r31, Y+4	; 0x04
    49a4:	88 e2       	ldi	r24, 0x28	; 40
    49a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    49a8:	8b 81       	ldd	r24, Y+3	; 0x03
    49aa:	9c 81       	ldd	r25, Y+4	; 0x04
    49ac:	01 97       	sbiw	r24, 0x01	; 1
    49ae:	9c 83       	std	Y+4, r25	; 0x04
    49b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    49b2:	eb 81       	ldd	r30, Y+3	; 0x03
    49b4:	fc 81       	ldd	r31, Y+4	; 0x04
    49b6:	89 e2       	ldi	r24, 0x29	; 41
    49b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    49ba:	8b 81       	ldd	r24, Y+3	; 0x03
    49bc:	9c 81       	ldd	r25, Y+4	; 0x04
    49be:	01 97       	sbiw	r24, 0x01	; 1
    49c0:	9c 83       	std	Y+4, r25	; 0x04
    49c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    49c4:	eb 81       	ldd	r30, Y+3	; 0x03
    49c6:	fc 81       	ldd	r31, Y+4	; 0x04
    49c8:	80 e3       	ldi	r24, 0x30	; 48
    49ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    49cc:	8b 81       	ldd	r24, Y+3	; 0x03
    49ce:	9c 81       	ldd	r25, Y+4	; 0x04
    49d0:	01 97       	sbiw	r24, 0x01	; 1
    49d2:	9c 83       	std	Y+4, r25	; 0x04
    49d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    49d6:	eb 81       	ldd	r30, Y+3	; 0x03
    49d8:	fc 81       	ldd	r31, Y+4	; 0x04
    49da:	81 e3       	ldi	r24, 0x31	; 49
    49dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    49de:	8b 81       	ldd	r24, Y+3	; 0x03
    49e0:	9c 81       	ldd	r25, Y+4	; 0x04
    49e2:	01 97       	sbiw	r24, 0x01	; 1
    49e4:	9c 83       	std	Y+4, r25	; 0x04
    49e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    49e8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ea:	9c 81       	ldd	r25, Y+4	; 0x04
}
    49ec:	28 96       	adiw	r28, 0x08	; 8
    49ee:	0f b6       	in	r0, 0x3f	; 63
    49f0:	f8 94       	cli
    49f2:	de bf       	out	0x3e, r29	; 62
    49f4:	0f be       	out	0x3f, r0	; 63
    49f6:	cd bf       	out	0x3d, r28	; 61
    49f8:	cf 91       	pop	r28
    49fa:	df 91       	pop	r29
    49fc:	08 95       	ret

000049fe <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    49fe:	df 93       	push	r29
    4a00:	cf 93       	push	r28
    4a02:	cd b7       	in	r28, 0x3d	; 61
    4a04:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    4a06:	0e 94 ef 25 	call	0x4bde	; 0x4bde <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    4a0a:	a0 91 9f 06 	lds	r26, 0x069F
    4a0e:	b0 91 a0 06 	lds	r27, 0x06A0
    4a12:	cd 91       	ld	r28, X+
    4a14:	cd bf       	out	0x3d, r28	; 61
    4a16:	dd 91       	ld	r29, X+
    4a18:	de bf       	out	0x3e, r29	; 62
    4a1a:	ff 91       	pop	r31
    4a1c:	ef 91       	pop	r30
    4a1e:	df 91       	pop	r29
    4a20:	cf 91       	pop	r28
    4a22:	bf 91       	pop	r27
    4a24:	af 91       	pop	r26
    4a26:	9f 91       	pop	r25
    4a28:	8f 91       	pop	r24
    4a2a:	7f 91       	pop	r23
    4a2c:	6f 91       	pop	r22
    4a2e:	5f 91       	pop	r21
    4a30:	4f 91       	pop	r20
    4a32:	3f 91       	pop	r19
    4a34:	2f 91       	pop	r18
    4a36:	1f 91       	pop	r17
    4a38:	0f 91       	pop	r16
    4a3a:	ff 90       	pop	r15
    4a3c:	ef 90       	pop	r14
    4a3e:	df 90       	pop	r13
    4a40:	cf 90       	pop	r12
    4a42:	bf 90       	pop	r11
    4a44:	af 90       	pop	r10
    4a46:	9f 90       	pop	r9
    4a48:	8f 90       	pop	r8
    4a4a:	7f 90       	pop	r7
    4a4c:	6f 90       	pop	r6
    4a4e:	5f 90       	pop	r5
    4a50:	4f 90       	pop	r4
    4a52:	3f 90       	pop	r3
    4a54:	2f 90       	pop	r2
    4a56:	1f 90       	pop	r1
    4a58:	0f 90       	pop	r0
    4a5a:	0f be       	out	0x3f, r0	; 63
    4a5c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    4a5e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    4a60:	81 e0       	ldi	r24, 0x01	; 1
}
    4a62:	cf 91       	pop	r28
    4a64:	df 91       	pop	r29
    4a66:	08 95       	ret

00004a68 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4a68:	df 93       	push	r29
    4a6a:	cf 93       	push	r28
    4a6c:	cd b7       	in	r28, 0x3d	; 61
    4a6e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    4a70:	cf 91       	pop	r28
    4a72:	df 91       	pop	r29
    4a74:	08 95       	ret

00004a76 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    4a76:	0f 92       	push	r0
    4a78:	0f b6       	in	r0, 0x3f	; 63
    4a7a:	f8 94       	cli
    4a7c:	0f 92       	push	r0
    4a7e:	1f 92       	push	r1
    4a80:	11 24       	eor	r1, r1
    4a82:	2f 92       	push	r2
    4a84:	3f 92       	push	r3
    4a86:	4f 92       	push	r4
    4a88:	5f 92       	push	r5
    4a8a:	6f 92       	push	r6
    4a8c:	7f 92       	push	r7
    4a8e:	8f 92       	push	r8
    4a90:	9f 92       	push	r9
    4a92:	af 92       	push	r10
    4a94:	bf 92       	push	r11
    4a96:	cf 92       	push	r12
    4a98:	df 92       	push	r13
    4a9a:	ef 92       	push	r14
    4a9c:	ff 92       	push	r15
    4a9e:	0f 93       	push	r16
    4aa0:	1f 93       	push	r17
    4aa2:	2f 93       	push	r18
    4aa4:	3f 93       	push	r19
    4aa6:	4f 93       	push	r20
    4aa8:	5f 93       	push	r21
    4aaa:	6f 93       	push	r22
    4aac:	7f 93       	push	r23
    4aae:	8f 93       	push	r24
    4ab0:	9f 93       	push	r25
    4ab2:	af 93       	push	r26
    4ab4:	bf 93       	push	r27
    4ab6:	cf 93       	push	r28
    4ab8:	df 93       	push	r29
    4aba:	ef 93       	push	r30
    4abc:	ff 93       	push	r31
    4abe:	a0 91 9f 06 	lds	r26, 0x069F
    4ac2:	b0 91 a0 06 	lds	r27, 0x06A0
    4ac6:	0d b6       	in	r0, 0x3d	; 61
    4ac8:	0d 92       	st	X+, r0
    4aca:	0e b6       	in	r0, 0x3e	; 62
    4acc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    4ace:	0e 94 ab 2e 	call	0x5d56	; 0x5d56 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4ad2:	a0 91 9f 06 	lds	r26, 0x069F
    4ad6:	b0 91 a0 06 	lds	r27, 0x06A0
    4ada:	cd 91       	ld	r28, X+
    4adc:	cd bf       	out	0x3d, r28	; 61
    4ade:	dd 91       	ld	r29, X+
    4ae0:	de bf       	out	0x3e, r29	; 62
    4ae2:	ff 91       	pop	r31
    4ae4:	ef 91       	pop	r30
    4ae6:	df 91       	pop	r29
    4ae8:	cf 91       	pop	r28
    4aea:	bf 91       	pop	r27
    4aec:	af 91       	pop	r26
    4aee:	9f 91       	pop	r25
    4af0:	8f 91       	pop	r24
    4af2:	7f 91       	pop	r23
    4af4:	6f 91       	pop	r22
    4af6:	5f 91       	pop	r21
    4af8:	4f 91       	pop	r20
    4afa:	3f 91       	pop	r19
    4afc:	2f 91       	pop	r18
    4afe:	1f 91       	pop	r17
    4b00:	0f 91       	pop	r16
    4b02:	ff 90       	pop	r15
    4b04:	ef 90       	pop	r14
    4b06:	df 90       	pop	r13
    4b08:	cf 90       	pop	r12
    4b0a:	bf 90       	pop	r11
    4b0c:	af 90       	pop	r10
    4b0e:	9f 90       	pop	r9
    4b10:	8f 90       	pop	r8
    4b12:	7f 90       	pop	r7
    4b14:	6f 90       	pop	r6
    4b16:	5f 90       	pop	r5
    4b18:	4f 90       	pop	r4
    4b1a:	3f 90       	pop	r3
    4b1c:	2f 90       	pop	r2
    4b1e:	1f 90       	pop	r1
    4b20:	0f 90       	pop	r0
    4b22:	0f be       	out	0x3f, r0	; 63
    4b24:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4b26:	08 95       	ret

00004b28 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    4b28:	0f 92       	push	r0
    4b2a:	0f b6       	in	r0, 0x3f	; 63
    4b2c:	f8 94       	cli
    4b2e:	0f 92       	push	r0
    4b30:	1f 92       	push	r1
    4b32:	11 24       	eor	r1, r1
    4b34:	2f 92       	push	r2
    4b36:	3f 92       	push	r3
    4b38:	4f 92       	push	r4
    4b3a:	5f 92       	push	r5
    4b3c:	6f 92       	push	r6
    4b3e:	7f 92       	push	r7
    4b40:	8f 92       	push	r8
    4b42:	9f 92       	push	r9
    4b44:	af 92       	push	r10
    4b46:	bf 92       	push	r11
    4b48:	cf 92       	push	r12
    4b4a:	df 92       	push	r13
    4b4c:	ef 92       	push	r14
    4b4e:	ff 92       	push	r15
    4b50:	0f 93       	push	r16
    4b52:	1f 93       	push	r17
    4b54:	2f 93       	push	r18
    4b56:	3f 93       	push	r19
    4b58:	4f 93       	push	r20
    4b5a:	5f 93       	push	r21
    4b5c:	6f 93       	push	r22
    4b5e:	7f 93       	push	r23
    4b60:	8f 93       	push	r24
    4b62:	9f 93       	push	r25
    4b64:	af 93       	push	r26
    4b66:	bf 93       	push	r27
    4b68:	cf 93       	push	r28
    4b6a:	df 93       	push	r29
    4b6c:	ef 93       	push	r30
    4b6e:	ff 93       	push	r31
    4b70:	a0 91 9f 06 	lds	r26, 0x069F
    4b74:	b0 91 a0 06 	lds	r27, 0x06A0
    4b78:	0d b6       	in	r0, 0x3d	; 61
    4b7a:	0d 92       	st	X+, r0
    4b7c:	0e b6       	in	r0, 0x3e	; 62
    4b7e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    4b80:	0e 94 d6 2d 	call	0x5bac	; 0x5bac <vTaskIncrementTick>
	vTaskSwitchContext();
    4b84:	0e 94 ab 2e 	call	0x5d56	; 0x5d56 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4b88:	a0 91 9f 06 	lds	r26, 0x069F
    4b8c:	b0 91 a0 06 	lds	r27, 0x06A0
    4b90:	cd 91       	ld	r28, X+
    4b92:	cd bf       	out	0x3d, r28	; 61
    4b94:	dd 91       	ld	r29, X+
    4b96:	de bf       	out	0x3e, r29	; 62
    4b98:	ff 91       	pop	r31
    4b9a:	ef 91       	pop	r30
    4b9c:	df 91       	pop	r29
    4b9e:	cf 91       	pop	r28
    4ba0:	bf 91       	pop	r27
    4ba2:	af 91       	pop	r26
    4ba4:	9f 91       	pop	r25
    4ba6:	8f 91       	pop	r24
    4ba8:	7f 91       	pop	r23
    4baa:	6f 91       	pop	r22
    4bac:	5f 91       	pop	r21
    4bae:	4f 91       	pop	r20
    4bb0:	3f 91       	pop	r19
    4bb2:	2f 91       	pop	r18
    4bb4:	1f 91       	pop	r17
    4bb6:	0f 91       	pop	r16
    4bb8:	ff 90       	pop	r15
    4bba:	ef 90       	pop	r14
    4bbc:	df 90       	pop	r13
    4bbe:	cf 90       	pop	r12
    4bc0:	bf 90       	pop	r11
    4bc2:	af 90       	pop	r10
    4bc4:	9f 90       	pop	r9
    4bc6:	8f 90       	pop	r8
    4bc8:	7f 90       	pop	r7
    4bca:	6f 90       	pop	r6
    4bcc:	5f 90       	pop	r5
    4bce:	4f 90       	pop	r4
    4bd0:	3f 90       	pop	r3
    4bd2:	2f 90       	pop	r2
    4bd4:	1f 90       	pop	r1
    4bd6:	0f 90       	pop	r0
    4bd8:	0f be       	out	0x3f, r0	; 63
    4bda:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4bdc:	08 95       	ret

00004bde <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    4bde:	df 93       	push	r29
    4be0:	cf 93       	push	r28
    4be2:	00 d0       	rcall	.+0      	; 0x4be4 <prvSetupTimerInterrupt+0x6>
    4be4:	00 d0       	rcall	.+0      	; 0x4be6 <prvSetupTimerInterrupt+0x8>
    4be6:	00 d0       	rcall	.+0      	; 0x4be8 <prvSetupTimerInterrupt+0xa>
    4be8:	cd b7       	in	r28, 0x3d	; 61
    4bea:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    4bec:	80 e4       	ldi	r24, 0x40	; 64
    4bee:	9f e1       	ldi	r25, 0x1F	; 31
    4bf0:	a0 e0       	ldi	r26, 0x00	; 0
    4bf2:	b0 e0       	ldi	r27, 0x00	; 0
    4bf4:	8b 83       	std	Y+3, r24	; 0x03
    4bf6:	9c 83       	std	Y+4, r25	; 0x04
    4bf8:	ad 83       	std	Y+5, r26	; 0x05
    4bfa:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    4bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    4bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    4c00:	ad 81       	ldd	r26, Y+5	; 0x05
    4c02:	be 81       	ldd	r27, Y+6	; 0x06
    4c04:	68 94       	set
    4c06:	15 f8       	bld	r1, 5
    4c08:	b6 95       	lsr	r27
    4c0a:	a7 95       	ror	r26
    4c0c:	97 95       	ror	r25
    4c0e:	87 95       	ror	r24
    4c10:	16 94       	lsr	r1
    4c12:	d1 f7       	brne	.-12     	; 0x4c08 <prvSetupTimerInterrupt+0x2a>
    4c14:	8b 83       	std	Y+3, r24	; 0x03
    4c16:	9c 83       	std	Y+4, r25	; 0x04
    4c18:	ad 83       	std	Y+5, r26	; 0x05
    4c1a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    4c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c1e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c20:	ad 81       	ldd	r26, Y+5	; 0x05
    4c22:	be 81       	ldd	r27, Y+6	; 0x06
    4c24:	01 97       	sbiw	r24, 0x01	; 1
    4c26:	a1 09       	sbc	r26, r1
    4c28:	b1 09       	sbc	r27, r1
    4c2a:	8b 83       	std	Y+3, r24	; 0x03
    4c2c:	9c 83       	std	Y+4, r25	; 0x04
    4c2e:	ad 83       	std	Y+5, r26	; 0x05
    4c30:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    4c32:	8b 81       	ldd	r24, Y+3	; 0x03
    4c34:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    4c36:	8b 81       	ldd	r24, Y+3	; 0x03
    4c38:	9c 81       	ldd	r25, Y+4	; 0x04
    4c3a:	ad 81       	ldd	r26, Y+5	; 0x05
    4c3c:	be 81       	ldd	r27, Y+6	; 0x06
    4c3e:	89 2f       	mov	r24, r25
    4c40:	9a 2f       	mov	r25, r26
    4c42:	ab 2f       	mov	r26, r27
    4c44:	bb 27       	eor	r27, r27
    4c46:	8b 83       	std	Y+3, r24	; 0x03
    4c48:	9c 83       	std	Y+4, r25	; 0x04
    4c4a:	ad 83       	std	Y+5, r26	; 0x05
    4c4c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    4c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c50:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    4c52:	eb e4       	ldi	r30, 0x4B	; 75
    4c54:	f0 e0       	ldi	r31, 0x00	; 0
    4c56:	8a 81       	ldd	r24, Y+2	; 0x02
    4c58:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    4c5a:	ea e4       	ldi	r30, 0x4A	; 74
    4c5c:	f0 e0       	ldi	r31, 0x00	; 0
    4c5e:	89 81       	ldd	r24, Y+1	; 0x01
    4c60:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    4c62:	8b e0       	ldi	r24, 0x0B	; 11
    4c64:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    4c66:	ee e4       	ldi	r30, 0x4E	; 78
    4c68:	f0 e0       	ldi	r31, 0x00	; 0
    4c6a:	89 81       	ldd	r24, Y+1	; 0x01
    4c6c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    4c6e:	e9 e5       	ldi	r30, 0x59	; 89
    4c70:	f0 e0       	ldi	r31, 0x00	; 0
    4c72:	80 81       	ld	r24, Z
    4c74:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    4c76:	89 81       	ldd	r24, Y+1	; 0x01
    4c78:	80 61       	ori	r24, 0x10	; 16
    4c7a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    4c7c:	e9 e5       	ldi	r30, 0x59	; 89
    4c7e:	f0 e0       	ldi	r31, 0x00	; 0
    4c80:	89 81       	ldd	r24, Y+1	; 0x01
    4c82:	80 83       	st	Z, r24
}
    4c84:	26 96       	adiw	r28, 0x06	; 6
    4c86:	0f b6       	in	r0, 0x3f	; 63
    4c88:	f8 94       	cli
    4c8a:	de bf       	out	0x3e, r29	; 62
    4c8c:	0f be       	out	0x3f, r0	; 63
    4c8e:	cd bf       	out	0x3d, r28	; 61
    4c90:	cf 91       	pop	r28
    4c92:	df 91       	pop	r29
    4c94:	08 95       	ret

00004c96 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    4c96:	0e 94 94 25 	call	0x4b28	; 0x4b28 <vPortYieldFromTick>
		asm volatile ( "reti" );
    4c9a:	18 95       	reti

00004c9c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    4c9c:	df 93       	push	r29
    4c9e:	cf 93       	push	r28
    4ca0:	cd b7       	in	r28, 0x3d	; 61
    4ca2:	de b7       	in	r29, 0x3e	; 62
    4ca4:	28 97       	sbiw	r28, 0x08	; 8
    4ca6:	0f b6       	in	r0, 0x3f	; 63
    4ca8:	f8 94       	cli
    4caa:	de bf       	out	0x3e, r29	; 62
    4cac:	0f be       	out	0x3f, r0	; 63
    4cae:	cd bf       	out	0x3d, r28	; 61
    4cb0:	8f 83       	std	Y+7, r24	; 0x07
    4cb2:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    4cb4:	1a 82       	std	Y+2, r1	; 0x02
    4cb6:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    4cb8:	8f 81       	ldd	r24, Y+7	; 0x07
    4cba:	88 23       	and	r24, r24
    4cbc:	09 f4       	brne	.+2      	; 0x4cc0 <xQueueCreate+0x24>
    4cbe:	8c c0       	rjmp	.+280    	; 0x4dd8 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4cc0:	8f e1       	ldi	r24, 0x1F	; 31
    4cc2:	90 e0       	ldi	r25, 0x00	; 0
    4cc4:	0e 94 d5 21 	call	0x43aa	; 0x43aa <pvPortMalloc>
    4cc8:	9e 83       	std	Y+6, r25	; 0x06
    4cca:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    4ccc:	8d 81       	ldd	r24, Y+5	; 0x05
    4cce:	9e 81       	ldd	r25, Y+6	; 0x06
    4cd0:	00 97       	sbiw	r24, 0x00	; 0
    4cd2:	09 f4       	brne	.+2      	; 0x4cd6 <xQueueCreate+0x3a>
    4cd4:	81 c0       	rjmp	.+258    	; 0x4dd8 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    4cd6:	8f 81       	ldd	r24, Y+7	; 0x07
    4cd8:	28 2f       	mov	r18, r24
    4cda:	30 e0       	ldi	r19, 0x00	; 0
    4cdc:	88 85       	ldd	r24, Y+8	; 0x08
    4cde:	88 2f       	mov	r24, r24
    4ce0:	90 e0       	ldi	r25, 0x00	; 0
    4ce2:	ac 01       	movw	r20, r24
    4ce4:	24 9f       	mul	r18, r20
    4ce6:	c0 01       	movw	r24, r0
    4ce8:	25 9f       	mul	r18, r21
    4cea:	90 0d       	add	r25, r0
    4cec:	34 9f       	mul	r19, r20
    4cee:	90 0d       	add	r25, r0
    4cf0:	11 24       	eor	r1, r1
    4cf2:	01 96       	adiw	r24, 0x01	; 1
    4cf4:	9c 83       	std	Y+4, r25	; 0x04
    4cf6:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    4cfc:	0e 94 d5 21 	call	0x43aa	; 0x43aa <pvPortMalloc>
    4d00:	ed 81       	ldd	r30, Y+5	; 0x05
    4d02:	fe 81       	ldd	r31, Y+6	; 0x06
    4d04:	91 83       	std	Z+1, r25	; 0x01
    4d06:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    4d08:	ed 81       	ldd	r30, Y+5	; 0x05
    4d0a:	fe 81       	ldd	r31, Y+6	; 0x06
    4d0c:	80 81       	ld	r24, Z
    4d0e:	91 81       	ldd	r25, Z+1	; 0x01
    4d10:	00 97       	sbiw	r24, 0x00	; 0
    4d12:	09 f4       	brne	.+2      	; 0x4d16 <xQueueCreate+0x7a>
    4d14:	5d c0       	rjmp	.+186    	; 0x4dd0 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4d16:	ed 81       	ldd	r30, Y+5	; 0x05
    4d18:	fe 81       	ldd	r31, Y+6	; 0x06
    4d1a:	40 81       	ld	r20, Z
    4d1c:	51 81       	ldd	r21, Z+1	; 0x01
    4d1e:	8f 81       	ldd	r24, Y+7	; 0x07
    4d20:	28 2f       	mov	r18, r24
    4d22:	30 e0       	ldi	r19, 0x00	; 0
    4d24:	88 85       	ldd	r24, Y+8	; 0x08
    4d26:	88 2f       	mov	r24, r24
    4d28:	90 e0       	ldi	r25, 0x00	; 0
    4d2a:	bc 01       	movw	r22, r24
    4d2c:	26 9f       	mul	r18, r22
    4d2e:	c0 01       	movw	r24, r0
    4d30:	27 9f       	mul	r18, r23
    4d32:	90 0d       	add	r25, r0
    4d34:	36 9f       	mul	r19, r22
    4d36:	90 0d       	add	r25, r0
    4d38:	11 24       	eor	r1, r1
    4d3a:	84 0f       	add	r24, r20
    4d3c:	95 1f       	adc	r25, r21
    4d3e:	ed 81       	ldd	r30, Y+5	; 0x05
    4d40:	fe 81       	ldd	r31, Y+6	; 0x06
    4d42:	93 83       	std	Z+3, r25	; 0x03
    4d44:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    4d46:	ed 81       	ldd	r30, Y+5	; 0x05
    4d48:	fe 81       	ldd	r31, Y+6	; 0x06
    4d4a:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    4d4c:	ed 81       	ldd	r30, Y+5	; 0x05
    4d4e:	fe 81       	ldd	r31, Y+6	; 0x06
    4d50:	80 81       	ld	r24, Z
    4d52:	91 81       	ldd	r25, Z+1	; 0x01
    4d54:	ed 81       	ldd	r30, Y+5	; 0x05
    4d56:	fe 81       	ldd	r31, Y+6	; 0x06
    4d58:	95 83       	std	Z+5, r25	; 0x05
    4d5a:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    4d5c:	ed 81       	ldd	r30, Y+5	; 0x05
    4d5e:	fe 81       	ldd	r31, Y+6	; 0x06
    4d60:	40 81       	ld	r20, Z
    4d62:	51 81       	ldd	r21, Z+1	; 0x01
    4d64:	8f 81       	ldd	r24, Y+7	; 0x07
    4d66:	88 2f       	mov	r24, r24
    4d68:	90 e0       	ldi	r25, 0x00	; 0
    4d6a:	9c 01       	movw	r18, r24
    4d6c:	21 50       	subi	r18, 0x01	; 1
    4d6e:	30 40       	sbci	r19, 0x00	; 0
    4d70:	88 85       	ldd	r24, Y+8	; 0x08
    4d72:	88 2f       	mov	r24, r24
    4d74:	90 e0       	ldi	r25, 0x00	; 0
    4d76:	bc 01       	movw	r22, r24
    4d78:	26 9f       	mul	r18, r22
    4d7a:	c0 01       	movw	r24, r0
    4d7c:	27 9f       	mul	r18, r23
    4d7e:	90 0d       	add	r25, r0
    4d80:	36 9f       	mul	r19, r22
    4d82:	90 0d       	add	r25, r0
    4d84:	11 24       	eor	r1, r1
    4d86:	84 0f       	add	r24, r20
    4d88:	95 1f       	adc	r25, r21
    4d8a:	ed 81       	ldd	r30, Y+5	; 0x05
    4d8c:	fe 81       	ldd	r31, Y+6	; 0x06
    4d8e:	97 83       	std	Z+7, r25	; 0x07
    4d90:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    4d92:	ed 81       	ldd	r30, Y+5	; 0x05
    4d94:	fe 81       	ldd	r31, Y+6	; 0x06
    4d96:	8f 81       	ldd	r24, Y+7	; 0x07
    4d98:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    4d9a:	ed 81       	ldd	r30, Y+5	; 0x05
    4d9c:	fe 81       	ldd	r31, Y+6	; 0x06
    4d9e:	88 85       	ldd	r24, Y+8	; 0x08
    4da0:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    4da2:	ed 81       	ldd	r30, Y+5	; 0x05
    4da4:	fe 81       	ldd	r31, Y+6	; 0x06
    4da6:	8f ef       	ldi	r24, 0xFF	; 255
    4da8:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    4daa:	ed 81       	ldd	r30, Y+5	; 0x05
    4dac:	fe 81       	ldd	r31, Y+6	; 0x06
    4dae:	8f ef       	ldi	r24, 0xFF	; 255
    4db0:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4db2:	8d 81       	ldd	r24, Y+5	; 0x05
    4db4:	9e 81       	ldd	r25, Y+6	; 0x06
    4db6:	08 96       	adiw	r24, 0x08	; 8
    4db8:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    4dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    4dbe:	9e 81       	ldd	r25, Y+6	; 0x06
    4dc0:	41 96       	adiw	r24, 0x11	; 17
    4dc2:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    4dc6:	8d 81       	ldd	r24, Y+5	; 0x05
    4dc8:	9e 81       	ldd	r25, Y+6	; 0x06
    4dca:	9a 83       	std	Y+2, r25	; 0x02
    4dcc:	89 83       	std	Y+1, r24	; 0x01
    4dce:	04 c0       	rjmp	.+8      	; 0x4dd8 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    4dd0:	8d 81       	ldd	r24, Y+5	; 0x05
    4dd2:	9e 81       	ldd	r25, Y+6	; 0x06
    4dd4:	0e 94 1b 22 	call	0x4436	; 0x4436 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    4dd8:	89 81       	ldd	r24, Y+1	; 0x01
    4dda:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4ddc:	28 96       	adiw	r28, 0x08	; 8
    4dde:	0f b6       	in	r0, 0x3f	; 63
    4de0:	f8 94       	cli
    4de2:	de bf       	out	0x3e, r29	; 62
    4de4:	0f be       	out	0x3f, r0	; 63
    4de6:	cd bf       	out	0x3d, r28	; 61
    4de8:	cf 91       	pop	r28
    4dea:	df 91       	pop	r29
    4dec:	08 95       	ret

00004dee <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    4dee:	df 93       	push	r29
    4df0:	cf 93       	push	r28
    4df2:	cd b7       	in	r28, 0x3d	; 61
    4df4:	de b7       	in	r29, 0x3e	; 62
    4df6:	2c 97       	sbiw	r28, 0x0c	; 12
    4df8:	0f b6       	in	r0, 0x3f	; 63
    4dfa:	f8 94       	cli
    4dfc:	de bf       	out	0x3e, r29	; 62
    4dfe:	0f be       	out	0x3f, r0	; 63
    4e00:	cd bf       	out	0x3d, r28	; 61
    4e02:	9e 83       	std	Y+6, r25	; 0x06
    4e04:	8d 83       	std	Y+5, r24	; 0x05
    4e06:	78 87       	std	Y+8, r23	; 0x08
    4e08:	6f 83       	std	Y+7, r22	; 0x07
    4e0a:	5a 87       	std	Y+10, r21	; 0x0a
    4e0c:	49 87       	std	Y+9, r20	; 0x09
    4e0e:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4e10:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4e12:	0f b6       	in	r0, 0x3f	; 63
    4e14:	f8 94       	cli
    4e16:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4e18:	ed 81       	ldd	r30, Y+5	; 0x05
    4e1a:	fe 81       	ldd	r31, Y+6	; 0x06
    4e1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    4e1e:	ed 81       	ldd	r30, Y+5	; 0x05
    4e20:	fe 81       	ldd	r31, Y+6	; 0x06
    4e22:	83 8d       	ldd	r24, Z+27	; 0x1b
    4e24:	98 17       	cp	r25, r24
    4e26:	d8 f4       	brcc	.+54     	; 0x4e5e <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4e28:	8d 81       	ldd	r24, Y+5	; 0x05
    4e2a:	9e 81       	ldd	r25, Y+6	; 0x06
    4e2c:	2f 81       	ldd	r18, Y+7	; 0x07
    4e2e:	38 85       	ldd	r19, Y+8	; 0x08
    4e30:	b9 01       	movw	r22, r18
    4e32:	4b 85       	ldd	r20, Y+11	; 0x0b
    4e34:	0e 94 32 29 	call	0x5264	; 0x5264 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4e38:	ed 81       	ldd	r30, Y+5	; 0x05
    4e3a:	fe 81       	ldd	r31, Y+6	; 0x06
    4e3c:	81 89       	ldd	r24, Z+17	; 0x11
    4e3e:	88 23       	and	r24, r24
    4e40:	49 f0       	breq	.+18     	; 0x4e54 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    4e42:	8d 81       	ldd	r24, Y+5	; 0x05
    4e44:	9e 81       	ldd	r25, Y+6	; 0x06
    4e46:	41 96       	adiw	r24, 0x11	; 17
    4e48:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    4e4c:	81 30       	cpi	r24, 0x01	; 1
    4e4e:	11 f4       	brne	.+4      	; 0x4e54 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    4e50:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    4e54:	0f 90       	pop	r0
    4e56:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    4e58:	81 e0       	ldi	r24, 0x01	; 1
    4e5a:	8c 87       	std	Y+12, r24	; 0x0c
    4e5c:	5c c0       	rjmp	.+184    	; 0x4f16 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    4e5e:	89 85       	ldd	r24, Y+9	; 0x09
    4e60:	9a 85       	ldd	r25, Y+10	; 0x0a
    4e62:	00 97       	sbiw	r24, 0x00	; 0
    4e64:	21 f4       	brne	.+8      	; 0x4e6e <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4e66:	0f 90       	pop	r0
    4e68:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    4e6a:	1c 86       	std	Y+12, r1	; 0x0c
    4e6c:	54 c0       	rjmp	.+168    	; 0x4f16 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    4e6e:	89 81       	ldd	r24, Y+1	; 0x01
    4e70:	88 23       	and	r24, r24
    4e72:	31 f4       	brne	.+12     	; 0x4e80 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4e74:	ce 01       	movw	r24, r28
    4e76:	02 96       	adiw	r24, 0x02	; 2
    4e78:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4e7c:	81 e0       	ldi	r24, 0x01	; 1
    4e7e:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    4e80:	0f 90       	pop	r0
    4e82:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4e84:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4e88:	0f b6       	in	r0, 0x3f	; 63
    4e8a:	f8 94       	cli
    4e8c:	0f 92       	push	r0
    4e8e:	ed 81       	ldd	r30, Y+5	; 0x05
    4e90:	fe 81       	ldd	r31, Y+6	; 0x06
    4e92:	85 8d       	ldd	r24, Z+29	; 0x1d
    4e94:	8f 3f       	cpi	r24, 0xFF	; 255
    4e96:	19 f4       	brne	.+6      	; 0x4e9e <xQueueGenericSend+0xb0>
    4e98:	ed 81       	ldd	r30, Y+5	; 0x05
    4e9a:	fe 81       	ldd	r31, Y+6	; 0x06
    4e9c:	15 8e       	std	Z+29, r1	; 0x1d
    4e9e:	ed 81       	ldd	r30, Y+5	; 0x05
    4ea0:	fe 81       	ldd	r31, Y+6	; 0x06
    4ea2:	86 8d       	ldd	r24, Z+30	; 0x1e
    4ea4:	8f 3f       	cpi	r24, 0xFF	; 255
    4ea6:	19 f4       	brne	.+6      	; 0x4eae <xQueueGenericSend+0xc0>
    4ea8:	ed 81       	ldd	r30, Y+5	; 0x05
    4eaa:	fe 81       	ldd	r31, Y+6	; 0x06
    4eac:	16 8e       	std	Z+30, r1	; 0x1e
    4eae:	0f 90       	pop	r0
    4eb0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4eb2:	ce 01       	movw	r24, r28
    4eb4:	02 96       	adiw	r24, 0x02	; 2
    4eb6:	9e 01       	movw	r18, r28
    4eb8:	27 5f       	subi	r18, 0xF7	; 247
    4eba:	3f 4f       	sbci	r19, 0xFF	; 255
    4ebc:	b9 01       	movw	r22, r18
    4ebe:	0e 94 c8 2f 	call	0x5f90	; 0x5f90 <xTaskCheckForTimeOut>
    4ec2:	88 23       	and	r24, r24
    4ec4:	09 f5       	brne	.+66     	; 0x4f08 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4ec6:	8d 81       	ldd	r24, Y+5	; 0x05
    4ec8:	9e 81       	ldd	r25, Y+6	; 0x06
    4eca:	0e 94 96 2a 	call	0x552c	; 0x552c <prvIsQueueFull>
    4ece:	88 23       	and	r24, r24
    4ed0:	a1 f0       	breq	.+40     	; 0x4efa <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4ed2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed4:	9e 81       	ldd	r25, Y+6	; 0x06
    4ed6:	08 96       	adiw	r24, 0x08	; 8
    4ed8:	29 85       	ldd	r18, Y+9	; 0x09
    4eda:	3a 85       	ldd	r19, Y+10	; 0x0a
    4edc:	b9 01       	movw	r22, r18
    4ede:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4ee2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ee4:	9e 81       	ldd	r25, Y+6	; 0x06
    4ee6:	0e 94 0f 2a 	call	0x541e	; 0x541e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    4eea:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
    4eee:	88 23       	and	r24, r24
    4ef0:	09 f0       	breq	.+2      	; 0x4ef4 <xQueueGenericSend+0x106>
    4ef2:	8f cf       	rjmp	.-226    	; 0x4e12 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    4ef4:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
    4ef8:	8c cf       	rjmp	.-232    	; 0x4e12 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4efa:	8d 81       	ldd	r24, Y+5	; 0x05
    4efc:	9e 81       	ldd	r25, Y+6	; 0x06
    4efe:	0e 94 0f 2a 	call	0x541e	; 0x541e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4f02:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
    4f06:	85 cf       	rjmp	.-246    	; 0x4e12 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    4f08:	8d 81       	ldd	r24, Y+5	; 0x05
    4f0a:	9e 81       	ldd	r25, Y+6	; 0x06
    4f0c:	0e 94 0f 2a 	call	0x541e	; 0x541e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4f10:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4f14:	1c 86       	std	Y+12, r1	; 0x0c
    4f16:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    4f18:	2c 96       	adiw	r28, 0x0c	; 12
    4f1a:	0f b6       	in	r0, 0x3f	; 63
    4f1c:	f8 94       	cli
    4f1e:	de bf       	out	0x3e, r29	; 62
    4f20:	0f be       	out	0x3f, r0	; 63
    4f22:	cd bf       	out	0x3d, r28	; 61
    4f24:	cf 91       	pop	r28
    4f26:	df 91       	pop	r29
    4f28:	08 95       	ret

00004f2a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    4f2a:	df 93       	push	r29
    4f2c:	cf 93       	push	r28
    4f2e:	cd b7       	in	r28, 0x3d	; 61
    4f30:	de b7       	in	r29, 0x3e	; 62
    4f32:	29 97       	sbiw	r28, 0x09	; 9
    4f34:	0f b6       	in	r0, 0x3f	; 63
    4f36:	f8 94       	cli
    4f38:	de bf       	out	0x3e, r29	; 62
    4f3a:	0f be       	out	0x3f, r0	; 63
    4f3c:	cd bf       	out	0x3d, r28	; 61
    4f3e:	9c 83       	std	Y+4, r25	; 0x04
    4f40:	8b 83       	std	Y+3, r24	; 0x03
    4f42:	7e 83       	std	Y+6, r23	; 0x06
    4f44:	6d 83       	std	Y+5, r22	; 0x05
    4f46:	58 87       	std	Y+8, r21	; 0x08
    4f48:	4f 83       	std	Y+7, r20	; 0x07
    4f4a:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f4c:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f50:	fc 81       	ldd	r31, Y+4	; 0x04
    4f52:	92 8d       	ldd	r25, Z+26	; 0x1a
    4f54:	eb 81       	ldd	r30, Y+3	; 0x03
    4f56:	fc 81       	ldd	r31, Y+4	; 0x04
    4f58:	83 8d       	ldd	r24, Z+27	; 0x1b
    4f5a:	98 17       	cp	r25, r24
    4f5c:	40 f5       	brcc	.+80     	; 0x4fae <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f60:	9c 81       	ldd	r25, Y+4	; 0x04
    4f62:	2d 81       	ldd	r18, Y+5	; 0x05
    4f64:	3e 81       	ldd	r19, Y+6	; 0x06
    4f66:	b9 01       	movw	r22, r18
    4f68:	49 85       	ldd	r20, Y+9	; 0x09
    4f6a:	0e 94 32 29 	call	0x5264	; 0x5264 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    4f6e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f70:	fc 81       	ldd	r31, Y+4	; 0x04
    4f72:	86 8d       	ldd	r24, Z+30	; 0x1e
    4f74:	8f 3f       	cpi	r24, 0xFF	; 255
    4f76:	89 f4       	brne	.+34     	; 0x4f9a <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4f78:	eb 81       	ldd	r30, Y+3	; 0x03
    4f7a:	fc 81       	ldd	r31, Y+4	; 0x04
    4f7c:	81 89       	ldd	r24, Z+17	; 0x11
    4f7e:	88 23       	and	r24, r24
    4f80:	99 f0       	breq	.+38     	; 0x4fa8 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4f82:	8b 81       	ldd	r24, Y+3	; 0x03
    4f84:	9c 81       	ldd	r25, Y+4	; 0x04
    4f86:	41 96       	adiw	r24, 0x11	; 17
    4f88:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    4f8c:	88 23       	and	r24, r24
    4f8e:	61 f0       	breq	.+24     	; 0x4fa8 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    4f90:	ef 81       	ldd	r30, Y+7	; 0x07
    4f92:	f8 85       	ldd	r31, Y+8	; 0x08
    4f94:	81 e0       	ldi	r24, 0x01	; 1
    4f96:	80 83       	st	Z, r24
    4f98:	07 c0       	rjmp	.+14     	; 0x4fa8 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    4f9a:	eb 81       	ldd	r30, Y+3	; 0x03
    4f9c:	fc 81       	ldd	r31, Y+4	; 0x04
    4f9e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4fa0:	8f 5f       	subi	r24, 0xFF	; 255
    4fa2:	eb 81       	ldd	r30, Y+3	; 0x03
    4fa4:	fc 81       	ldd	r31, Y+4	; 0x04
    4fa6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4fa8:	81 e0       	ldi	r24, 0x01	; 1
    4faa:	8a 83       	std	Y+2, r24	; 0x02
    4fac:	01 c0       	rjmp	.+2      	; 0x4fb0 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4fae:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4fb0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4fb2:	29 96       	adiw	r28, 0x09	; 9
    4fb4:	0f b6       	in	r0, 0x3f	; 63
    4fb6:	f8 94       	cli
    4fb8:	de bf       	out	0x3e, r29	; 62
    4fba:	0f be       	out	0x3f, r0	; 63
    4fbc:	cd bf       	out	0x3d, r28	; 61
    4fbe:	cf 91       	pop	r28
    4fc0:	df 91       	pop	r29
    4fc2:	08 95       	ret

00004fc4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    4fc4:	df 93       	push	r29
    4fc6:	cf 93       	push	r28
    4fc8:	cd b7       	in	r28, 0x3d	; 61
    4fca:	de b7       	in	r29, 0x3e	; 62
    4fcc:	2e 97       	sbiw	r28, 0x0e	; 14
    4fce:	0f b6       	in	r0, 0x3f	; 63
    4fd0:	f8 94       	cli
    4fd2:	de bf       	out	0x3e, r29	; 62
    4fd4:	0f be       	out	0x3f, r0	; 63
    4fd6:	cd bf       	out	0x3d, r28	; 61
    4fd8:	98 87       	std	Y+8, r25	; 0x08
    4fda:	8f 83       	std	Y+7, r24	; 0x07
    4fdc:	7a 87       	std	Y+10, r23	; 0x0a
    4fde:	69 87       	std	Y+9, r22	; 0x09
    4fe0:	5c 87       	std	Y+12, r21	; 0x0c
    4fe2:	4b 87       	std	Y+11, r20	; 0x0b
    4fe4:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4fe6:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    4fe8:	0f b6       	in	r0, 0x3f	; 63
    4fea:	f8 94       	cli
    4fec:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    4fee:	ef 81       	ldd	r30, Y+7	; 0x07
    4ff0:	f8 85       	ldd	r31, Y+8	; 0x08
    4ff2:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ff4:	88 23       	and	r24, r24
    4ff6:	09 f4       	brne	.+2      	; 0x4ffa <xQueueGenericReceive+0x36>
    4ff8:	3f c0       	rjmp	.+126    	; 0x5078 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    4ffa:	ef 81       	ldd	r30, Y+7	; 0x07
    4ffc:	f8 85       	ldd	r31, Y+8	; 0x08
    4ffe:	86 81       	ldd	r24, Z+6	; 0x06
    5000:	97 81       	ldd	r25, Z+7	; 0x07
    5002:	9a 83       	std	Y+2, r25	; 0x02
    5004:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5006:	8f 81       	ldd	r24, Y+7	; 0x07
    5008:	98 85       	ldd	r25, Y+8	; 0x08
    500a:	29 85       	ldd	r18, Y+9	; 0x09
    500c:	3a 85       	ldd	r19, Y+10	; 0x0a
    500e:	b9 01       	movw	r22, r18
    5010:	0e 94 c7 29 	call	0x538e	; 0x538e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    5014:	8d 85       	ldd	r24, Y+13	; 0x0d
    5016:	88 23       	and	r24, r24
    5018:	b1 f4       	brne	.+44     	; 0x5046 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    501a:	ef 81       	ldd	r30, Y+7	; 0x07
    501c:	f8 85       	ldd	r31, Y+8	; 0x08
    501e:	82 8d       	ldd	r24, Z+26	; 0x1a
    5020:	81 50       	subi	r24, 0x01	; 1
    5022:	ef 81       	ldd	r30, Y+7	; 0x07
    5024:	f8 85       	ldd	r31, Y+8	; 0x08
    5026:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5028:	ef 81       	ldd	r30, Y+7	; 0x07
    502a:	f8 85       	ldd	r31, Y+8	; 0x08
    502c:	80 85       	ldd	r24, Z+8	; 0x08
    502e:	88 23       	and	r24, r24
    5030:	f1 f0       	breq	.+60     	; 0x506e <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    5032:	8f 81       	ldd	r24, Y+7	; 0x07
    5034:	98 85       	ldd	r25, Y+8	; 0x08
    5036:	08 96       	adiw	r24, 0x08	; 8
    5038:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    503c:	81 30       	cpi	r24, 0x01	; 1
    503e:	b9 f4       	brne	.+46     	; 0x506e <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    5040:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
    5044:	14 c0       	rjmp	.+40     	; 0x506e <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    5046:	ef 81       	ldd	r30, Y+7	; 0x07
    5048:	f8 85       	ldd	r31, Y+8	; 0x08
    504a:	89 81       	ldd	r24, Y+1	; 0x01
    504c:	9a 81       	ldd	r25, Y+2	; 0x02
    504e:	97 83       	std	Z+7, r25	; 0x07
    5050:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5052:	ef 81       	ldd	r30, Y+7	; 0x07
    5054:	f8 85       	ldd	r31, Y+8	; 0x08
    5056:	81 89       	ldd	r24, Z+17	; 0x11
    5058:	88 23       	and	r24, r24
    505a:	49 f0       	breq	.+18     	; 0x506e <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    505c:	8f 81       	ldd	r24, Y+7	; 0x07
    505e:	98 85       	ldd	r25, Y+8	; 0x08
    5060:	41 96       	adiw	r24, 0x11	; 17
    5062:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    5066:	88 23       	and	r24, r24
    5068:	11 f0       	breq	.+4      	; 0x506e <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    506a:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    506e:	0f 90       	pop	r0
    5070:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5072:	81 e0       	ldi	r24, 0x01	; 1
    5074:	8e 87       	std	Y+14, r24	; 0x0e
    5076:	5c c0       	rjmp	.+184    	; 0x5130 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5078:	8b 85       	ldd	r24, Y+11	; 0x0b
    507a:	9c 85       	ldd	r25, Y+12	; 0x0c
    507c:	00 97       	sbiw	r24, 0x00	; 0
    507e:	21 f4       	brne	.+8      	; 0x5088 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5080:	0f 90       	pop	r0
    5082:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5084:	1e 86       	std	Y+14, r1	; 0x0e
    5086:	54 c0       	rjmp	.+168    	; 0x5130 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    5088:	8b 81       	ldd	r24, Y+3	; 0x03
    508a:	88 23       	and	r24, r24
    508c:	31 f4       	brne	.+12     	; 0x509a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    508e:	ce 01       	movw	r24, r28
    5090:	04 96       	adiw	r24, 0x04	; 4
    5092:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5096:	81 e0       	ldi	r24, 0x01	; 1
    5098:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    509a:	0f 90       	pop	r0
    509c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    509e:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    50a2:	0f b6       	in	r0, 0x3f	; 63
    50a4:	f8 94       	cli
    50a6:	0f 92       	push	r0
    50a8:	ef 81       	ldd	r30, Y+7	; 0x07
    50aa:	f8 85       	ldd	r31, Y+8	; 0x08
    50ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    50ae:	8f 3f       	cpi	r24, 0xFF	; 255
    50b0:	19 f4       	brne	.+6      	; 0x50b8 <xQueueGenericReceive+0xf4>
    50b2:	ef 81       	ldd	r30, Y+7	; 0x07
    50b4:	f8 85       	ldd	r31, Y+8	; 0x08
    50b6:	15 8e       	std	Z+29, r1	; 0x1d
    50b8:	ef 81       	ldd	r30, Y+7	; 0x07
    50ba:	f8 85       	ldd	r31, Y+8	; 0x08
    50bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    50be:	8f 3f       	cpi	r24, 0xFF	; 255
    50c0:	19 f4       	brne	.+6      	; 0x50c8 <xQueueGenericReceive+0x104>
    50c2:	ef 81       	ldd	r30, Y+7	; 0x07
    50c4:	f8 85       	ldd	r31, Y+8	; 0x08
    50c6:	16 8e       	std	Z+30, r1	; 0x1e
    50c8:	0f 90       	pop	r0
    50ca:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    50cc:	ce 01       	movw	r24, r28
    50ce:	04 96       	adiw	r24, 0x04	; 4
    50d0:	9e 01       	movw	r18, r28
    50d2:	25 5f       	subi	r18, 0xF5	; 245
    50d4:	3f 4f       	sbci	r19, 0xFF	; 255
    50d6:	b9 01       	movw	r22, r18
    50d8:	0e 94 c8 2f 	call	0x5f90	; 0x5f90 <xTaskCheckForTimeOut>
    50dc:	88 23       	and	r24, r24
    50de:	09 f5       	brne	.+66     	; 0x5122 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    50e0:	8f 81       	ldd	r24, Y+7	; 0x07
    50e2:	98 85       	ldd	r25, Y+8	; 0x08
    50e4:	0e 94 63 2a 	call	0x54c6	; 0x54c6 <prvIsQueueEmpty>
    50e8:	88 23       	and	r24, r24
    50ea:	a1 f0       	breq	.+40     	; 0x5114 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    50ec:	8f 81       	ldd	r24, Y+7	; 0x07
    50ee:	98 85       	ldd	r25, Y+8	; 0x08
    50f0:	41 96       	adiw	r24, 0x11	; 17
    50f2:	2b 85       	ldd	r18, Y+11	; 0x0b
    50f4:	3c 85       	ldd	r19, Y+12	; 0x0c
    50f6:	b9 01       	movw	r22, r18
    50f8:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    50fc:	8f 81       	ldd	r24, Y+7	; 0x07
    50fe:	98 85       	ldd	r25, Y+8	; 0x08
    5100:	0e 94 0f 2a 	call	0x541e	; 0x541e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5104:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
    5108:	88 23       	and	r24, r24
    510a:	09 f0       	breq	.+2      	; 0x510e <xQueueGenericReceive+0x14a>
    510c:	6d cf       	rjmp	.-294    	; 0x4fe8 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    510e:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
    5112:	6a cf       	rjmp	.-300    	; 0x4fe8 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5114:	8f 81       	ldd	r24, Y+7	; 0x07
    5116:	98 85       	ldd	r25, Y+8	; 0x08
    5118:	0e 94 0f 2a 	call	0x541e	; 0x541e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    511c:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
    5120:	63 cf       	rjmp	.-314    	; 0x4fe8 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    5122:	8f 81       	ldd	r24, Y+7	; 0x07
    5124:	98 85       	ldd	r25, Y+8	; 0x08
    5126:	0e 94 0f 2a 	call	0x541e	; 0x541e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    512a:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    512e:	1e 86       	std	Y+14, r1	; 0x0e
    5130:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    5132:	2e 96       	adiw	r28, 0x0e	; 14
    5134:	0f b6       	in	r0, 0x3f	; 63
    5136:	f8 94       	cli
    5138:	de bf       	out	0x3e, r29	; 62
    513a:	0f be       	out	0x3f, r0	; 63
    513c:	cd bf       	out	0x3d, r28	; 61
    513e:	cf 91       	pop	r28
    5140:	df 91       	pop	r29
    5142:	08 95       	ret

00005144 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    5144:	df 93       	push	r29
    5146:	cf 93       	push	r28
    5148:	cd b7       	in	r28, 0x3d	; 61
    514a:	de b7       	in	r29, 0x3e	; 62
    514c:	28 97       	sbiw	r28, 0x08	; 8
    514e:	0f b6       	in	r0, 0x3f	; 63
    5150:	f8 94       	cli
    5152:	de bf       	out	0x3e, r29	; 62
    5154:	0f be       	out	0x3f, r0	; 63
    5156:	cd bf       	out	0x3d, r28	; 61
    5158:	9c 83       	std	Y+4, r25	; 0x04
    515a:	8b 83       	std	Y+3, r24	; 0x03
    515c:	7e 83       	std	Y+6, r23	; 0x06
    515e:	6d 83       	std	Y+5, r22	; 0x05
    5160:	58 87       	std	Y+8, r21	; 0x08
    5162:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5164:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5166:	eb 81       	ldd	r30, Y+3	; 0x03
    5168:	fc 81       	ldd	r31, Y+4	; 0x04
    516a:	82 8d       	ldd	r24, Z+26	; 0x1a
    516c:	88 23       	and	r24, r24
    516e:	71 f1       	breq	.+92     	; 0x51cc <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    5170:	8b 81       	ldd	r24, Y+3	; 0x03
    5172:	9c 81       	ldd	r25, Y+4	; 0x04
    5174:	2d 81       	ldd	r18, Y+5	; 0x05
    5176:	3e 81       	ldd	r19, Y+6	; 0x06
    5178:	b9 01       	movw	r22, r18
    517a:	0e 94 c7 29 	call	0x538e	; 0x538e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    517e:	eb 81       	ldd	r30, Y+3	; 0x03
    5180:	fc 81       	ldd	r31, Y+4	; 0x04
    5182:	82 8d       	ldd	r24, Z+26	; 0x1a
    5184:	81 50       	subi	r24, 0x01	; 1
    5186:	eb 81       	ldd	r30, Y+3	; 0x03
    5188:	fc 81       	ldd	r31, Y+4	; 0x04
    518a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    518c:	eb 81       	ldd	r30, Y+3	; 0x03
    518e:	fc 81       	ldd	r31, Y+4	; 0x04
    5190:	85 8d       	ldd	r24, Z+29	; 0x1d
    5192:	8f 3f       	cpi	r24, 0xFF	; 255
    5194:	89 f4       	brne	.+34     	; 0x51b8 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5196:	eb 81       	ldd	r30, Y+3	; 0x03
    5198:	fc 81       	ldd	r31, Y+4	; 0x04
    519a:	80 85       	ldd	r24, Z+8	; 0x08
    519c:	88 23       	and	r24, r24
    519e:	99 f0       	breq	.+38     	; 0x51c6 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    51a0:	8b 81       	ldd	r24, Y+3	; 0x03
    51a2:	9c 81       	ldd	r25, Y+4	; 0x04
    51a4:	08 96       	adiw	r24, 0x08	; 8
    51a6:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    51aa:	88 23       	and	r24, r24
    51ac:	61 f0       	breq	.+24     	; 0x51c6 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    51ae:	ef 81       	ldd	r30, Y+7	; 0x07
    51b0:	f8 85       	ldd	r31, Y+8	; 0x08
    51b2:	81 e0       	ldi	r24, 0x01	; 1
    51b4:	80 83       	st	Z, r24
    51b6:	07 c0       	rjmp	.+14     	; 0x51c6 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    51b8:	eb 81       	ldd	r30, Y+3	; 0x03
    51ba:	fc 81       	ldd	r31, Y+4	; 0x04
    51bc:	85 8d       	ldd	r24, Z+29	; 0x1d
    51be:	8f 5f       	subi	r24, 0xFF	; 255
    51c0:	eb 81       	ldd	r30, Y+3	; 0x03
    51c2:	fc 81       	ldd	r31, Y+4	; 0x04
    51c4:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    51c6:	81 e0       	ldi	r24, 0x01	; 1
    51c8:	8a 83       	std	Y+2, r24	; 0x02
    51ca:	01 c0       	rjmp	.+2      	; 0x51ce <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    51cc:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    51ce:	8a 81       	ldd	r24, Y+2	; 0x02
}
    51d0:	28 96       	adiw	r28, 0x08	; 8
    51d2:	0f b6       	in	r0, 0x3f	; 63
    51d4:	f8 94       	cli
    51d6:	de bf       	out	0x3e, r29	; 62
    51d8:	0f be       	out	0x3f, r0	; 63
    51da:	cd bf       	out	0x3d, r28	; 61
    51dc:	cf 91       	pop	r28
    51de:	df 91       	pop	r29
    51e0:	08 95       	ret

000051e2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    51e2:	df 93       	push	r29
    51e4:	cf 93       	push	r28
    51e6:	00 d0       	rcall	.+0      	; 0x51e8 <uxQueueMessagesWaiting+0x6>
    51e8:	0f 92       	push	r0
    51ea:	cd b7       	in	r28, 0x3d	; 61
    51ec:	de b7       	in	r29, 0x3e	; 62
    51ee:	9b 83       	std	Y+3, r25	; 0x03
    51f0:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    51f2:	0f b6       	in	r0, 0x3f	; 63
    51f4:	f8 94       	cli
    51f6:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    51f8:	ea 81       	ldd	r30, Y+2	; 0x02
    51fa:	fb 81       	ldd	r31, Y+3	; 0x03
    51fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    51fe:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5200:	0f 90       	pop	r0
    5202:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    5204:	89 81       	ldd	r24, Y+1	; 0x01
}
    5206:	0f 90       	pop	r0
    5208:	0f 90       	pop	r0
    520a:	0f 90       	pop	r0
    520c:	cf 91       	pop	r28
    520e:	df 91       	pop	r29
    5210:	08 95       	ret

00005212 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    5212:	df 93       	push	r29
    5214:	cf 93       	push	r28
    5216:	00 d0       	rcall	.+0      	; 0x5218 <uxQueueMessagesWaitingFromISR+0x6>
    5218:	0f 92       	push	r0
    521a:	cd b7       	in	r28, 0x3d	; 61
    521c:	de b7       	in	r29, 0x3e	; 62
    521e:	9b 83       	std	Y+3, r25	; 0x03
    5220:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    5222:	ea 81       	ldd	r30, Y+2	; 0x02
    5224:	fb 81       	ldd	r31, Y+3	; 0x03
    5226:	82 8d       	ldd	r24, Z+26	; 0x1a
    5228:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    522a:	89 81       	ldd	r24, Y+1	; 0x01
}
    522c:	0f 90       	pop	r0
    522e:	0f 90       	pop	r0
    5230:	0f 90       	pop	r0
    5232:	cf 91       	pop	r28
    5234:	df 91       	pop	r29
    5236:	08 95       	ret

00005238 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    5238:	df 93       	push	r29
    523a:	cf 93       	push	r28
    523c:	00 d0       	rcall	.+0      	; 0x523e <vQueueDelete+0x6>
    523e:	cd b7       	in	r28, 0x3d	; 61
    5240:	de b7       	in	r29, 0x3e	; 62
    5242:	9a 83       	std	Y+2, r25	; 0x02
    5244:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    5246:	e9 81       	ldd	r30, Y+1	; 0x01
    5248:	fa 81       	ldd	r31, Y+2	; 0x02
    524a:	80 81       	ld	r24, Z
    524c:	91 81       	ldd	r25, Z+1	; 0x01
    524e:	0e 94 1b 22 	call	0x4436	; 0x4436 <vPortFree>
	vPortFree( pxQueue );
    5252:	89 81       	ldd	r24, Y+1	; 0x01
    5254:	9a 81       	ldd	r25, Y+2	; 0x02
    5256:	0e 94 1b 22 	call	0x4436	; 0x4436 <vPortFree>
}
    525a:	0f 90       	pop	r0
    525c:	0f 90       	pop	r0
    525e:	cf 91       	pop	r28
    5260:	df 91       	pop	r29
    5262:	08 95       	ret

00005264 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    5264:	df 93       	push	r29
    5266:	cf 93       	push	r28
    5268:	00 d0       	rcall	.+0      	; 0x526a <prvCopyDataToQueue+0x6>
    526a:	00 d0       	rcall	.+0      	; 0x526c <prvCopyDataToQueue+0x8>
    526c:	0f 92       	push	r0
    526e:	cd b7       	in	r28, 0x3d	; 61
    5270:	de b7       	in	r29, 0x3e	; 62
    5272:	9a 83       	std	Y+2, r25	; 0x02
    5274:	89 83       	std	Y+1, r24	; 0x01
    5276:	7c 83       	std	Y+4, r23	; 0x04
    5278:	6b 83       	std	Y+3, r22	; 0x03
    527a:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    527c:	e9 81       	ldd	r30, Y+1	; 0x01
    527e:	fa 81       	ldd	r31, Y+2	; 0x02
    5280:	84 8d       	ldd	r24, Z+28	; 0x1c
    5282:	88 23       	and	r24, r24
    5284:	09 f4       	brne	.+2      	; 0x5288 <prvCopyDataToQueue+0x24>
    5286:	74 c0       	rjmp	.+232    	; 0x5370 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    5288:	8d 81       	ldd	r24, Y+5	; 0x05
    528a:	88 23       	and	r24, r24
    528c:	99 f5       	brne	.+102    	; 0x52f4 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    528e:	e9 81       	ldd	r30, Y+1	; 0x01
    5290:	fa 81       	ldd	r31, Y+2	; 0x02
    5292:	64 81       	ldd	r22, Z+4	; 0x04
    5294:	75 81       	ldd	r23, Z+5	; 0x05
    5296:	e9 81       	ldd	r30, Y+1	; 0x01
    5298:	fa 81       	ldd	r31, Y+2	; 0x02
    529a:	84 8d       	ldd	r24, Z+28	; 0x1c
    529c:	48 2f       	mov	r20, r24
    529e:	50 e0       	ldi	r21, 0x00	; 0
    52a0:	2b 81       	ldd	r18, Y+3	; 0x03
    52a2:	3c 81       	ldd	r19, Y+4	; 0x04
    52a4:	cb 01       	movw	r24, r22
    52a6:	b9 01       	movw	r22, r18
    52a8:	0e 94 50 32 	call	0x64a0	; 0x64a0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    52ac:	e9 81       	ldd	r30, Y+1	; 0x01
    52ae:	fa 81       	ldd	r31, Y+2	; 0x02
    52b0:	24 81       	ldd	r18, Z+4	; 0x04
    52b2:	35 81       	ldd	r19, Z+5	; 0x05
    52b4:	e9 81       	ldd	r30, Y+1	; 0x01
    52b6:	fa 81       	ldd	r31, Y+2	; 0x02
    52b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    52ba:	88 2f       	mov	r24, r24
    52bc:	90 e0       	ldi	r25, 0x00	; 0
    52be:	82 0f       	add	r24, r18
    52c0:	93 1f       	adc	r25, r19
    52c2:	e9 81       	ldd	r30, Y+1	; 0x01
    52c4:	fa 81       	ldd	r31, Y+2	; 0x02
    52c6:	95 83       	std	Z+5, r25	; 0x05
    52c8:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    52ca:	e9 81       	ldd	r30, Y+1	; 0x01
    52cc:	fa 81       	ldd	r31, Y+2	; 0x02
    52ce:	24 81       	ldd	r18, Z+4	; 0x04
    52d0:	35 81       	ldd	r19, Z+5	; 0x05
    52d2:	e9 81       	ldd	r30, Y+1	; 0x01
    52d4:	fa 81       	ldd	r31, Y+2	; 0x02
    52d6:	82 81       	ldd	r24, Z+2	; 0x02
    52d8:	93 81       	ldd	r25, Z+3	; 0x03
    52da:	28 17       	cp	r18, r24
    52dc:	39 07       	cpc	r19, r25
    52de:	08 f4       	brcc	.+2      	; 0x52e2 <prvCopyDataToQueue+0x7e>
    52e0:	47 c0       	rjmp	.+142    	; 0x5370 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    52e2:	e9 81       	ldd	r30, Y+1	; 0x01
    52e4:	fa 81       	ldd	r31, Y+2	; 0x02
    52e6:	80 81       	ld	r24, Z
    52e8:	91 81       	ldd	r25, Z+1	; 0x01
    52ea:	e9 81       	ldd	r30, Y+1	; 0x01
    52ec:	fa 81       	ldd	r31, Y+2	; 0x02
    52ee:	95 83       	std	Z+5, r25	; 0x05
    52f0:	84 83       	std	Z+4, r24	; 0x04
    52f2:	3e c0       	rjmp	.+124    	; 0x5370 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    52f4:	e9 81       	ldd	r30, Y+1	; 0x01
    52f6:	fa 81       	ldd	r31, Y+2	; 0x02
    52f8:	66 81       	ldd	r22, Z+6	; 0x06
    52fa:	77 81       	ldd	r23, Z+7	; 0x07
    52fc:	e9 81       	ldd	r30, Y+1	; 0x01
    52fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5300:	84 8d       	ldd	r24, Z+28	; 0x1c
    5302:	48 2f       	mov	r20, r24
    5304:	50 e0       	ldi	r21, 0x00	; 0
    5306:	2b 81       	ldd	r18, Y+3	; 0x03
    5308:	3c 81       	ldd	r19, Y+4	; 0x04
    530a:	cb 01       	movw	r24, r22
    530c:	b9 01       	movw	r22, r18
    530e:	0e 94 50 32 	call	0x64a0	; 0x64a0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    5312:	e9 81       	ldd	r30, Y+1	; 0x01
    5314:	fa 81       	ldd	r31, Y+2	; 0x02
    5316:	26 81       	ldd	r18, Z+6	; 0x06
    5318:	37 81       	ldd	r19, Z+7	; 0x07
    531a:	e9 81       	ldd	r30, Y+1	; 0x01
    531c:	fa 81       	ldd	r31, Y+2	; 0x02
    531e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5320:	88 2f       	mov	r24, r24
    5322:	90 e0       	ldi	r25, 0x00	; 0
    5324:	90 95       	com	r25
    5326:	81 95       	neg	r24
    5328:	9f 4f       	sbci	r25, 0xFF	; 255
    532a:	82 0f       	add	r24, r18
    532c:	93 1f       	adc	r25, r19
    532e:	e9 81       	ldd	r30, Y+1	; 0x01
    5330:	fa 81       	ldd	r31, Y+2	; 0x02
    5332:	97 83       	std	Z+7, r25	; 0x07
    5334:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    5336:	e9 81       	ldd	r30, Y+1	; 0x01
    5338:	fa 81       	ldd	r31, Y+2	; 0x02
    533a:	26 81       	ldd	r18, Z+6	; 0x06
    533c:	37 81       	ldd	r19, Z+7	; 0x07
    533e:	e9 81       	ldd	r30, Y+1	; 0x01
    5340:	fa 81       	ldd	r31, Y+2	; 0x02
    5342:	80 81       	ld	r24, Z
    5344:	91 81       	ldd	r25, Z+1	; 0x01
    5346:	28 17       	cp	r18, r24
    5348:	39 07       	cpc	r19, r25
    534a:	90 f4       	brcc	.+36     	; 0x5370 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    534c:	e9 81       	ldd	r30, Y+1	; 0x01
    534e:	fa 81       	ldd	r31, Y+2	; 0x02
    5350:	22 81       	ldd	r18, Z+2	; 0x02
    5352:	33 81       	ldd	r19, Z+3	; 0x03
    5354:	e9 81       	ldd	r30, Y+1	; 0x01
    5356:	fa 81       	ldd	r31, Y+2	; 0x02
    5358:	84 8d       	ldd	r24, Z+28	; 0x1c
    535a:	88 2f       	mov	r24, r24
    535c:	90 e0       	ldi	r25, 0x00	; 0
    535e:	90 95       	com	r25
    5360:	81 95       	neg	r24
    5362:	9f 4f       	sbci	r25, 0xFF	; 255
    5364:	82 0f       	add	r24, r18
    5366:	93 1f       	adc	r25, r19
    5368:	e9 81       	ldd	r30, Y+1	; 0x01
    536a:	fa 81       	ldd	r31, Y+2	; 0x02
    536c:	97 83       	std	Z+7, r25	; 0x07
    536e:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    5370:	e9 81       	ldd	r30, Y+1	; 0x01
    5372:	fa 81       	ldd	r31, Y+2	; 0x02
    5374:	82 8d       	ldd	r24, Z+26	; 0x1a
    5376:	8f 5f       	subi	r24, 0xFF	; 255
    5378:	e9 81       	ldd	r30, Y+1	; 0x01
    537a:	fa 81       	ldd	r31, Y+2	; 0x02
    537c:	82 8f       	std	Z+26, r24	; 0x1a
}
    537e:	0f 90       	pop	r0
    5380:	0f 90       	pop	r0
    5382:	0f 90       	pop	r0
    5384:	0f 90       	pop	r0
    5386:	0f 90       	pop	r0
    5388:	cf 91       	pop	r28
    538a:	df 91       	pop	r29
    538c:	08 95       	ret

0000538e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    538e:	df 93       	push	r29
    5390:	cf 93       	push	r28
    5392:	00 d0       	rcall	.+0      	; 0x5394 <prvCopyDataFromQueue+0x6>
    5394:	00 d0       	rcall	.+0      	; 0x5396 <prvCopyDataFromQueue+0x8>
    5396:	cd b7       	in	r28, 0x3d	; 61
    5398:	de b7       	in	r29, 0x3e	; 62
    539a:	9a 83       	std	Y+2, r25	; 0x02
    539c:	89 83       	std	Y+1, r24	; 0x01
    539e:	7c 83       	std	Y+4, r23	; 0x04
    53a0:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    53a2:	e9 81       	ldd	r30, Y+1	; 0x01
    53a4:	fa 81       	ldd	r31, Y+2	; 0x02
    53a6:	80 81       	ld	r24, Z
    53a8:	91 81       	ldd	r25, Z+1	; 0x01
    53aa:	00 97       	sbiw	r24, 0x00	; 0
    53ac:	89 f1       	breq	.+98     	; 0x5410 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    53ae:	e9 81       	ldd	r30, Y+1	; 0x01
    53b0:	fa 81       	ldd	r31, Y+2	; 0x02
    53b2:	26 81       	ldd	r18, Z+6	; 0x06
    53b4:	37 81       	ldd	r19, Z+7	; 0x07
    53b6:	e9 81       	ldd	r30, Y+1	; 0x01
    53b8:	fa 81       	ldd	r31, Y+2	; 0x02
    53ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    53bc:	88 2f       	mov	r24, r24
    53be:	90 e0       	ldi	r25, 0x00	; 0
    53c0:	82 0f       	add	r24, r18
    53c2:	93 1f       	adc	r25, r19
    53c4:	e9 81       	ldd	r30, Y+1	; 0x01
    53c6:	fa 81       	ldd	r31, Y+2	; 0x02
    53c8:	97 83       	std	Z+7, r25	; 0x07
    53ca:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    53cc:	e9 81       	ldd	r30, Y+1	; 0x01
    53ce:	fa 81       	ldd	r31, Y+2	; 0x02
    53d0:	26 81       	ldd	r18, Z+6	; 0x06
    53d2:	37 81       	ldd	r19, Z+7	; 0x07
    53d4:	e9 81       	ldd	r30, Y+1	; 0x01
    53d6:	fa 81       	ldd	r31, Y+2	; 0x02
    53d8:	82 81       	ldd	r24, Z+2	; 0x02
    53da:	93 81       	ldd	r25, Z+3	; 0x03
    53dc:	28 17       	cp	r18, r24
    53de:	39 07       	cpc	r19, r25
    53e0:	40 f0       	brcs	.+16     	; 0x53f2 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    53e2:	e9 81       	ldd	r30, Y+1	; 0x01
    53e4:	fa 81       	ldd	r31, Y+2	; 0x02
    53e6:	80 81       	ld	r24, Z
    53e8:	91 81       	ldd	r25, Z+1	; 0x01
    53ea:	e9 81       	ldd	r30, Y+1	; 0x01
    53ec:	fa 81       	ldd	r31, Y+2	; 0x02
    53ee:	97 83       	std	Z+7, r25	; 0x07
    53f0:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    53f2:	e9 81       	ldd	r30, Y+1	; 0x01
    53f4:	fa 81       	ldd	r31, Y+2	; 0x02
    53f6:	46 81       	ldd	r20, Z+6	; 0x06
    53f8:	57 81       	ldd	r21, Z+7	; 0x07
    53fa:	e9 81       	ldd	r30, Y+1	; 0x01
    53fc:	fa 81       	ldd	r31, Y+2	; 0x02
    53fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    5400:	28 2f       	mov	r18, r24
    5402:	30 e0       	ldi	r19, 0x00	; 0
    5404:	8b 81       	ldd	r24, Y+3	; 0x03
    5406:	9c 81       	ldd	r25, Y+4	; 0x04
    5408:	ba 01       	movw	r22, r20
    540a:	a9 01       	movw	r20, r18
    540c:	0e 94 50 32 	call	0x64a0	; 0x64a0 <memcpy>
	}
}
    5410:	0f 90       	pop	r0
    5412:	0f 90       	pop	r0
    5414:	0f 90       	pop	r0
    5416:	0f 90       	pop	r0
    5418:	cf 91       	pop	r28
    541a:	df 91       	pop	r29
    541c:	08 95       	ret

0000541e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    541e:	df 93       	push	r29
    5420:	cf 93       	push	r28
    5422:	00 d0       	rcall	.+0      	; 0x5424 <prvUnlockQueue+0x6>
    5424:	cd b7       	in	r28, 0x3d	; 61
    5426:	de b7       	in	r29, 0x3e	; 62
    5428:	9a 83       	std	Y+2, r25	; 0x02
    542a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    542c:	0f b6       	in	r0, 0x3f	; 63
    542e:	f8 94       	cli
    5430:	0f 92       	push	r0
    5432:	15 c0       	rjmp	.+42     	; 0x545e <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5434:	e9 81       	ldd	r30, Y+1	; 0x01
    5436:	fa 81       	ldd	r31, Y+2	; 0x02
    5438:	81 89       	ldd	r24, Z+17	; 0x11
    543a:	88 23       	and	r24, r24
    543c:	a9 f0       	breq	.+42     	; 0x5468 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    543e:	89 81       	ldd	r24, Y+1	; 0x01
    5440:	9a 81       	ldd	r25, Y+2	; 0x02
    5442:	41 96       	adiw	r24, 0x11	; 17
    5444:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    5448:	88 23       	and	r24, r24
    544a:	11 f0       	breq	.+4      	; 0x5450 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    544c:	0e 94 25 30 	call	0x604a	; 0x604a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    5450:	e9 81       	ldd	r30, Y+1	; 0x01
    5452:	fa 81       	ldd	r31, Y+2	; 0x02
    5454:	86 8d       	ldd	r24, Z+30	; 0x1e
    5456:	81 50       	subi	r24, 0x01	; 1
    5458:	e9 81       	ldd	r30, Y+1	; 0x01
    545a:	fa 81       	ldd	r31, Y+2	; 0x02
    545c:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    545e:	e9 81       	ldd	r30, Y+1	; 0x01
    5460:	fa 81       	ldd	r31, Y+2	; 0x02
    5462:	86 8d       	ldd	r24, Z+30	; 0x1e
    5464:	18 16       	cp	r1, r24
    5466:	34 f3       	brlt	.-52     	; 0x5434 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    5468:	e9 81       	ldd	r30, Y+1	; 0x01
    546a:	fa 81       	ldd	r31, Y+2	; 0x02
    546c:	8f ef       	ldi	r24, 0xFF	; 255
    546e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    5470:	0f 90       	pop	r0
    5472:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    5474:	0f b6       	in	r0, 0x3f	; 63
    5476:	f8 94       	cli
    5478:	0f 92       	push	r0
    547a:	15 c0       	rjmp	.+42     	; 0x54a6 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    547c:	e9 81       	ldd	r30, Y+1	; 0x01
    547e:	fa 81       	ldd	r31, Y+2	; 0x02
    5480:	80 85       	ldd	r24, Z+8	; 0x08
    5482:	88 23       	and	r24, r24
    5484:	a9 f0       	breq	.+42     	; 0x54b0 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5486:	89 81       	ldd	r24, Y+1	; 0x01
    5488:	9a 81       	ldd	r25, Y+2	; 0x02
    548a:	08 96       	adiw	r24, 0x08	; 8
    548c:	0e 94 47 2f 	call	0x5e8e	; 0x5e8e <xTaskRemoveFromEventList>
    5490:	88 23       	and	r24, r24
    5492:	11 f0       	breq	.+4      	; 0x5498 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    5494:	0e 94 25 30 	call	0x604a	; 0x604a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    5498:	e9 81       	ldd	r30, Y+1	; 0x01
    549a:	fa 81       	ldd	r31, Y+2	; 0x02
    549c:	85 8d       	ldd	r24, Z+29	; 0x1d
    549e:	81 50       	subi	r24, 0x01	; 1
    54a0:	e9 81       	ldd	r30, Y+1	; 0x01
    54a2:	fa 81       	ldd	r31, Y+2	; 0x02
    54a4:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    54a6:	e9 81       	ldd	r30, Y+1	; 0x01
    54a8:	fa 81       	ldd	r31, Y+2	; 0x02
    54aa:	85 8d       	ldd	r24, Z+29	; 0x1d
    54ac:	18 16       	cp	r1, r24
    54ae:	34 f3       	brlt	.-52     	; 0x547c <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    54b0:	e9 81       	ldd	r30, Y+1	; 0x01
    54b2:	fa 81       	ldd	r31, Y+2	; 0x02
    54b4:	8f ef       	ldi	r24, 0xFF	; 255
    54b6:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    54b8:	0f 90       	pop	r0
    54ba:	0f be       	out	0x3f, r0	; 63
}
    54bc:	0f 90       	pop	r0
    54be:	0f 90       	pop	r0
    54c0:	cf 91       	pop	r28
    54c2:	df 91       	pop	r29
    54c4:	08 95       	ret

000054c6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    54c6:	df 93       	push	r29
    54c8:	cf 93       	push	r28
    54ca:	00 d0       	rcall	.+0      	; 0x54cc <prvIsQueueEmpty+0x6>
    54cc:	0f 92       	push	r0
    54ce:	cd b7       	in	r28, 0x3d	; 61
    54d0:	de b7       	in	r29, 0x3e	; 62
    54d2:	9b 83       	std	Y+3, r25	; 0x03
    54d4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    54d6:	0f b6       	in	r0, 0x3f	; 63
    54d8:	f8 94       	cli
    54da:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    54dc:	ea 81       	ldd	r30, Y+2	; 0x02
    54de:	fb 81       	ldd	r31, Y+3	; 0x03
    54e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    54e2:	19 82       	std	Y+1, r1	; 0x01
    54e4:	88 23       	and	r24, r24
    54e6:	11 f4       	brne	.+4      	; 0x54ec <prvIsQueueEmpty+0x26>
    54e8:	81 e0       	ldi	r24, 0x01	; 1
    54ea:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    54ec:	0f 90       	pop	r0
    54ee:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    54f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    54f2:	0f 90       	pop	r0
    54f4:	0f 90       	pop	r0
    54f6:	0f 90       	pop	r0
    54f8:	cf 91       	pop	r28
    54fa:	df 91       	pop	r29
    54fc:	08 95       	ret

000054fe <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    54fe:	df 93       	push	r29
    5500:	cf 93       	push	r28
    5502:	00 d0       	rcall	.+0      	; 0x5504 <xQueueIsQueueEmptyFromISR+0x6>
    5504:	0f 92       	push	r0
    5506:	cd b7       	in	r28, 0x3d	; 61
    5508:	de b7       	in	r29, 0x3e	; 62
    550a:	9b 83       	std	Y+3, r25	; 0x03
    550c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    550e:	ea 81       	ldd	r30, Y+2	; 0x02
    5510:	fb 81       	ldd	r31, Y+3	; 0x03
    5512:	82 8d       	ldd	r24, Z+26	; 0x1a
    5514:	19 82       	std	Y+1, r1	; 0x01
    5516:	88 23       	and	r24, r24
    5518:	11 f4       	brne	.+4      	; 0x551e <xQueueIsQueueEmptyFromISR+0x20>
    551a:	81 e0       	ldi	r24, 0x01	; 1
    551c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    551e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5520:	0f 90       	pop	r0
    5522:	0f 90       	pop	r0
    5524:	0f 90       	pop	r0
    5526:	cf 91       	pop	r28
    5528:	df 91       	pop	r29
    552a:	08 95       	ret

0000552c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    552c:	df 93       	push	r29
    552e:	cf 93       	push	r28
    5530:	00 d0       	rcall	.+0      	; 0x5532 <prvIsQueueFull+0x6>
    5532:	0f 92       	push	r0
    5534:	cd b7       	in	r28, 0x3d	; 61
    5536:	de b7       	in	r29, 0x3e	; 62
    5538:	9b 83       	std	Y+3, r25	; 0x03
    553a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    553c:	0f b6       	in	r0, 0x3f	; 63
    553e:	f8 94       	cli
    5540:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    5542:	ea 81       	ldd	r30, Y+2	; 0x02
    5544:	fb 81       	ldd	r31, Y+3	; 0x03
    5546:	92 8d       	ldd	r25, Z+26	; 0x1a
    5548:	ea 81       	ldd	r30, Y+2	; 0x02
    554a:	fb 81       	ldd	r31, Y+3	; 0x03
    554c:	83 8d       	ldd	r24, Z+27	; 0x1b
    554e:	19 82       	std	Y+1, r1	; 0x01
    5550:	98 17       	cp	r25, r24
    5552:	11 f4       	brne	.+4      	; 0x5558 <prvIsQueueFull+0x2c>
    5554:	81 e0       	ldi	r24, 0x01	; 1
    5556:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    5558:	0f 90       	pop	r0
    555a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    555c:	89 81       	ldd	r24, Y+1	; 0x01
}
    555e:	0f 90       	pop	r0
    5560:	0f 90       	pop	r0
    5562:	0f 90       	pop	r0
    5564:	cf 91       	pop	r28
    5566:	df 91       	pop	r29
    5568:	08 95       	ret

0000556a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    556a:	df 93       	push	r29
    556c:	cf 93       	push	r28
    556e:	00 d0       	rcall	.+0      	; 0x5570 <xQueueIsQueueFullFromISR+0x6>
    5570:	0f 92       	push	r0
    5572:	cd b7       	in	r28, 0x3d	; 61
    5574:	de b7       	in	r29, 0x3e	; 62
    5576:	9b 83       	std	Y+3, r25	; 0x03
    5578:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    557a:	ea 81       	ldd	r30, Y+2	; 0x02
    557c:	fb 81       	ldd	r31, Y+3	; 0x03
    557e:	92 8d       	ldd	r25, Z+26	; 0x1a
    5580:	ea 81       	ldd	r30, Y+2	; 0x02
    5582:	fb 81       	ldd	r31, Y+3	; 0x03
    5584:	83 8d       	ldd	r24, Z+27	; 0x1b
    5586:	19 82       	std	Y+1, r1	; 0x01
    5588:	98 17       	cp	r25, r24
    558a:	11 f4       	brne	.+4      	; 0x5590 <xQueueIsQueueFullFromISR+0x26>
    558c:	81 e0       	ldi	r24, 0x01	; 1
    558e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    5590:	89 81       	ldd	r24, Y+1	; 0x01
}
    5592:	0f 90       	pop	r0
    5594:	0f 90       	pop	r0
    5596:	0f 90       	pop	r0
    5598:	cf 91       	pop	r28
    559a:	df 91       	pop	r29
    559c:	08 95       	ret

0000559e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    559e:	af 92       	push	r10
    55a0:	bf 92       	push	r11
    55a2:	cf 92       	push	r12
    55a4:	df 92       	push	r13
    55a6:	ef 92       	push	r14
    55a8:	ff 92       	push	r15
    55aa:	0f 93       	push	r16
    55ac:	1f 93       	push	r17
    55ae:	df 93       	push	r29
    55b0:	cf 93       	push	r28
    55b2:	cd b7       	in	r28, 0x3d	; 61
    55b4:	de b7       	in	r29, 0x3e	; 62
    55b6:	64 97       	sbiw	r28, 0x14	; 20
    55b8:	0f b6       	in	r0, 0x3f	; 63
    55ba:	f8 94       	cli
    55bc:	de bf       	out	0x3e, r29	; 62
    55be:	0f be       	out	0x3f, r0	; 63
    55c0:	cd bf       	out	0x3d, r28	; 61
    55c2:	9f 83       	std	Y+7, r25	; 0x07
    55c4:	8e 83       	std	Y+6, r24	; 0x06
    55c6:	79 87       	std	Y+9, r23	; 0x09
    55c8:	68 87       	std	Y+8, r22	; 0x08
    55ca:	5b 87       	std	Y+11, r21	; 0x0b
    55cc:	4a 87       	std	Y+10, r20	; 0x0a
    55ce:	3d 87       	std	Y+13, r19	; 0x0d
    55d0:	2c 87       	std	Y+12, r18	; 0x0c
    55d2:	0e 87       	std	Y+14, r16	; 0x0e
    55d4:	f8 8a       	std	Y+16, r15	; 0x10
    55d6:	ef 86       	std	Y+15, r14	; 0x0f
    55d8:	da 8a       	std	Y+18, r13	; 0x12
    55da:	c9 8a       	std	Y+17, r12	; 0x11
    55dc:	bc 8a       	std	Y+20, r11	; 0x14
    55de:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    55e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    55e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    55e4:	29 89       	ldd	r18, Y+17	; 0x11
    55e6:	3a 89       	ldd	r19, Y+18	; 0x12
    55e8:	b9 01       	movw	r22, r18
    55ea:	0e 94 54 31 	call	0x62a8	; 0x62a8 <prvAllocateTCBAndStack>
    55ee:	9c 83       	std	Y+4, r25	; 0x04
    55f0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    55f2:	8b 81       	ldd	r24, Y+3	; 0x03
    55f4:	9c 81       	ldd	r25, Y+4	; 0x04
    55f6:	00 97       	sbiw	r24, 0x00	; 0
    55f8:	09 f4       	brne	.+2      	; 0x55fc <xTaskGenericCreate+0x5e>
    55fa:	99 c0       	rjmp	.+306    	; 0x572e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    55fc:	eb 81       	ldd	r30, Y+3	; 0x03
    55fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5600:	27 89       	ldd	r18, Z+23	; 0x17
    5602:	30 8d       	ldd	r19, Z+24	; 0x18
    5604:	8a 85       	ldd	r24, Y+10	; 0x0a
    5606:	9b 85       	ldd	r25, Y+11	; 0x0b
    5608:	01 97       	sbiw	r24, 0x01	; 1
    560a:	82 0f       	add	r24, r18
    560c:	93 1f       	adc	r25, r19
    560e:	9a 83       	std	Y+2, r25	; 0x02
    5610:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    5612:	8b 81       	ldd	r24, Y+3	; 0x03
    5614:	9c 81       	ldd	r25, Y+4	; 0x04
    5616:	28 85       	ldd	r18, Y+8	; 0x08
    5618:	39 85       	ldd	r19, Y+9	; 0x09
    561a:	eb 89       	ldd	r30, Y+19	; 0x13
    561c:	fc 89       	ldd	r31, Y+20	; 0x14
    561e:	aa 85       	ldd	r26, Y+10	; 0x0a
    5620:	bb 85       	ldd	r27, Y+11	; 0x0b
    5622:	b9 01       	movw	r22, r18
    5624:	4e 85       	ldd	r20, Y+14	; 0x0e
    5626:	9f 01       	movw	r18, r30
    5628:	8d 01       	movw	r16, r26
    562a:	0e 94 39 30 	call	0x6072	; 0x6072 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    562e:	89 81       	ldd	r24, Y+1	; 0x01
    5630:	9a 81       	ldd	r25, Y+2	; 0x02
    5632:	2e 81       	ldd	r18, Y+6	; 0x06
    5634:	3f 81       	ldd	r19, Y+7	; 0x07
    5636:	4c 85       	ldd	r20, Y+12	; 0x0c
    5638:	5d 85       	ldd	r21, Y+13	; 0x0d
    563a:	b9 01       	movw	r22, r18
    563c:	0e 94 7c 23 	call	0x46f8	; 0x46f8 <pxPortInitialiseStack>
    5640:	eb 81       	ldd	r30, Y+3	; 0x03
    5642:	fc 81       	ldd	r31, Y+4	; 0x04
    5644:	91 83       	std	Z+1, r25	; 0x01
    5646:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    5648:	8f 85       	ldd	r24, Y+15	; 0x0f
    564a:	98 89       	ldd	r25, Y+16	; 0x10
    564c:	00 97       	sbiw	r24, 0x00	; 0
    564e:	31 f0       	breq	.+12     	; 0x565c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5650:	ef 85       	ldd	r30, Y+15	; 0x0f
    5652:	f8 89       	ldd	r31, Y+16	; 0x10
    5654:	8b 81       	ldd	r24, Y+3	; 0x03
    5656:	9c 81       	ldd	r25, Y+4	; 0x04
    5658:	91 83       	std	Z+1, r25	; 0x01
    565a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    565c:	0f b6       	in	r0, 0x3f	; 63
    565e:	f8 94       	cli
    5660:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    5662:	80 91 a2 06 	lds	r24, 0x06A2
    5666:	8f 5f       	subi	r24, 0xFF	; 255
    5668:	80 93 a2 06 	sts	0x06A2, r24
			if( pxCurrentTCB == NULL )
    566c:	80 91 9f 06 	lds	r24, 0x069F
    5670:	90 91 a0 06 	lds	r25, 0x06A0
    5674:	00 97       	sbiw	r24, 0x00	; 0
    5676:	69 f4       	brne	.+26     	; 0x5692 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5678:	8b 81       	ldd	r24, Y+3	; 0x03
    567a:	9c 81       	ldd	r25, Y+4	; 0x04
    567c:	90 93 a0 06 	sts	0x06A0, r25
    5680:	80 93 9f 06 	sts	0x069F, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    5684:	80 91 a2 06 	lds	r24, 0x06A2
    5688:	81 30       	cpi	r24, 0x01	; 1
    568a:	a9 f4       	brne	.+42     	; 0x56b6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    568c:	0e 94 90 30 	call	0x6120	; 0x6120 <prvInitialiseTaskLists>
    5690:	12 c0       	rjmp	.+36     	; 0x56b6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    5692:	80 91 a7 06 	lds	r24, 0x06A7
    5696:	88 23       	and	r24, r24
    5698:	71 f4       	brne	.+28     	; 0x56b6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    569a:	e0 91 9f 06 	lds	r30, 0x069F
    569e:	f0 91 a0 06 	lds	r31, 0x06A0
    56a2:	96 89       	ldd	r25, Z+22	; 0x16
    56a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    56a6:	89 17       	cp	r24, r25
    56a8:	30 f0       	brcs	.+12     	; 0x56b6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    56aa:	8b 81       	ldd	r24, Y+3	; 0x03
    56ac:	9c 81       	ldd	r25, Y+4	; 0x04
    56ae:	90 93 a0 06 	sts	0x06A0, r25
    56b2:	80 93 9f 06 	sts	0x069F, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    56b6:	eb 81       	ldd	r30, Y+3	; 0x03
    56b8:	fc 81       	ldd	r31, Y+4	; 0x04
    56ba:	96 89       	ldd	r25, Z+22	; 0x16
    56bc:	80 91 a5 06 	lds	r24, 0x06A5
    56c0:	89 17       	cp	r24, r25
    56c2:	28 f4       	brcc	.+10     	; 0x56ce <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    56c4:	eb 81       	ldd	r30, Y+3	; 0x03
    56c6:	fc 81       	ldd	r31, Y+4	; 0x04
    56c8:	86 89       	ldd	r24, Z+22	; 0x16
    56ca:	80 93 a5 06 	sts	0x06A5, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    56ce:	80 91 ac 06 	lds	r24, 0x06AC
    56d2:	8f 5f       	subi	r24, 0xFF	; 255
    56d4:	80 93 ac 06 	sts	0x06AC, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    56d8:	eb 81       	ldd	r30, Y+3	; 0x03
    56da:	fc 81       	ldd	r31, Y+4	; 0x04
    56dc:	96 89       	ldd	r25, Z+22	; 0x16
    56de:	80 91 a6 06 	lds	r24, 0x06A6
    56e2:	89 17       	cp	r24, r25
    56e4:	28 f4       	brcc	.+10     	; 0x56f0 <xTaskGenericCreate+0x152>
    56e6:	eb 81       	ldd	r30, Y+3	; 0x03
    56e8:	fc 81       	ldd	r31, Y+4	; 0x04
    56ea:	86 89       	ldd	r24, Z+22	; 0x16
    56ec:	80 93 a6 06 	sts	0x06A6, r24
    56f0:	eb 81       	ldd	r30, Y+3	; 0x03
    56f2:	fc 81       	ldd	r31, Y+4	; 0x04
    56f4:	86 89       	ldd	r24, Z+22	; 0x16
    56f6:	28 2f       	mov	r18, r24
    56f8:	30 e0       	ldi	r19, 0x00	; 0
    56fa:	c9 01       	movw	r24, r18
    56fc:	88 0f       	add	r24, r24
    56fe:	99 1f       	adc	r25, r25
    5700:	88 0f       	add	r24, r24
    5702:	99 1f       	adc	r25, r25
    5704:	88 0f       	add	r24, r24
    5706:	99 1f       	adc	r25, r25
    5708:	82 0f       	add	r24, r18
    570a:	93 1f       	adc	r25, r19
    570c:	ac 01       	movw	r20, r24
    570e:	43 55       	subi	r20, 0x53	; 83
    5710:	59 4f       	sbci	r21, 0xF9	; 249
    5712:	8b 81       	ldd	r24, Y+3	; 0x03
    5714:	9c 81       	ldd	r25, Y+4	; 0x04
    5716:	9c 01       	movw	r18, r24
    5718:	2e 5f       	subi	r18, 0xFE	; 254
    571a:	3f 4f       	sbci	r19, 0xFF	; 255
    571c:	ca 01       	movw	r24, r20
    571e:	b9 01       	movw	r22, r18
    5720:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>

			xReturn = pdPASS;
    5724:	81 e0       	ldi	r24, 0x01	; 1
    5726:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    5728:	0f 90       	pop	r0
    572a:	0f be       	out	0x3f, r0	; 63
    572c:	02 c0       	rjmp	.+4      	; 0x5732 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    572e:	8f ef       	ldi	r24, 0xFF	; 255
    5730:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    5732:	8d 81       	ldd	r24, Y+5	; 0x05
    5734:	81 30       	cpi	r24, 0x01	; 1
    5736:	71 f4       	brne	.+28     	; 0x5754 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    5738:	80 91 a7 06 	lds	r24, 0x06A7
    573c:	88 23       	and	r24, r24
    573e:	51 f0       	breq	.+20     	; 0x5754 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5740:	e0 91 9f 06 	lds	r30, 0x069F
    5744:	f0 91 a0 06 	lds	r31, 0x06A0
    5748:	96 89       	ldd	r25, Z+22	; 0x16
    574a:	8e 85       	ldd	r24, Y+14	; 0x0e
    574c:	98 17       	cp	r25, r24
    574e:	10 f4       	brcc	.+4      	; 0x5754 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    5750:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
			}
		}
	}

	return xReturn;
    5754:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5756:	64 96       	adiw	r28, 0x14	; 20
    5758:	0f b6       	in	r0, 0x3f	; 63
    575a:	f8 94       	cli
    575c:	de bf       	out	0x3e, r29	; 62
    575e:	0f be       	out	0x3f, r0	; 63
    5760:	cd bf       	out	0x3d, r28	; 61
    5762:	cf 91       	pop	r28
    5764:	df 91       	pop	r29
    5766:	1f 91       	pop	r17
    5768:	0f 91       	pop	r16
    576a:	ff 90       	pop	r15
    576c:	ef 90       	pop	r14
    576e:	df 90       	pop	r13
    5770:	cf 90       	pop	r12
    5772:	bf 90       	pop	r11
    5774:	af 90       	pop	r10
    5776:	08 95       	ret

00005778 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    5778:	df 93       	push	r29
    577a:	cf 93       	push	r28
    577c:	00 d0       	rcall	.+0      	; 0x577e <vTaskDelete+0x6>
    577e:	00 d0       	rcall	.+0      	; 0x5780 <vTaskDelete+0x8>
    5780:	00 d0       	rcall	.+0      	; 0x5782 <vTaskDelete+0xa>
    5782:	cd b7       	in	r28, 0x3d	; 61
    5784:	de b7       	in	r29, 0x3e	; 62
    5786:	9c 83       	std	Y+4, r25	; 0x04
    5788:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    578a:	0f b6       	in	r0, 0x3f	; 63
    578c:	f8 94       	cli
    578e:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    5790:	20 91 9f 06 	lds	r18, 0x069F
    5794:	30 91 a0 06 	lds	r19, 0x06A0
    5798:	8b 81       	ldd	r24, Y+3	; 0x03
    579a:	9c 81       	ldd	r25, Y+4	; 0x04
    579c:	82 17       	cp	r24, r18
    579e:	93 07       	cpc	r25, r19
    57a0:	11 f4       	brne	.+4      	; 0x57a6 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    57a2:	1c 82       	std	Y+4, r1	; 0x04
    57a4:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    57a6:	8b 81       	ldd	r24, Y+3	; 0x03
    57a8:	9c 81       	ldd	r25, Y+4	; 0x04
    57aa:	00 97       	sbiw	r24, 0x00	; 0
    57ac:	39 f4       	brne	.+14     	; 0x57bc <vTaskDelete+0x44>
    57ae:	80 91 9f 06 	lds	r24, 0x069F
    57b2:	90 91 a0 06 	lds	r25, 0x06A0
    57b6:	9e 83       	std	Y+6, r25	; 0x06
    57b8:	8d 83       	std	Y+5, r24	; 0x05
    57ba:	04 c0       	rjmp	.+8      	; 0x57c4 <vTaskDelete+0x4c>
    57bc:	8b 81       	ldd	r24, Y+3	; 0x03
    57be:	9c 81       	ldd	r25, Y+4	; 0x04
    57c0:	9e 83       	std	Y+6, r25	; 0x06
    57c2:	8d 83       	std	Y+5, r24	; 0x05
    57c4:	8d 81       	ldd	r24, Y+5	; 0x05
    57c6:	9e 81       	ldd	r25, Y+6	; 0x06
    57c8:	9a 83       	std	Y+2, r25	; 0x02
    57ca:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    57cc:	89 81       	ldd	r24, Y+1	; 0x01
    57ce:	9a 81       	ldd	r25, Y+2	; 0x02
    57d0:	02 96       	adiw	r24, 0x02	; 2
    57d2:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    57d6:	e9 81       	ldd	r30, Y+1	; 0x01
    57d8:	fa 81       	ldd	r31, Y+2	; 0x02
    57da:	84 89       	ldd	r24, Z+20	; 0x14
    57dc:	95 89       	ldd	r25, Z+21	; 0x15
    57de:	00 97       	sbiw	r24, 0x00	; 0
    57e0:	29 f0       	breq	.+10     	; 0x57ec <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    57e2:	89 81       	ldd	r24, Y+1	; 0x01
    57e4:	9a 81       	ldd	r25, Y+2	; 0x02
    57e6:	0c 96       	adiw	r24, 0x0c	; 12
    57e8:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    57ec:	89 81       	ldd	r24, Y+1	; 0x01
    57ee:	9a 81       	ldd	r25, Y+2	; 0x02
    57f0:	9c 01       	movw	r18, r24
    57f2:	2e 5f       	subi	r18, 0xFE	; 254
    57f4:	3f 4f       	sbci	r19, 0xFF	; 255
    57f6:	82 e0       	ldi	r24, 0x02	; 2
    57f8:	97 e0       	ldi	r25, 0x07	; 7
    57fa:	b9 01       	movw	r22, r18
    57fc:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    5800:	80 91 a1 06 	lds	r24, 0x06A1
    5804:	8f 5f       	subi	r24, 0xFF	; 255
    5806:	80 93 a1 06 	sts	0x06A1, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    580a:	80 91 ac 06 	lds	r24, 0x06AC
    580e:	8f 5f       	subi	r24, 0xFF	; 255
    5810:	80 93 ac 06 	sts	0x06AC, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5814:	0f 90       	pop	r0
    5816:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    5818:	80 91 a7 06 	lds	r24, 0x06A7
    581c:	88 23       	and	r24, r24
    581e:	31 f0       	breq	.+12     	; 0x582c <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    5820:	8b 81       	ldd	r24, Y+3	; 0x03
    5822:	9c 81       	ldd	r25, Y+4	; 0x04
    5824:	00 97       	sbiw	r24, 0x00	; 0
    5826:	11 f4       	brne	.+4      	; 0x582c <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    5828:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
			}
		}
	}
    582c:	26 96       	adiw	r28, 0x06	; 6
    582e:	0f b6       	in	r0, 0x3f	; 63
    5830:	f8 94       	cli
    5832:	de bf       	out	0x3e, r29	; 62
    5834:	0f be       	out	0x3f, r0	; 63
    5836:	cd bf       	out	0x3d, r28	; 61
    5838:	cf 91       	pop	r28
    583a:	df 91       	pop	r29
    583c:	08 95       	ret

0000583e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    583e:	df 93       	push	r29
    5840:	cf 93       	push	r28
    5842:	cd b7       	in	r28, 0x3d	; 61
    5844:	de b7       	in	r29, 0x3e	; 62
    5846:	28 97       	sbiw	r28, 0x08	; 8
    5848:	0f b6       	in	r0, 0x3f	; 63
    584a:	f8 94       	cli
    584c:	de bf       	out	0x3e, r29	; 62
    584e:	0f be       	out	0x3f, r0	; 63
    5850:	cd bf       	out	0x3d, r28	; 61
    5852:	9e 83       	std	Y+6, r25	; 0x06
    5854:	8d 83       	std	Y+5, r24	; 0x05
    5856:	78 87       	std	Y+8, r23	; 0x08
    5858:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    585a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    585c:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5860:	ed 81       	ldd	r30, Y+5	; 0x05
    5862:	fe 81       	ldd	r31, Y+6	; 0x06
    5864:	20 81       	ld	r18, Z
    5866:	31 81       	ldd	r19, Z+1	; 0x01
    5868:	8f 81       	ldd	r24, Y+7	; 0x07
    586a:	98 85       	ldd	r25, Y+8	; 0x08
    586c:	82 0f       	add	r24, r18
    586e:	93 1f       	adc	r25, r19
    5870:	9c 83       	std	Y+4, r25	; 0x04
    5872:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    5874:	ed 81       	ldd	r30, Y+5	; 0x05
    5876:	fe 81       	ldd	r31, Y+6	; 0x06
    5878:	20 81       	ld	r18, Z
    587a:	31 81       	ldd	r19, Z+1	; 0x01
    587c:	80 91 a3 06 	lds	r24, 0x06A3
    5880:	90 91 a4 06 	lds	r25, 0x06A4
    5884:	82 17       	cp	r24, r18
    5886:	93 07       	cpc	r25, r19
    5888:	a8 f4       	brcc	.+42     	; 0x58b4 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    588a:	ed 81       	ldd	r30, Y+5	; 0x05
    588c:	fe 81       	ldd	r31, Y+6	; 0x06
    588e:	20 81       	ld	r18, Z
    5890:	31 81       	ldd	r19, Z+1	; 0x01
    5892:	8b 81       	ldd	r24, Y+3	; 0x03
    5894:	9c 81       	ldd	r25, Y+4	; 0x04
    5896:	82 17       	cp	r24, r18
    5898:	93 07       	cpc	r25, r19
    589a:	00 f5       	brcc	.+64     	; 0x58dc <vTaskDelayUntil+0x9e>
    589c:	20 91 a3 06 	lds	r18, 0x06A3
    58a0:	30 91 a4 06 	lds	r19, 0x06A4
    58a4:	8b 81       	ldd	r24, Y+3	; 0x03
    58a6:	9c 81       	ldd	r25, Y+4	; 0x04
    58a8:	28 17       	cp	r18, r24
    58aa:	39 07       	cpc	r19, r25
    58ac:	b8 f4       	brcc	.+46     	; 0x58dc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    58ae:	81 e0       	ldi	r24, 0x01	; 1
    58b0:	89 83       	std	Y+1, r24	; 0x01
    58b2:	14 c0       	rjmp	.+40     	; 0x58dc <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    58b4:	ed 81       	ldd	r30, Y+5	; 0x05
    58b6:	fe 81       	ldd	r31, Y+6	; 0x06
    58b8:	20 81       	ld	r18, Z
    58ba:	31 81       	ldd	r19, Z+1	; 0x01
    58bc:	8b 81       	ldd	r24, Y+3	; 0x03
    58be:	9c 81       	ldd	r25, Y+4	; 0x04
    58c0:	82 17       	cp	r24, r18
    58c2:	93 07       	cpc	r25, r19
    58c4:	48 f0       	brcs	.+18     	; 0x58d8 <vTaskDelayUntil+0x9a>
    58c6:	20 91 a3 06 	lds	r18, 0x06A3
    58ca:	30 91 a4 06 	lds	r19, 0x06A4
    58ce:	8b 81       	ldd	r24, Y+3	; 0x03
    58d0:	9c 81       	ldd	r25, Y+4	; 0x04
    58d2:	28 17       	cp	r18, r24
    58d4:	39 07       	cpc	r19, r25
    58d6:	10 f4       	brcc	.+4      	; 0x58dc <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    58d8:	81 e0       	ldi	r24, 0x01	; 1
    58da:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    58dc:	ed 81       	ldd	r30, Y+5	; 0x05
    58de:	fe 81       	ldd	r31, Y+6	; 0x06
    58e0:	8b 81       	ldd	r24, Y+3	; 0x03
    58e2:	9c 81       	ldd	r25, Y+4	; 0x04
    58e4:	91 83       	std	Z+1, r25	; 0x01
    58e6:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    58e8:	89 81       	ldd	r24, Y+1	; 0x01
    58ea:	88 23       	and	r24, r24
    58ec:	59 f0       	breq	.+22     	; 0x5904 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    58ee:	80 91 9f 06 	lds	r24, 0x069F
    58f2:	90 91 a0 06 	lds	r25, 0x06A0
    58f6:	02 96       	adiw	r24, 0x02	; 2
    58f8:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    58fc:	8b 81       	ldd	r24, Y+3	; 0x03
    58fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5900:	0e 94 0b 31 	call	0x6216	; 0x6216 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    5904:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
    5908:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    590a:	8a 81       	ldd	r24, Y+2	; 0x02
    590c:	88 23       	and	r24, r24
    590e:	11 f4       	brne	.+4      	; 0x5914 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    5910:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
		}
	}
    5914:	28 96       	adiw	r28, 0x08	; 8
    5916:	0f b6       	in	r0, 0x3f	; 63
    5918:	f8 94       	cli
    591a:	de bf       	out	0x3e, r29	; 62
    591c:	0f be       	out	0x3f, r0	; 63
    591e:	cd bf       	out	0x3d, r28	; 61
    5920:	cf 91       	pop	r28
    5922:	df 91       	pop	r29
    5924:	08 95       	ret

00005926 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    5926:	df 93       	push	r29
    5928:	cf 93       	push	r28
    592a:	00 d0       	rcall	.+0      	; 0x592c <vTaskDelay+0x6>
    592c:	00 d0       	rcall	.+0      	; 0x592e <vTaskDelay+0x8>
    592e:	0f 92       	push	r0
    5930:	cd b7       	in	r28, 0x3d	; 61
    5932:	de b7       	in	r29, 0x3e	; 62
    5934:	9d 83       	std	Y+5, r25	; 0x05
    5936:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5938:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    593a:	8c 81       	ldd	r24, Y+4	; 0x04
    593c:	9d 81       	ldd	r25, Y+5	; 0x05
    593e:	00 97       	sbiw	r24, 0x00	; 0
    5940:	d1 f0       	breq	.+52     	; 0x5976 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    5942:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    5946:	20 91 a3 06 	lds	r18, 0x06A3
    594a:	30 91 a4 06 	lds	r19, 0x06A4
    594e:	8c 81       	ldd	r24, Y+4	; 0x04
    5950:	9d 81       	ldd	r25, Y+5	; 0x05
    5952:	82 0f       	add	r24, r18
    5954:	93 1f       	adc	r25, r19
    5956:	9b 83       	std	Y+3, r25	; 0x03
    5958:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    595a:	80 91 9f 06 	lds	r24, 0x069F
    595e:	90 91 a0 06 	lds	r25, 0x06A0
    5962:	02 96       	adiw	r24, 0x02	; 2
    5964:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5968:	8a 81       	ldd	r24, Y+2	; 0x02
    596a:	9b 81       	ldd	r25, Y+3	; 0x03
    596c:	0e 94 0b 31 	call	0x6216	; 0x6216 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5970:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>
    5974:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5976:	89 81       	ldd	r24, Y+1	; 0x01
    5978:	88 23       	and	r24, r24
    597a:	11 f4       	brne	.+4      	; 0x5980 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    597c:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
		}
	}
    5980:	0f 90       	pop	r0
    5982:	0f 90       	pop	r0
    5984:	0f 90       	pop	r0
    5986:	0f 90       	pop	r0
    5988:	0f 90       	pop	r0
    598a:	cf 91       	pop	r28
    598c:	df 91       	pop	r29
    598e:	08 95       	ret

00005990 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    5990:	af 92       	push	r10
    5992:	bf 92       	push	r11
    5994:	cf 92       	push	r12
    5996:	df 92       	push	r13
    5998:	ef 92       	push	r14
    599a:	ff 92       	push	r15
    599c:	0f 93       	push	r16
    599e:	df 93       	push	r29
    59a0:	cf 93       	push	r28
    59a2:	0f 92       	push	r0
    59a4:	cd b7       	in	r28, 0x3d	; 61
    59a6:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    59a8:	28 eb       	ldi	r18, 0xB8	; 184
    59aa:	30 e0       	ldi	r19, 0x00	; 0
    59ac:	8f e2       	ldi	r24, 0x2F	; 47
    59ae:	90 e3       	ldi	r25, 0x30	; 48
    59b0:	b9 01       	movw	r22, r18
    59b2:	45 e5       	ldi	r20, 0x55	; 85
    59b4:	50 e0       	ldi	r21, 0x00	; 0
    59b6:	20 e0       	ldi	r18, 0x00	; 0
    59b8:	30 e0       	ldi	r19, 0x00	; 0
    59ba:	00 e0       	ldi	r16, 0x00	; 0
    59bc:	ee 24       	eor	r14, r14
    59be:	ff 24       	eor	r15, r15
    59c0:	cc 24       	eor	r12, r12
    59c2:	dd 24       	eor	r13, r13
    59c4:	aa 24       	eor	r10, r10
    59c6:	bb 24       	eor	r11, r11
    59c8:	0e 94 cf 2a 	call	0x559e	; 0x559e <xTaskGenericCreate>
    59cc:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    59ce:	89 81       	ldd	r24, Y+1	; 0x01
    59d0:	81 30       	cpi	r24, 0x01	; 1
    59d2:	51 f4       	brne	.+20     	; 0x59e8 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    59d4:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    59d6:	81 e0       	ldi	r24, 0x01	; 1
    59d8:	80 93 a7 06 	sts	0x06A7, r24
		xTickCount = ( portTickType ) 0U;
    59dc:	10 92 a4 06 	sts	0x06A4, r1
    59e0:	10 92 a3 06 	sts	0x06A3, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    59e4:	0e 94 ff 24 	call	0x49fe	; 0x49fe <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    59e8:	0f 90       	pop	r0
    59ea:	cf 91       	pop	r28
    59ec:	df 91       	pop	r29
    59ee:	0f 91       	pop	r16
    59f0:	ff 90       	pop	r15
    59f2:	ef 90       	pop	r14
    59f4:	df 90       	pop	r13
    59f6:	cf 90       	pop	r12
    59f8:	bf 90       	pop	r11
    59fa:	af 90       	pop	r10
    59fc:	08 95       	ret

000059fe <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    59fe:	df 93       	push	r29
    5a00:	cf 93       	push	r28
    5a02:	cd b7       	in	r28, 0x3d	; 61
    5a04:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5a06:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    5a08:	10 92 a7 06 	sts	0x06A7, r1
	vPortEndScheduler();
    5a0c:	0e 94 34 25 	call	0x4a68	; 0x4a68 <vPortEndScheduler>
}
    5a10:	cf 91       	pop	r28
    5a12:	df 91       	pop	r29
    5a14:	08 95       	ret

00005a16 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    5a16:	df 93       	push	r29
    5a18:	cf 93       	push	r28
    5a1a:	cd b7       	in	r28, 0x3d	; 61
    5a1c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    5a1e:	80 91 a8 06 	lds	r24, 0x06A8
    5a22:	8f 5f       	subi	r24, 0xFF	; 255
    5a24:	80 93 a8 06 	sts	0x06A8, r24
}
    5a28:	cf 91       	pop	r28
    5a2a:	df 91       	pop	r29
    5a2c:	08 95       	ret

00005a2e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    5a2e:	df 93       	push	r29
    5a30:	cf 93       	push	r28
    5a32:	00 d0       	rcall	.+0      	; 0x5a34 <xTaskResumeAll+0x6>
    5a34:	00 d0       	rcall	.+0      	; 0x5a36 <xTaskResumeAll+0x8>
    5a36:	cd b7       	in	r28, 0x3d	; 61
    5a38:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    5a3a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5a3c:	0f b6       	in	r0, 0x3f	; 63
    5a3e:	f8 94       	cli
    5a40:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5a42:	80 91 a8 06 	lds	r24, 0x06A8
    5a46:	81 50       	subi	r24, 0x01	; 1
    5a48:	80 93 a8 06 	sts	0x06A8, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5a4c:	80 91 a8 06 	lds	r24, 0x06A8
    5a50:	88 23       	and	r24, r24
    5a52:	09 f0       	breq	.+2      	; 0x5a56 <xTaskResumeAll+0x28>
    5a54:	6c c0       	rjmp	.+216    	; 0x5b2e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    5a56:	80 91 a2 06 	lds	r24, 0x06A2
    5a5a:	88 23       	and	r24, r24
    5a5c:	09 f4       	brne	.+2      	; 0x5a60 <xTaskResumeAll+0x32>
    5a5e:	67 c0       	rjmp	.+206    	; 0x5b2e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    5a60:	19 82       	std	Y+1, r1	; 0x01
    5a62:	41 c0       	rjmp	.+130    	; 0x5ae6 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    5a64:	e0 91 fe 06 	lds	r30, 0x06FE
    5a68:	f0 91 ff 06 	lds	r31, 0x06FF
    5a6c:	86 81       	ldd	r24, Z+6	; 0x06
    5a6e:	97 81       	ldd	r25, Z+7	; 0x07
    5a70:	9c 83       	std	Y+4, r25	; 0x04
    5a72:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    5a74:	8b 81       	ldd	r24, Y+3	; 0x03
    5a76:	9c 81       	ldd	r25, Y+4	; 0x04
    5a78:	0c 96       	adiw	r24, 0x0c	; 12
    5a7a:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    5a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a80:	9c 81       	ldd	r25, Y+4	; 0x04
    5a82:	02 96       	adiw	r24, 0x02	; 2
    5a84:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    5a88:	eb 81       	ldd	r30, Y+3	; 0x03
    5a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a8c:	96 89       	ldd	r25, Z+22	; 0x16
    5a8e:	80 91 a6 06 	lds	r24, 0x06A6
    5a92:	89 17       	cp	r24, r25
    5a94:	28 f4       	brcc	.+10     	; 0x5aa0 <xTaskResumeAll+0x72>
    5a96:	eb 81       	ldd	r30, Y+3	; 0x03
    5a98:	fc 81       	ldd	r31, Y+4	; 0x04
    5a9a:	86 89       	ldd	r24, Z+22	; 0x16
    5a9c:	80 93 a6 06 	sts	0x06A6, r24
    5aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    5aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    5aa4:	86 89       	ldd	r24, Z+22	; 0x16
    5aa6:	28 2f       	mov	r18, r24
    5aa8:	30 e0       	ldi	r19, 0x00	; 0
    5aaa:	c9 01       	movw	r24, r18
    5aac:	88 0f       	add	r24, r24
    5aae:	99 1f       	adc	r25, r25
    5ab0:	88 0f       	add	r24, r24
    5ab2:	99 1f       	adc	r25, r25
    5ab4:	88 0f       	add	r24, r24
    5ab6:	99 1f       	adc	r25, r25
    5ab8:	82 0f       	add	r24, r18
    5aba:	93 1f       	adc	r25, r19
    5abc:	83 55       	subi	r24, 0x53	; 83
    5abe:	99 4f       	sbci	r25, 0xF9	; 249
    5ac0:	2b 81       	ldd	r18, Y+3	; 0x03
    5ac2:	3c 81       	ldd	r19, Y+4	; 0x04
    5ac4:	2e 5f       	subi	r18, 0xFE	; 254
    5ac6:	3f 4f       	sbci	r19, 0xFF	; 255
    5ac8:	b9 01       	movw	r22, r18
    5aca:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5ace:	eb 81       	ldd	r30, Y+3	; 0x03
    5ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    5ad2:	96 89       	ldd	r25, Z+22	; 0x16
    5ad4:	e0 91 9f 06 	lds	r30, 0x069F
    5ad8:	f0 91 a0 06 	lds	r31, 0x06A0
    5adc:	86 89       	ldd	r24, Z+22	; 0x16
    5ade:	98 17       	cp	r25, r24
    5ae0:	10 f0       	brcs	.+4      	; 0x5ae6 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    5ae2:	81 e0       	ldi	r24, 0x01	; 1
    5ae4:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    5ae6:	80 91 f9 06 	lds	r24, 0x06F9
    5aea:	88 23       	and	r24, r24
    5aec:	09 f0       	breq	.+2      	; 0x5af0 <xTaskResumeAll+0xc2>
    5aee:	ba cf       	rjmp	.-140    	; 0x5a64 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5af0:	80 91 a9 06 	lds	r24, 0x06A9
    5af4:	88 23       	and	r24, r24
    5af6:	71 f0       	breq	.+28     	; 0x5b14 <xTaskResumeAll+0xe6>
    5af8:	07 c0       	rjmp	.+14     	; 0x5b08 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    5afa:	0e 94 d6 2d 	call	0x5bac	; 0x5bac <vTaskIncrementTick>
						--uxMissedTicks;
    5afe:	80 91 a9 06 	lds	r24, 0x06A9
    5b02:	81 50       	subi	r24, 0x01	; 1
    5b04:	80 93 a9 06 	sts	0x06A9, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5b08:	80 91 a9 06 	lds	r24, 0x06A9
    5b0c:	88 23       	and	r24, r24
    5b0e:	a9 f7       	brne	.-22     	; 0x5afa <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    5b14:	89 81       	ldd	r24, Y+1	; 0x01
    5b16:	81 30       	cpi	r24, 0x01	; 1
    5b18:	21 f0       	breq	.+8      	; 0x5b22 <xTaskResumeAll+0xf4>
    5b1a:	80 91 aa 06 	lds	r24, 0x06AA
    5b1e:	81 30       	cpi	r24, 0x01	; 1
    5b20:	31 f4       	brne	.+12     	; 0x5b2e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    5b22:	81 e0       	ldi	r24, 0x01	; 1
    5b24:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    5b26:	10 92 aa 06 	sts	0x06AA, r1
					portYIELD_WITHIN_API();
    5b2a:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    5b2e:	0f 90       	pop	r0
    5b30:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    5b32:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5b34:	0f 90       	pop	r0
    5b36:	0f 90       	pop	r0
    5b38:	0f 90       	pop	r0
    5b3a:	0f 90       	pop	r0
    5b3c:	cf 91       	pop	r28
    5b3e:	df 91       	pop	r29
    5b40:	08 95       	ret

00005b42 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    5b42:	df 93       	push	r29
    5b44:	cf 93       	push	r28
    5b46:	00 d0       	rcall	.+0      	; 0x5b48 <xTaskGetTickCount+0x6>
    5b48:	cd b7       	in	r28, 0x3d	; 61
    5b4a:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    5b4c:	0f b6       	in	r0, 0x3f	; 63
    5b4e:	f8 94       	cli
    5b50:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5b52:	80 91 a3 06 	lds	r24, 0x06A3
    5b56:	90 91 a4 06 	lds	r25, 0x06A4
    5b5a:	9a 83       	std	Y+2, r25	; 0x02
    5b5c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5b5e:	0f 90       	pop	r0
    5b60:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5b62:	89 81       	ldd	r24, Y+1	; 0x01
    5b64:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5b66:	0f 90       	pop	r0
    5b68:	0f 90       	pop	r0
    5b6a:	cf 91       	pop	r28
    5b6c:	df 91       	pop	r29
    5b6e:	08 95       	ret

00005b70 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    5b70:	df 93       	push	r29
    5b72:	cf 93       	push	r28
    5b74:	00 d0       	rcall	.+0      	; 0x5b76 <xTaskGetTickCountFromISR+0x6>
    5b76:	0f 92       	push	r0
    5b78:	cd b7       	in	r28, 0x3d	; 61
    5b7a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5b7c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    5b7e:	80 91 a3 06 	lds	r24, 0x06A3
    5b82:	90 91 a4 06 	lds	r25, 0x06A4
    5b86:	9b 83       	std	Y+3, r25	; 0x03
    5b88:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5b8a:	8a 81       	ldd	r24, Y+2	; 0x02
    5b8c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5b8e:	0f 90       	pop	r0
    5b90:	0f 90       	pop	r0
    5b92:	0f 90       	pop	r0
    5b94:	cf 91       	pop	r28
    5b96:	df 91       	pop	r29
    5b98:	08 95       	ret

00005b9a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    5b9a:	df 93       	push	r29
    5b9c:	cf 93       	push	r28
    5b9e:	cd b7       	in	r28, 0x3d	; 61
    5ba0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    5ba2:	80 91 a2 06 	lds	r24, 0x06A2
}
    5ba6:	cf 91       	pop	r28
    5ba8:	df 91       	pop	r29
    5baa:	08 95       	ret

00005bac <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    5bac:	df 93       	push	r29
    5bae:	cf 93       	push	r28
    5bb0:	00 d0       	rcall	.+0      	; 0x5bb2 <vTaskIncrementTick+0x6>
    5bb2:	00 d0       	rcall	.+0      	; 0x5bb4 <vTaskIncrementTick+0x8>
    5bb4:	00 d0       	rcall	.+0      	; 0x5bb6 <vTaskIncrementTick+0xa>
    5bb6:	cd b7       	in	r28, 0x3d	; 61
    5bb8:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5bba:	80 91 a8 06 	lds	r24, 0x06A8
    5bbe:	88 23       	and	r24, r24
    5bc0:	09 f0       	breq	.+2      	; 0x5bc4 <vTaskIncrementTick+0x18>
    5bc2:	bb c0       	rjmp	.+374    	; 0x5d3a <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    5bc4:	80 91 a3 06 	lds	r24, 0x06A3
    5bc8:	90 91 a4 06 	lds	r25, 0x06A4
    5bcc:	01 96       	adiw	r24, 0x01	; 1
    5bce:	90 93 a4 06 	sts	0x06A4, r25
    5bd2:	80 93 a3 06 	sts	0x06A3, r24
		if( xTickCount == ( portTickType ) 0U )
    5bd6:	80 91 a3 06 	lds	r24, 0x06A3
    5bda:	90 91 a4 06 	lds	r25, 0x06A4
    5bde:	00 97       	sbiw	r24, 0x00	; 0
    5be0:	d1 f5       	brne	.+116    	; 0x5c56 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    5be2:	80 91 f5 06 	lds	r24, 0x06F5
    5be6:	90 91 f6 06 	lds	r25, 0x06F6
    5bea:	9c 83       	std	Y+4, r25	; 0x04
    5bec:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    5bee:	80 91 f7 06 	lds	r24, 0x06F7
    5bf2:	90 91 f8 06 	lds	r25, 0x06F8
    5bf6:	90 93 f6 06 	sts	0x06F6, r25
    5bfa:	80 93 f5 06 	sts	0x06F5, r24
			pxOverflowDelayedTaskList = pxTemp;
    5bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    5c00:	9c 81       	ldd	r25, Y+4	; 0x04
    5c02:	90 93 f8 06 	sts	0x06F8, r25
    5c06:	80 93 f7 06 	sts	0x06F7, r24
			xNumOfOverflows++;
    5c0a:	80 91 ab 06 	lds	r24, 0x06AB
    5c0e:	8f 5f       	subi	r24, 0xFF	; 255
    5c10:	80 93 ab 06 	sts	0x06AB, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5c14:	e0 91 f5 06 	lds	r30, 0x06F5
    5c18:	f0 91 f6 06 	lds	r31, 0x06F6
    5c1c:	80 81       	ld	r24, Z
    5c1e:	88 23       	and	r24, r24
    5c20:	39 f4       	brne	.+14     	; 0x5c30 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    5c22:	8f ef       	ldi	r24, 0xFF	; 255
    5c24:	9f ef       	ldi	r25, 0xFF	; 255
    5c26:	90 93 36 01 	sts	0x0136, r25
    5c2a:	80 93 35 01 	sts	0x0135, r24
    5c2e:	13 c0       	rjmp	.+38     	; 0x5c56 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5c30:	e0 91 f5 06 	lds	r30, 0x06F5
    5c34:	f0 91 f6 06 	lds	r31, 0x06F6
    5c38:	05 80       	ldd	r0, Z+5	; 0x05
    5c3a:	f6 81       	ldd	r31, Z+6	; 0x06
    5c3c:	e0 2d       	mov	r30, r0
    5c3e:	86 81       	ldd	r24, Z+6	; 0x06
    5c40:	97 81       	ldd	r25, Z+7	; 0x07
    5c42:	9e 83       	std	Y+6, r25	; 0x06
    5c44:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5c46:	ed 81       	ldd	r30, Y+5	; 0x05
    5c48:	fe 81       	ldd	r31, Y+6	; 0x06
    5c4a:	82 81       	ldd	r24, Z+2	; 0x02
    5c4c:	93 81       	ldd	r25, Z+3	; 0x03
    5c4e:	90 93 36 01 	sts	0x0136, r25
    5c52:	80 93 35 01 	sts	0x0135, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    5c56:	20 91 a3 06 	lds	r18, 0x06A3
    5c5a:	30 91 a4 06 	lds	r19, 0x06A4
    5c5e:	80 91 35 01 	lds	r24, 0x0135
    5c62:	90 91 36 01 	lds	r25, 0x0136
    5c66:	28 17       	cp	r18, r24
    5c68:	39 07       	cpc	r19, r25
    5c6a:	08 f4       	brcc	.+2      	; 0x5c6e <vTaskIncrementTick+0xc2>
    5c6c:	6b c0       	rjmp	.+214    	; 0x5d44 <vTaskIncrementTick+0x198>
    5c6e:	e0 91 f5 06 	lds	r30, 0x06F5
    5c72:	f0 91 f6 06 	lds	r31, 0x06F6
    5c76:	80 81       	ld	r24, Z
    5c78:	88 23       	and	r24, r24
    5c7a:	39 f4       	brne	.+14     	; 0x5c8a <vTaskIncrementTick+0xde>
    5c7c:	8f ef       	ldi	r24, 0xFF	; 255
    5c7e:	9f ef       	ldi	r25, 0xFF	; 255
    5c80:	90 93 36 01 	sts	0x0136, r25
    5c84:	80 93 35 01 	sts	0x0135, r24
    5c88:	5d c0       	rjmp	.+186    	; 0x5d44 <vTaskIncrementTick+0x198>
    5c8a:	e0 91 f5 06 	lds	r30, 0x06F5
    5c8e:	f0 91 f6 06 	lds	r31, 0x06F6
    5c92:	05 80       	ldd	r0, Z+5	; 0x05
    5c94:	f6 81       	ldd	r31, Z+6	; 0x06
    5c96:	e0 2d       	mov	r30, r0
    5c98:	86 81       	ldd	r24, Z+6	; 0x06
    5c9a:	97 81       	ldd	r25, Z+7	; 0x07
    5c9c:	9e 83       	std	Y+6, r25	; 0x06
    5c9e:	8d 83       	std	Y+5, r24	; 0x05
    5ca0:	ed 81       	ldd	r30, Y+5	; 0x05
    5ca2:	fe 81       	ldd	r31, Y+6	; 0x06
    5ca4:	82 81       	ldd	r24, Z+2	; 0x02
    5ca6:	93 81       	ldd	r25, Z+3	; 0x03
    5ca8:	9a 83       	std	Y+2, r25	; 0x02
    5caa:	89 83       	std	Y+1, r24	; 0x01
    5cac:	20 91 a3 06 	lds	r18, 0x06A3
    5cb0:	30 91 a4 06 	lds	r19, 0x06A4
    5cb4:	89 81       	ldd	r24, Y+1	; 0x01
    5cb6:	9a 81       	ldd	r25, Y+2	; 0x02
    5cb8:	28 17       	cp	r18, r24
    5cba:	39 07       	cpc	r19, r25
    5cbc:	38 f4       	brcc	.+14     	; 0x5ccc <vTaskIncrementTick+0x120>
    5cbe:	89 81       	ldd	r24, Y+1	; 0x01
    5cc0:	9a 81       	ldd	r25, Y+2	; 0x02
    5cc2:	90 93 36 01 	sts	0x0136, r25
    5cc6:	80 93 35 01 	sts	0x0135, r24
    5cca:	3c c0       	rjmp	.+120    	; 0x5d44 <vTaskIncrementTick+0x198>
    5ccc:	8d 81       	ldd	r24, Y+5	; 0x05
    5cce:	9e 81       	ldd	r25, Y+6	; 0x06
    5cd0:	02 96       	adiw	r24, 0x02	; 2
    5cd2:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
    5cd6:	ed 81       	ldd	r30, Y+5	; 0x05
    5cd8:	fe 81       	ldd	r31, Y+6	; 0x06
    5cda:	84 89       	ldd	r24, Z+20	; 0x14
    5cdc:	95 89       	ldd	r25, Z+21	; 0x15
    5cde:	00 97       	sbiw	r24, 0x00	; 0
    5ce0:	29 f0       	breq	.+10     	; 0x5cec <vTaskIncrementTick+0x140>
    5ce2:	8d 81       	ldd	r24, Y+5	; 0x05
    5ce4:	9e 81       	ldd	r25, Y+6	; 0x06
    5ce6:	0c 96       	adiw	r24, 0x0c	; 12
    5ce8:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
    5cec:	ed 81       	ldd	r30, Y+5	; 0x05
    5cee:	fe 81       	ldd	r31, Y+6	; 0x06
    5cf0:	96 89       	ldd	r25, Z+22	; 0x16
    5cf2:	80 91 a6 06 	lds	r24, 0x06A6
    5cf6:	89 17       	cp	r24, r25
    5cf8:	28 f4       	brcc	.+10     	; 0x5d04 <vTaskIncrementTick+0x158>
    5cfa:	ed 81       	ldd	r30, Y+5	; 0x05
    5cfc:	fe 81       	ldd	r31, Y+6	; 0x06
    5cfe:	86 89       	ldd	r24, Z+22	; 0x16
    5d00:	80 93 a6 06 	sts	0x06A6, r24
    5d04:	ed 81       	ldd	r30, Y+5	; 0x05
    5d06:	fe 81       	ldd	r31, Y+6	; 0x06
    5d08:	86 89       	ldd	r24, Z+22	; 0x16
    5d0a:	28 2f       	mov	r18, r24
    5d0c:	30 e0       	ldi	r19, 0x00	; 0
    5d0e:	c9 01       	movw	r24, r18
    5d10:	88 0f       	add	r24, r24
    5d12:	99 1f       	adc	r25, r25
    5d14:	88 0f       	add	r24, r24
    5d16:	99 1f       	adc	r25, r25
    5d18:	88 0f       	add	r24, r24
    5d1a:	99 1f       	adc	r25, r25
    5d1c:	82 0f       	add	r24, r18
    5d1e:	93 1f       	adc	r25, r19
    5d20:	ac 01       	movw	r20, r24
    5d22:	43 55       	subi	r20, 0x53	; 83
    5d24:	59 4f       	sbci	r21, 0xF9	; 249
    5d26:	8d 81       	ldd	r24, Y+5	; 0x05
    5d28:	9e 81       	ldd	r25, Y+6	; 0x06
    5d2a:	9c 01       	movw	r18, r24
    5d2c:	2e 5f       	subi	r18, 0xFE	; 254
    5d2e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d30:	ca 01       	movw	r24, r20
    5d32:	b9 01       	movw	r22, r18
    5d34:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>
    5d38:	9a cf       	rjmp	.-204    	; 0x5c6e <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    5d3a:	80 91 a9 06 	lds	r24, 0x06A9
    5d3e:	8f 5f       	subi	r24, 0xFF	; 255
    5d40:	80 93 a9 06 	sts	0x06A9, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    5d44:	26 96       	adiw	r28, 0x06	; 6
    5d46:	0f b6       	in	r0, 0x3f	; 63
    5d48:	f8 94       	cli
    5d4a:	de bf       	out	0x3e, r29	; 62
    5d4c:	0f be       	out	0x3f, r0	; 63
    5d4e:	cd bf       	out	0x3d, r28	; 61
    5d50:	cf 91       	pop	r28
    5d52:	df 91       	pop	r29
    5d54:	08 95       	ret

00005d56 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5d56:	df 93       	push	r29
    5d58:	cf 93       	push	r28
    5d5a:	00 d0       	rcall	.+0      	; 0x5d5c <vTaskSwitchContext+0x6>
    5d5c:	cd b7       	in	r28, 0x3d	; 61
    5d5e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    5d60:	80 91 a8 06 	lds	r24, 0x06A8
    5d64:	88 23       	and	r24, r24
    5d66:	49 f0       	breq	.+18     	; 0x5d7a <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5d68:	81 e0       	ldi	r24, 0x01	; 1
    5d6a:	80 93 aa 06 	sts	0x06AA, r24
    5d6e:	54 c0       	rjmp	.+168    	; 0x5e18 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    5d70:	80 91 a6 06 	lds	r24, 0x06A6
    5d74:	81 50       	subi	r24, 0x01	; 1
    5d76:	80 93 a6 06 	sts	0x06A6, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    5d7a:	80 91 a6 06 	lds	r24, 0x06A6
    5d7e:	28 2f       	mov	r18, r24
    5d80:	30 e0       	ldi	r19, 0x00	; 0
    5d82:	c9 01       	movw	r24, r18
    5d84:	88 0f       	add	r24, r24
    5d86:	99 1f       	adc	r25, r25
    5d88:	88 0f       	add	r24, r24
    5d8a:	99 1f       	adc	r25, r25
    5d8c:	88 0f       	add	r24, r24
    5d8e:	99 1f       	adc	r25, r25
    5d90:	82 0f       	add	r24, r18
    5d92:	93 1f       	adc	r25, r19
    5d94:	fc 01       	movw	r30, r24
    5d96:	e3 55       	subi	r30, 0x53	; 83
    5d98:	f9 4f       	sbci	r31, 0xF9	; 249
    5d9a:	80 81       	ld	r24, Z
    5d9c:	88 23       	and	r24, r24
    5d9e:	41 f3       	breq	.-48     	; 0x5d70 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    5da0:	80 91 a6 06 	lds	r24, 0x06A6
    5da4:	28 2f       	mov	r18, r24
    5da6:	30 e0       	ldi	r19, 0x00	; 0
    5da8:	c9 01       	movw	r24, r18
    5daa:	88 0f       	add	r24, r24
    5dac:	99 1f       	adc	r25, r25
    5dae:	88 0f       	add	r24, r24
    5db0:	99 1f       	adc	r25, r25
    5db2:	88 0f       	add	r24, r24
    5db4:	99 1f       	adc	r25, r25
    5db6:	82 0f       	add	r24, r18
    5db8:	93 1f       	adc	r25, r19
    5dba:	83 55       	subi	r24, 0x53	; 83
    5dbc:	99 4f       	sbci	r25, 0xF9	; 249
    5dbe:	9a 83       	std	Y+2, r25	; 0x02
    5dc0:	89 83       	std	Y+1, r24	; 0x01
    5dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    5dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    5dc6:	01 80       	ldd	r0, Z+1	; 0x01
    5dc8:	f2 81       	ldd	r31, Z+2	; 0x02
    5dca:	e0 2d       	mov	r30, r0
    5dcc:	82 81       	ldd	r24, Z+2	; 0x02
    5dce:	93 81       	ldd	r25, Z+3	; 0x03
    5dd0:	e9 81       	ldd	r30, Y+1	; 0x01
    5dd2:	fa 81       	ldd	r31, Y+2	; 0x02
    5dd4:	92 83       	std	Z+2, r25	; 0x02
    5dd6:	81 83       	std	Z+1, r24	; 0x01
    5dd8:	e9 81       	ldd	r30, Y+1	; 0x01
    5dda:	fa 81       	ldd	r31, Y+2	; 0x02
    5ddc:	21 81       	ldd	r18, Z+1	; 0x01
    5dde:	32 81       	ldd	r19, Z+2	; 0x02
    5de0:	89 81       	ldd	r24, Y+1	; 0x01
    5de2:	9a 81       	ldd	r25, Y+2	; 0x02
    5de4:	03 96       	adiw	r24, 0x03	; 3
    5de6:	28 17       	cp	r18, r24
    5de8:	39 07       	cpc	r19, r25
    5dea:	59 f4       	brne	.+22     	; 0x5e02 <vTaskSwitchContext+0xac>
    5dec:	e9 81       	ldd	r30, Y+1	; 0x01
    5dee:	fa 81       	ldd	r31, Y+2	; 0x02
    5df0:	01 80       	ldd	r0, Z+1	; 0x01
    5df2:	f2 81       	ldd	r31, Z+2	; 0x02
    5df4:	e0 2d       	mov	r30, r0
    5df6:	82 81       	ldd	r24, Z+2	; 0x02
    5df8:	93 81       	ldd	r25, Z+3	; 0x03
    5dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    5dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    5dfe:	92 83       	std	Z+2, r25	; 0x02
    5e00:	81 83       	std	Z+1, r24	; 0x01
    5e02:	e9 81       	ldd	r30, Y+1	; 0x01
    5e04:	fa 81       	ldd	r31, Y+2	; 0x02
    5e06:	01 80       	ldd	r0, Z+1	; 0x01
    5e08:	f2 81       	ldd	r31, Z+2	; 0x02
    5e0a:	e0 2d       	mov	r30, r0
    5e0c:	86 81       	ldd	r24, Z+6	; 0x06
    5e0e:	97 81       	ldd	r25, Z+7	; 0x07
    5e10:	90 93 a0 06 	sts	0x06A0, r25
    5e14:	80 93 9f 06 	sts	0x069F, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    5e18:	0f 90       	pop	r0
    5e1a:	0f 90       	pop	r0
    5e1c:	cf 91       	pop	r28
    5e1e:	df 91       	pop	r29
    5e20:	08 95       	ret

00005e22 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    5e22:	df 93       	push	r29
    5e24:	cf 93       	push	r28
    5e26:	00 d0       	rcall	.+0      	; 0x5e28 <vTaskPlaceOnEventList+0x6>
    5e28:	00 d0       	rcall	.+0      	; 0x5e2a <vTaskPlaceOnEventList+0x8>
    5e2a:	00 d0       	rcall	.+0      	; 0x5e2c <vTaskPlaceOnEventList+0xa>
    5e2c:	cd b7       	in	r28, 0x3d	; 61
    5e2e:	de b7       	in	r29, 0x3e	; 62
    5e30:	9c 83       	std	Y+4, r25	; 0x04
    5e32:	8b 83       	std	Y+3, r24	; 0x03
    5e34:	7e 83       	std	Y+6, r23	; 0x06
    5e36:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5e38:	4b 81       	ldd	r20, Y+3	; 0x03
    5e3a:	5c 81       	ldd	r21, Y+4	; 0x04
    5e3c:	80 91 9f 06 	lds	r24, 0x069F
    5e40:	90 91 a0 06 	lds	r25, 0x06A0
    5e44:	9c 01       	movw	r18, r24
    5e46:	24 5f       	subi	r18, 0xF4	; 244
    5e48:	3f 4f       	sbci	r19, 0xFF	; 255
    5e4a:	ca 01       	movw	r24, r20
    5e4c:	b9 01       	movw	r22, r18
    5e4e:	0e 94 c7 22 	call	0x458e	; 0x458e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5e52:	80 91 9f 06 	lds	r24, 0x069F
    5e56:	90 91 a0 06 	lds	r25, 0x06A0
    5e5a:	02 96       	adiw	r24, 0x02	; 2
    5e5c:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    5e60:	20 91 a3 06 	lds	r18, 0x06A3
    5e64:	30 91 a4 06 	lds	r19, 0x06A4
    5e68:	8d 81       	ldd	r24, Y+5	; 0x05
    5e6a:	9e 81       	ldd	r25, Y+6	; 0x06
    5e6c:	82 0f       	add	r24, r18
    5e6e:	93 1f       	adc	r25, r19
    5e70:	9a 83       	std	Y+2, r25	; 0x02
    5e72:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5e74:	89 81       	ldd	r24, Y+1	; 0x01
    5e76:	9a 81       	ldd	r25, Y+2	; 0x02
    5e78:	0e 94 0b 31 	call	0x6216	; 0x6216 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    5e7c:	26 96       	adiw	r28, 0x06	; 6
    5e7e:	0f b6       	in	r0, 0x3f	; 63
    5e80:	f8 94       	cli
    5e82:	de bf       	out	0x3e, r29	; 62
    5e84:	0f be       	out	0x3f, r0	; 63
    5e86:	cd bf       	out	0x3d, r28	; 61
    5e88:	cf 91       	pop	r28
    5e8a:	df 91       	pop	r29
    5e8c:	08 95       	ret

00005e8e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    5e8e:	df 93       	push	r29
    5e90:	cf 93       	push	r28
    5e92:	00 d0       	rcall	.+0      	; 0x5e94 <xTaskRemoveFromEventList+0x6>
    5e94:	00 d0       	rcall	.+0      	; 0x5e96 <xTaskRemoveFromEventList+0x8>
    5e96:	0f 92       	push	r0
    5e98:	cd b7       	in	r28, 0x3d	; 61
    5e9a:	de b7       	in	r29, 0x3e	; 62
    5e9c:	9d 83       	std	Y+5, r25	; 0x05
    5e9e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5ea0:	ec 81       	ldd	r30, Y+4	; 0x04
    5ea2:	fd 81       	ldd	r31, Y+5	; 0x05
    5ea4:	05 80       	ldd	r0, Z+5	; 0x05
    5ea6:	f6 81       	ldd	r31, Z+6	; 0x06
    5ea8:	e0 2d       	mov	r30, r0
    5eaa:	86 81       	ldd	r24, Z+6	; 0x06
    5eac:	97 81       	ldd	r25, Z+7	; 0x07
    5eae:	9b 83       	std	Y+3, r25	; 0x03
    5eb0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb4:	9b 81       	ldd	r25, Y+3	; 0x03
    5eb6:	0c 96       	adiw	r24, 0x0c	; 12
    5eb8:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5ebc:	80 91 a8 06 	lds	r24, 0x06A8
    5ec0:	88 23       	and	r24, r24
    5ec2:	61 f5       	brne	.+88     	; 0x5f1c <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ec8:	02 96       	adiw	r24, 0x02	; 2
    5eca:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    5ece:	ea 81       	ldd	r30, Y+2	; 0x02
    5ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    5ed2:	96 89       	ldd	r25, Z+22	; 0x16
    5ed4:	80 91 a6 06 	lds	r24, 0x06A6
    5ed8:	89 17       	cp	r24, r25
    5eda:	28 f4       	brcc	.+10     	; 0x5ee6 <xTaskRemoveFromEventList+0x58>
    5edc:	ea 81       	ldd	r30, Y+2	; 0x02
    5ede:	fb 81       	ldd	r31, Y+3	; 0x03
    5ee0:	86 89       	ldd	r24, Z+22	; 0x16
    5ee2:	80 93 a6 06 	sts	0x06A6, r24
    5ee6:	ea 81       	ldd	r30, Y+2	; 0x02
    5ee8:	fb 81       	ldd	r31, Y+3	; 0x03
    5eea:	86 89       	ldd	r24, Z+22	; 0x16
    5eec:	28 2f       	mov	r18, r24
    5eee:	30 e0       	ldi	r19, 0x00	; 0
    5ef0:	c9 01       	movw	r24, r18
    5ef2:	88 0f       	add	r24, r24
    5ef4:	99 1f       	adc	r25, r25
    5ef6:	88 0f       	add	r24, r24
    5ef8:	99 1f       	adc	r25, r25
    5efa:	88 0f       	add	r24, r24
    5efc:	99 1f       	adc	r25, r25
    5efe:	82 0f       	add	r24, r18
    5f00:	93 1f       	adc	r25, r19
    5f02:	ac 01       	movw	r20, r24
    5f04:	43 55       	subi	r20, 0x53	; 83
    5f06:	59 4f       	sbci	r21, 0xF9	; 249
    5f08:	8a 81       	ldd	r24, Y+2	; 0x02
    5f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    5f0c:	9c 01       	movw	r18, r24
    5f0e:	2e 5f       	subi	r18, 0xFE	; 254
    5f10:	3f 4f       	sbci	r19, 0xFF	; 255
    5f12:	ca 01       	movw	r24, r20
    5f14:	b9 01       	movw	r22, r18
    5f16:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>
    5f1a:	0a c0       	rjmp	.+20     	; 0x5f30 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f1e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f20:	9c 01       	movw	r18, r24
    5f22:	24 5f       	subi	r18, 0xF4	; 244
    5f24:	3f 4f       	sbci	r19, 0xFF	; 255
    5f26:	89 ef       	ldi	r24, 0xF9	; 249
    5f28:	96 e0       	ldi	r25, 0x06	; 6
    5f2a:	b9 01       	movw	r22, r18
    5f2c:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5f30:	ea 81       	ldd	r30, Y+2	; 0x02
    5f32:	fb 81       	ldd	r31, Y+3	; 0x03
    5f34:	96 89       	ldd	r25, Z+22	; 0x16
    5f36:	e0 91 9f 06 	lds	r30, 0x069F
    5f3a:	f0 91 a0 06 	lds	r31, 0x06A0
    5f3e:	86 89       	ldd	r24, Z+22	; 0x16
    5f40:	98 17       	cp	r25, r24
    5f42:	18 f0       	brcs	.+6      	; 0x5f4a <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5f44:	81 e0       	ldi	r24, 0x01	; 1
    5f46:	89 83       	std	Y+1, r24	; 0x01
    5f48:	01 c0       	rjmp	.+2      	; 0x5f4c <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    5f4a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5f4c:	89 81       	ldd	r24, Y+1	; 0x01
}
    5f4e:	0f 90       	pop	r0
    5f50:	0f 90       	pop	r0
    5f52:	0f 90       	pop	r0
    5f54:	0f 90       	pop	r0
    5f56:	0f 90       	pop	r0
    5f58:	cf 91       	pop	r28
    5f5a:	df 91       	pop	r29
    5f5c:	08 95       	ret

00005f5e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    5f5e:	df 93       	push	r29
    5f60:	cf 93       	push	r28
    5f62:	00 d0       	rcall	.+0      	; 0x5f64 <vTaskSetTimeOutState+0x6>
    5f64:	cd b7       	in	r28, 0x3d	; 61
    5f66:	de b7       	in	r29, 0x3e	; 62
    5f68:	9a 83       	std	Y+2, r25	; 0x02
    5f6a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5f6c:	80 91 ab 06 	lds	r24, 0x06AB
    5f70:	e9 81       	ldd	r30, Y+1	; 0x01
    5f72:	fa 81       	ldd	r31, Y+2	; 0x02
    5f74:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5f76:	80 91 a3 06 	lds	r24, 0x06A3
    5f7a:	90 91 a4 06 	lds	r25, 0x06A4
    5f7e:	e9 81       	ldd	r30, Y+1	; 0x01
    5f80:	fa 81       	ldd	r31, Y+2	; 0x02
    5f82:	92 83       	std	Z+2, r25	; 0x02
    5f84:	81 83       	std	Z+1, r24	; 0x01
}
    5f86:	0f 90       	pop	r0
    5f88:	0f 90       	pop	r0
    5f8a:	cf 91       	pop	r28
    5f8c:	df 91       	pop	r29
    5f8e:	08 95       	ret

00005f90 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    5f90:	df 93       	push	r29
    5f92:	cf 93       	push	r28
    5f94:	00 d0       	rcall	.+0      	; 0x5f96 <xTaskCheckForTimeOut+0x6>
    5f96:	00 d0       	rcall	.+0      	; 0x5f98 <xTaskCheckForTimeOut+0x8>
    5f98:	0f 92       	push	r0
    5f9a:	cd b7       	in	r28, 0x3d	; 61
    5f9c:	de b7       	in	r29, 0x3e	; 62
    5f9e:	9b 83       	std	Y+3, r25	; 0x03
    5fa0:	8a 83       	std	Y+2, r24	; 0x02
    5fa2:	7d 83       	std	Y+5, r23	; 0x05
    5fa4:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5fa6:	0f b6       	in	r0, 0x3f	; 63
    5fa8:	f8 94       	cli
    5faa:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    5fac:	ea 81       	ldd	r30, Y+2	; 0x02
    5fae:	fb 81       	ldd	r31, Y+3	; 0x03
    5fb0:	90 81       	ld	r25, Z
    5fb2:	80 91 ab 06 	lds	r24, 0x06AB
    5fb6:	98 17       	cp	r25, r24
    5fb8:	71 f0       	breq	.+28     	; 0x5fd6 <xTaskCheckForTimeOut+0x46>
    5fba:	ea 81       	ldd	r30, Y+2	; 0x02
    5fbc:	fb 81       	ldd	r31, Y+3	; 0x03
    5fbe:	21 81       	ldd	r18, Z+1	; 0x01
    5fc0:	32 81       	ldd	r19, Z+2	; 0x02
    5fc2:	80 91 a3 06 	lds	r24, 0x06A3
    5fc6:	90 91 a4 06 	lds	r25, 0x06A4
    5fca:	82 17       	cp	r24, r18
    5fcc:	93 07       	cpc	r25, r19
    5fce:	18 f0       	brcs	.+6      	; 0x5fd6 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    5fd0:	81 e0       	ldi	r24, 0x01	; 1
    5fd2:	89 83       	std	Y+1, r24	; 0x01
    5fd4:	2f c0       	rjmp	.+94     	; 0x6034 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5fd6:	20 91 a3 06 	lds	r18, 0x06A3
    5fda:	30 91 a4 06 	lds	r19, 0x06A4
    5fde:	ea 81       	ldd	r30, Y+2	; 0x02
    5fe0:	fb 81       	ldd	r31, Y+3	; 0x03
    5fe2:	81 81       	ldd	r24, Z+1	; 0x01
    5fe4:	92 81       	ldd	r25, Z+2	; 0x02
    5fe6:	28 1b       	sub	r18, r24
    5fe8:	39 0b       	sbc	r19, r25
    5fea:	ec 81       	ldd	r30, Y+4	; 0x04
    5fec:	fd 81       	ldd	r31, Y+5	; 0x05
    5fee:	80 81       	ld	r24, Z
    5ff0:	91 81       	ldd	r25, Z+1	; 0x01
    5ff2:	28 17       	cp	r18, r24
    5ff4:	39 07       	cpc	r19, r25
    5ff6:	e0 f4       	brcc	.+56     	; 0x6030 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5ff8:	ec 81       	ldd	r30, Y+4	; 0x04
    5ffa:	fd 81       	ldd	r31, Y+5	; 0x05
    5ffc:	40 81       	ld	r20, Z
    5ffe:	51 81       	ldd	r21, Z+1	; 0x01
    6000:	ea 81       	ldd	r30, Y+2	; 0x02
    6002:	fb 81       	ldd	r31, Y+3	; 0x03
    6004:	21 81       	ldd	r18, Z+1	; 0x01
    6006:	32 81       	ldd	r19, Z+2	; 0x02
    6008:	80 91 a3 06 	lds	r24, 0x06A3
    600c:	90 91 a4 06 	lds	r25, 0x06A4
    6010:	b9 01       	movw	r22, r18
    6012:	68 1b       	sub	r22, r24
    6014:	79 0b       	sbc	r23, r25
    6016:	cb 01       	movw	r24, r22
    6018:	84 0f       	add	r24, r20
    601a:	95 1f       	adc	r25, r21
    601c:	ec 81       	ldd	r30, Y+4	; 0x04
    601e:	fd 81       	ldd	r31, Y+5	; 0x05
    6020:	91 83       	std	Z+1, r25	; 0x01
    6022:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    6024:	8a 81       	ldd	r24, Y+2	; 0x02
    6026:	9b 81       	ldd	r25, Y+3	; 0x03
    6028:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    602c:	19 82       	std	Y+1, r1	; 0x01
    602e:	02 c0       	rjmp	.+4      	; 0x6034 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    6030:	81 e0       	ldi	r24, 0x01	; 1
    6032:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    6034:	0f 90       	pop	r0
    6036:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6038:	89 81       	ldd	r24, Y+1	; 0x01
}
    603a:	0f 90       	pop	r0
    603c:	0f 90       	pop	r0
    603e:	0f 90       	pop	r0
    6040:	0f 90       	pop	r0
    6042:	0f 90       	pop	r0
    6044:	cf 91       	pop	r28
    6046:	df 91       	pop	r29
    6048:	08 95       	ret

0000604a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    604a:	df 93       	push	r29
    604c:	cf 93       	push	r28
    604e:	cd b7       	in	r28, 0x3d	; 61
    6050:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    6052:	81 e0       	ldi	r24, 0x01	; 1
    6054:	80 93 aa 06 	sts	0x06AA, r24
}
    6058:	cf 91       	pop	r28
    605a:	df 91       	pop	r29
    605c:	08 95       	ret

0000605e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    605e:	df 93       	push	r29
    6060:	cf 93       	push	r28
    6062:	00 d0       	rcall	.+0      	; 0x6064 <prvIdleTask+0x6>
    6064:	cd b7       	in	r28, 0x3d	; 61
    6066:	de b7       	in	r29, 0x3e	; 62
    6068:	9a 83       	std	Y+2, r25	; 0x02
    606a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    606c:	0e 94 cd 30 	call	0x619a	; 0x619a <prvCheckTasksWaitingTermination>
    6070:	fd cf       	rjmp	.-6      	; 0x606c <prvIdleTask+0xe>

00006072 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    6072:	0f 93       	push	r16
    6074:	1f 93       	push	r17
    6076:	df 93       	push	r29
    6078:	cf 93       	push	r28
    607a:	cd b7       	in	r28, 0x3d	; 61
    607c:	de b7       	in	r29, 0x3e	; 62
    607e:	29 97       	sbiw	r28, 0x09	; 9
    6080:	0f b6       	in	r0, 0x3f	; 63
    6082:	f8 94       	cli
    6084:	de bf       	out	0x3e, r29	; 62
    6086:	0f be       	out	0x3f, r0	; 63
    6088:	cd bf       	out	0x3d, r28	; 61
    608a:	9a 83       	std	Y+2, r25	; 0x02
    608c:	89 83       	std	Y+1, r24	; 0x01
    608e:	7c 83       	std	Y+4, r23	; 0x04
    6090:	6b 83       	std	Y+3, r22	; 0x03
    6092:	4d 83       	std	Y+5, r20	; 0x05
    6094:	3f 83       	std	Y+7, r19	; 0x07
    6096:	2e 83       	std	Y+6, r18	; 0x06
    6098:	19 87       	std	Y+9, r17	; 0x09
    609a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    609c:	89 81       	ldd	r24, Y+1	; 0x01
    609e:	9a 81       	ldd	r25, Y+2	; 0x02
    60a0:	49 96       	adiw	r24, 0x19	; 25
    60a2:	2b 81       	ldd	r18, Y+3	; 0x03
    60a4:	3c 81       	ldd	r19, Y+4	; 0x04
    60a6:	b9 01       	movw	r22, r18
    60a8:	48 e0       	ldi	r20, 0x08	; 8
    60aa:	50 e0       	ldi	r21, 0x00	; 0
    60ac:	0e 94 60 32 	call	0x64c0	; 0x64c0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    60b0:	e9 81       	ldd	r30, Y+1	; 0x01
    60b2:	fa 81       	ldd	r31, Y+2	; 0x02
    60b4:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    60b6:	8d 81       	ldd	r24, Y+5	; 0x05
    60b8:	86 30       	cpi	r24, 0x06	; 6
    60ba:	10 f0       	brcs	.+4      	; 0x60c0 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    60bc:	85 e0       	ldi	r24, 0x05	; 5
    60be:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    60c0:	e9 81       	ldd	r30, Y+1	; 0x01
    60c2:	fa 81       	ldd	r31, Y+2	; 0x02
    60c4:	8d 81       	ldd	r24, Y+5	; 0x05
    60c6:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    60c8:	89 81       	ldd	r24, Y+1	; 0x01
    60ca:	9a 81       	ldd	r25, Y+2	; 0x02
    60cc:	02 96       	adiw	r24, 0x02	; 2
    60ce:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    60d2:	89 81       	ldd	r24, Y+1	; 0x01
    60d4:	9a 81       	ldd	r25, Y+2	; 0x02
    60d6:	0c 96       	adiw	r24, 0x0c	; 12
    60d8:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    60dc:	e9 81       	ldd	r30, Y+1	; 0x01
    60de:	fa 81       	ldd	r31, Y+2	; 0x02
    60e0:	89 81       	ldd	r24, Y+1	; 0x01
    60e2:	9a 81       	ldd	r25, Y+2	; 0x02
    60e4:	91 87       	std	Z+9, r25	; 0x09
    60e6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    60e8:	8d 81       	ldd	r24, Y+5	; 0x05
    60ea:	28 2f       	mov	r18, r24
    60ec:	30 e0       	ldi	r19, 0x00	; 0
    60ee:	86 e0       	ldi	r24, 0x06	; 6
    60f0:	90 e0       	ldi	r25, 0x00	; 0
    60f2:	82 1b       	sub	r24, r18
    60f4:	93 0b       	sbc	r25, r19
    60f6:	e9 81       	ldd	r30, Y+1	; 0x01
    60f8:	fa 81       	ldd	r31, Y+2	; 0x02
    60fa:	95 87       	std	Z+13, r25	; 0x0d
    60fc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    60fe:	e9 81       	ldd	r30, Y+1	; 0x01
    6100:	fa 81       	ldd	r31, Y+2	; 0x02
    6102:	89 81       	ldd	r24, Y+1	; 0x01
    6104:	9a 81       	ldd	r25, Y+2	; 0x02
    6106:	93 8b       	std	Z+19, r25	; 0x13
    6108:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    610a:	29 96       	adiw	r28, 0x09	; 9
    610c:	0f b6       	in	r0, 0x3f	; 63
    610e:	f8 94       	cli
    6110:	de bf       	out	0x3e, r29	; 62
    6112:	0f be       	out	0x3f, r0	; 63
    6114:	cd bf       	out	0x3d, r28	; 61
    6116:	cf 91       	pop	r28
    6118:	df 91       	pop	r29
    611a:	1f 91       	pop	r17
    611c:	0f 91       	pop	r16
    611e:	08 95       	ret

00006120 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    6120:	df 93       	push	r29
    6122:	cf 93       	push	r28
    6124:	0f 92       	push	r0
    6126:	cd b7       	in	r28, 0x3d	; 61
    6128:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    612a:	19 82       	std	Y+1, r1	; 0x01
    612c:	13 c0       	rjmp	.+38     	; 0x6154 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    612e:	89 81       	ldd	r24, Y+1	; 0x01
    6130:	28 2f       	mov	r18, r24
    6132:	30 e0       	ldi	r19, 0x00	; 0
    6134:	c9 01       	movw	r24, r18
    6136:	88 0f       	add	r24, r24
    6138:	99 1f       	adc	r25, r25
    613a:	88 0f       	add	r24, r24
    613c:	99 1f       	adc	r25, r25
    613e:	88 0f       	add	r24, r24
    6140:	99 1f       	adc	r25, r25
    6142:	82 0f       	add	r24, r18
    6144:	93 1f       	adc	r25, r19
    6146:	83 55       	subi	r24, 0x53	; 83
    6148:	99 4f       	sbci	r25, 0xF9	; 249
    614a:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    614e:	89 81       	ldd	r24, Y+1	; 0x01
    6150:	8f 5f       	subi	r24, 0xFF	; 255
    6152:	89 83       	std	Y+1, r24	; 0x01
    6154:	89 81       	ldd	r24, Y+1	; 0x01
    6156:	86 30       	cpi	r24, 0x06	; 6
    6158:	50 f3       	brcs	.-44     	; 0x612e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    615a:	83 ee       	ldi	r24, 0xE3	; 227
    615c:	96 e0       	ldi	r25, 0x06	; 6
    615e:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    6162:	8c ee       	ldi	r24, 0xEC	; 236
    6164:	96 e0       	ldi	r25, 0x06	; 6
    6166:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    616a:	89 ef       	ldi	r24, 0xF9	; 249
    616c:	96 e0       	ldi	r25, 0x06	; 6
    616e:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    6172:	82 e0       	ldi	r24, 0x02	; 2
    6174:	97 e0       	ldi	r25, 0x07	; 7
    6176:	0e 94 41 22 	call	0x4482	; 0x4482 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    617a:	83 ee       	ldi	r24, 0xE3	; 227
    617c:	96 e0       	ldi	r25, 0x06	; 6
    617e:	90 93 f6 06 	sts	0x06F6, r25
    6182:	80 93 f5 06 	sts	0x06F5, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6186:	8c ee       	ldi	r24, 0xEC	; 236
    6188:	96 e0       	ldi	r25, 0x06	; 6
    618a:	90 93 f8 06 	sts	0x06F8, r25
    618e:	80 93 f7 06 	sts	0x06F7, r24
}
    6192:	0f 90       	pop	r0
    6194:	cf 91       	pop	r28
    6196:	df 91       	pop	r29
    6198:	08 95       	ret

0000619a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    619a:	df 93       	push	r29
    619c:	cf 93       	push	r28
    619e:	00 d0       	rcall	.+0      	; 0x61a0 <prvCheckTasksWaitingTermination+0x6>
    61a0:	0f 92       	push	r0
    61a2:	cd b7       	in	r28, 0x3d	; 61
    61a4:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    61a6:	80 91 a1 06 	lds	r24, 0x06A1
    61aa:	88 23       	and	r24, r24
    61ac:	71 f1       	breq	.+92     	; 0x620a <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    61ae:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    61b2:	80 91 02 07 	lds	r24, 0x0702
    61b6:	1b 82       	std	Y+3, r1	; 0x03
    61b8:	88 23       	and	r24, r24
    61ba:	11 f4       	brne	.+4      	; 0x61c0 <prvCheckTasksWaitingTermination+0x26>
    61bc:	81 e0       	ldi	r24, 0x01	; 1
    61be:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    61c0:	0e 94 17 2d 	call	0x5a2e	; 0x5a2e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    61c4:	8b 81       	ldd	r24, Y+3	; 0x03
    61c6:	88 23       	and	r24, r24
    61c8:	01 f5       	brne	.+64     	; 0x620a <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    61ca:	0f b6       	in	r0, 0x3f	; 63
    61cc:	f8 94       	cli
    61ce:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    61d0:	e0 91 07 07 	lds	r30, 0x0707
    61d4:	f0 91 08 07 	lds	r31, 0x0708
    61d8:	86 81       	ldd	r24, Z+6	; 0x06
    61da:	97 81       	ldd	r25, Z+7	; 0x07
    61dc:	9a 83       	std	Y+2, r25	; 0x02
    61de:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    61e0:	89 81       	ldd	r24, Y+1	; 0x01
    61e2:	9a 81       	ldd	r25, Y+2	; 0x02
    61e4:	02 96       	adiw	r24, 0x02	; 2
    61e6:	0e 94 33 23 	call	0x4666	; 0x4666 <vListRemove>
					--uxCurrentNumberOfTasks;
    61ea:	80 91 a2 06 	lds	r24, 0x06A2
    61ee:	81 50       	subi	r24, 0x01	; 1
    61f0:	80 93 a2 06 	sts	0x06A2, r24
					--uxTasksDeleted;
    61f4:	80 91 a1 06 	lds	r24, 0x06A1
    61f8:	81 50       	subi	r24, 0x01	; 1
    61fa:	80 93 a1 06 	sts	0x06A1, r24
				}
				taskEXIT_CRITICAL();
    61fe:	0f 90       	pop	r0
    6200:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6202:	89 81       	ldd	r24, Y+1	; 0x01
    6204:	9a 81       	ldd	r25, Y+2	; 0x02
    6206:	0e 94 a4 31 	call	0x6348	; 0x6348 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    620a:	0f 90       	pop	r0
    620c:	0f 90       	pop	r0
    620e:	0f 90       	pop	r0
    6210:	cf 91       	pop	r28
    6212:	df 91       	pop	r29
    6214:	08 95       	ret

00006216 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    6216:	df 93       	push	r29
    6218:	cf 93       	push	r28
    621a:	00 d0       	rcall	.+0      	; 0x621c <prvAddCurrentTaskToDelayedList+0x6>
    621c:	cd b7       	in	r28, 0x3d	; 61
    621e:	de b7       	in	r29, 0x3e	; 62
    6220:	9a 83       	std	Y+2, r25	; 0x02
    6222:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    6224:	e0 91 9f 06 	lds	r30, 0x069F
    6228:	f0 91 a0 06 	lds	r31, 0x06A0
    622c:	89 81       	ldd	r24, Y+1	; 0x01
    622e:	9a 81       	ldd	r25, Y+2	; 0x02
    6230:	93 83       	std	Z+3, r25	; 0x03
    6232:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    6234:	20 91 a3 06 	lds	r18, 0x06A3
    6238:	30 91 a4 06 	lds	r19, 0x06A4
    623c:	89 81       	ldd	r24, Y+1	; 0x01
    623e:	9a 81       	ldd	r25, Y+2	; 0x02
    6240:	82 17       	cp	r24, r18
    6242:	93 07       	cpc	r25, r19
    6244:	70 f4       	brcc	.+28     	; 0x6262 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6246:	80 91 f7 06 	lds	r24, 0x06F7
    624a:	90 91 f8 06 	lds	r25, 0x06F8
    624e:	20 91 9f 06 	lds	r18, 0x069F
    6252:	30 91 a0 06 	lds	r19, 0x06A0
    6256:	2e 5f       	subi	r18, 0xFE	; 254
    6258:	3f 4f       	sbci	r19, 0xFF	; 255
    625a:	b9 01       	movw	r22, r18
    625c:	0e 94 c7 22 	call	0x458e	; 0x458e <vListInsert>
    6260:	1e c0       	rjmp	.+60     	; 0x629e <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6262:	40 91 f5 06 	lds	r20, 0x06F5
    6266:	50 91 f6 06 	lds	r21, 0x06F6
    626a:	80 91 9f 06 	lds	r24, 0x069F
    626e:	90 91 a0 06 	lds	r25, 0x06A0
    6272:	9c 01       	movw	r18, r24
    6274:	2e 5f       	subi	r18, 0xFE	; 254
    6276:	3f 4f       	sbci	r19, 0xFF	; 255
    6278:	ca 01       	movw	r24, r20
    627a:	b9 01       	movw	r22, r18
    627c:	0e 94 c7 22 	call	0x458e	; 0x458e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    6280:	20 91 35 01 	lds	r18, 0x0135
    6284:	30 91 36 01 	lds	r19, 0x0136
    6288:	89 81       	ldd	r24, Y+1	; 0x01
    628a:	9a 81       	ldd	r25, Y+2	; 0x02
    628c:	82 17       	cp	r24, r18
    628e:	93 07       	cpc	r25, r19
    6290:	30 f4       	brcc	.+12     	; 0x629e <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    6292:	89 81       	ldd	r24, Y+1	; 0x01
    6294:	9a 81       	ldd	r25, Y+2	; 0x02
    6296:	90 93 36 01 	sts	0x0136, r25
    629a:	80 93 35 01 	sts	0x0135, r24
		}
	}
}
    629e:	0f 90       	pop	r0
    62a0:	0f 90       	pop	r0
    62a2:	cf 91       	pop	r28
    62a4:	df 91       	pop	r29
    62a6:	08 95       	ret

000062a8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    62a8:	df 93       	push	r29
    62aa:	cf 93       	push	r28
    62ac:	cd b7       	in	r28, 0x3d	; 61
    62ae:	de b7       	in	r29, 0x3e	; 62
    62b0:	28 97       	sbiw	r28, 0x08	; 8
    62b2:	0f b6       	in	r0, 0x3f	; 63
    62b4:	f8 94       	cli
    62b6:	de bf       	out	0x3e, r29	; 62
    62b8:	0f be       	out	0x3f, r0	; 63
    62ba:	cd bf       	out	0x3d, r28	; 61
    62bc:	9c 83       	std	Y+4, r25	; 0x04
    62be:	8b 83       	std	Y+3, r24	; 0x03
    62c0:	7e 83       	std	Y+6, r23	; 0x06
    62c2:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    62c4:	81 e2       	ldi	r24, 0x21	; 33
    62c6:	90 e0       	ldi	r25, 0x00	; 0
    62c8:	0e 94 d5 21 	call	0x43aa	; 0x43aa <pvPortMalloc>
    62cc:	9a 83       	std	Y+2, r25	; 0x02
    62ce:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    62d0:	89 81       	ldd	r24, Y+1	; 0x01
    62d2:	9a 81       	ldd	r25, Y+2	; 0x02
    62d4:	00 97       	sbiw	r24, 0x00	; 0
    62d6:	69 f1       	breq	.+90     	; 0x6332 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    62d8:	8d 81       	ldd	r24, Y+5	; 0x05
    62da:	9e 81       	ldd	r25, Y+6	; 0x06
    62dc:	00 97       	sbiw	r24, 0x00	; 0
    62de:	39 f4       	brne	.+14     	; 0x62ee <prvAllocateTCBAndStack+0x46>
    62e0:	8b 81       	ldd	r24, Y+3	; 0x03
    62e2:	9c 81       	ldd	r25, Y+4	; 0x04
    62e4:	0e 94 d5 21 	call	0x43aa	; 0x43aa <pvPortMalloc>
    62e8:	98 87       	std	Y+8, r25	; 0x08
    62ea:	8f 83       	std	Y+7, r24	; 0x07
    62ec:	04 c0       	rjmp	.+8      	; 0x62f6 <prvAllocateTCBAndStack+0x4e>
    62ee:	8d 81       	ldd	r24, Y+5	; 0x05
    62f0:	9e 81       	ldd	r25, Y+6	; 0x06
    62f2:	98 87       	std	Y+8, r25	; 0x08
    62f4:	8f 83       	std	Y+7, r24	; 0x07
    62f6:	e9 81       	ldd	r30, Y+1	; 0x01
    62f8:	fa 81       	ldd	r31, Y+2	; 0x02
    62fa:	8f 81       	ldd	r24, Y+7	; 0x07
    62fc:	98 85       	ldd	r25, Y+8	; 0x08
    62fe:	90 8f       	std	Z+24, r25	; 0x18
    6300:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    6302:	e9 81       	ldd	r30, Y+1	; 0x01
    6304:	fa 81       	ldd	r31, Y+2	; 0x02
    6306:	87 89       	ldd	r24, Z+23	; 0x17
    6308:	90 8d       	ldd	r25, Z+24	; 0x18
    630a:	00 97       	sbiw	r24, 0x00	; 0
    630c:	39 f4       	brne	.+14     	; 0x631c <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    630e:	89 81       	ldd	r24, Y+1	; 0x01
    6310:	9a 81       	ldd	r25, Y+2	; 0x02
    6312:	0e 94 1b 22 	call	0x4436	; 0x4436 <vPortFree>
			pxNewTCB = NULL;
    6316:	1a 82       	std	Y+2, r1	; 0x02
    6318:	19 82       	std	Y+1, r1	; 0x01
    631a:	0b c0       	rjmp	.+22     	; 0x6332 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    631c:	e9 81       	ldd	r30, Y+1	; 0x01
    631e:	fa 81       	ldd	r31, Y+2	; 0x02
    6320:	87 89       	ldd	r24, Z+23	; 0x17
    6322:	90 8d       	ldd	r25, Z+24	; 0x18
    6324:	2b 81       	ldd	r18, Y+3	; 0x03
    6326:	3c 81       	ldd	r19, Y+4	; 0x04
    6328:	65 ea       	ldi	r22, 0xA5	; 165
    632a:	70 e0       	ldi	r23, 0x00	; 0
    632c:	a9 01       	movw	r20, r18
    632e:	0e 94 59 32 	call	0x64b2	; 0x64b2 <memset>
		}
	}

	return pxNewTCB;
    6332:	89 81       	ldd	r24, Y+1	; 0x01
    6334:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6336:	28 96       	adiw	r28, 0x08	; 8
    6338:	0f b6       	in	r0, 0x3f	; 63
    633a:	f8 94       	cli
    633c:	de bf       	out	0x3e, r29	; 62
    633e:	0f be       	out	0x3f, r0	; 63
    6340:	cd bf       	out	0x3d, r28	; 61
    6342:	cf 91       	pop	r28
    6344:	df 91       	pop	r29
    6346:	08 95       	ret

00006348 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    6348:	df 93       	push	r29
    634a:	cf 93       	push	r28
    634c:	00 d0       	rcall	.+0      	; 0x634e <prvDeleteTCB+0x6>
    634e:	cd b7       	in	r28, 0x3d	; 61
    6350:	de b7       	in	r29, 0x3e	; 62
    6352:	9a 83       	std	Y+2, r25	; 0x02
    6354:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    6356:	e9 81       	ldd	r30, Y+1	; 0x01
    6358:	fa 81       	ldd	r31, Y+2	; 0x02
    635a:	87 89       	ldd	r24, Z+23	; 0x17
    635c:	90 8d       	ldd	r25, Z+24	; 0x18
    635e:	0e 94 1b 22 	call	0x4436	; 0x4436 <vPortFree>
		vPortFree( pxTCB );
    6362:	89 81       	ldd	r24, Y+1	; 0x01
    6364:	9a 81       	ldd	r25, Y+2	; 0x02
    6366:	0e 94 1b 22 	call	0x4436	; 0x4436 <vPortFree>
	}
    636a:	0f 90       	pop	r0
    636c:	0f 90       	pop	r0
    636e:	cf 91       	pop	r28
    6370:	df 91       	pop	r29
    6372:	08 95       	ret

00006374 <timer0_init>:
#include"std_types.h"
#include"Bit_Math.h"
#include"timer.h"


void timer0_init(void){
    6374:	df 93       	push	r29
    6376:	cf 93       	push	r28
    6378:	cd b7       	in	r28, 0x3d	; 61
    637a:	de b7       	in	r29, 0x3e	; 62
		CLR_BIT(MTMR_u8_TCCR0_REG , 6);
    637c:	a3 e5       	ldi	r26, 0x53	; 83
    637e:	b0 e0       	ldi	r27, 0x00	; 0
    6380:	e3 e5       	ldi	r30, 0x53	; 83
    6382:	f0 e0       	ldi	r31, 0x00	; 0
    6384:	80 81       	ld	r24, Z
    6386:	8f 7b       	andi	r24, 0xBF	; 191
    6388:	8c 93       	st	X, r24
		CLR_BIT(MTMR_u8_TCCR0_REG , 3);
    638a:	a3 e5       	ldi	r26, 0x53	; 83
    638c:	b0 e0       	ldi	r27, 0x00	; 0
    638e:	e3 e5       	ldi	r30, 0x53	; 83
    6390:	f0 e0       	ldi	r31, 0x00	; 0
    6392:	80 81       	ld	r24, Z
    6394:	87 7f       	andi	r24, 0xF7	; 247
    6396:	8c 93       	st	X, r24
		CLR_BIT(MTMR_u8_TCCR0_REG , 2);
    6398:	a3 e5       	ldi	r26, 0x53	; 83
    639a:	b0 e0       	ldi	r27, 0x00	; 0
    639c:	e3 e5       	ldi	r30, 0x53	; 83
    639e:	f0 e0       	ldi	r31, 0x00	; 0
    63a0:	80 81       	ld	r24, Z
    63a2:	8b 7f       	andi	r24, 0xFB	; 251
    63a4:	8c 93       	st	X, r24
		SET_BIT(MTMR_u8_TCCR0_REG , 1);
    63a6:	a3 e5       	ldi	r26, 0x53	; 83
    63a8:	b0 e0       	ldi	r27, 0x00	; 0
    63aa:	e3 e5       	ldi	r30, 0x53	; 83
    63ac:	f0 e0       	ldi	r31, 0x00	; 0
    63ae:	80 81       	ld	r24, Z
    63b0:	82 60       	ori	r24, 0x02	; 2
    63b2:	8c 93       	st	X, r24
		CLR_BIT(MTMR_u8_TCCR0_REG , 0);
    63b4:	a3 e5       	ldi	r26, 0x53	; 83
    63b6:	b0 e0       	ldi	r27, 0x00	; 0
    63b8:	e3 e5       	ldi	r30, 0x53	; 83
    63ba:	f0 e0       	ldi	r31, 0x00	; 0
    63bc:	80 81       	ld	r24, Z
    63be:	8e 7f       	andi	r24, 0xFE	; 254
    63c0:	8c 93       	st	X, r24
}
    63c2:	cf 91       	pop	r28
    63c4:	df 91       	pop	r29
    63c6:	08 95       	ret

000063c8 <generateRandomNumbers>:
u8 generateRandomNumbers(u8 mod){
    63c8:	df 93       	push	r29
    63ca:	cf 93       	push	r28
    63cc:	00 d0       	rcall	.+0      	; 0x63ce <generateRandomNumbers+0x6>
    63ce:	cd b7       	in	r28, 0x3d	; 61
    63d0:	de b7       	in	r29, 0x3e	; 62
    63d2:	8a 83       	std	Y+2, r24	; 0x02
   u8 random;
   random = (MTMR_u8_TCNT0_REG % mod);
    63d4:	e2 e5       	ldi	r30, 0x52	; 82
    63d6:	f0 e0       	ldi	r31, 0x00	; 0
    63d8:	80 81       	ld	r24, Z
    63da:	9a 81       	ldd	r25, Y+2	; 0x02
    63dc:	69 2f       	mov	r22, r25
    63de:	0e 94 f9 31 	call	0x63f2	; 0x63f2 <__udivmodqi4>
    63e2:	89 2f       	mov	r24, r25
    63e4:	89 83       	std	Y+1, r24	; 0x01
	return random;
    63e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    63e8:	0f 90       	pop	r0
    63ea:	0f 90       	pop	r0
    63ec:	cf 91       	pop	r28
    63ee:	df 91       	pop	r29
    63f0:	08 95       	ret

000063f2 <__udivmodqi4>:
    63f2:	99 1b       	sub	r25, r25
    63f4:	79 e0       	ldi	r23, 0x09	; 9
    63f6:	04 c0       	rjmp	.+8      	; 0x6400 <__udivmodqi4_ep>

000063f8 <__udivmodqi4_loop>:
    63f8:	99 1f       	adc	r25, r25
    63fa:	96 17       	cp	r25, r22
    63fc:	08 f0       	brcs	.+2      	; 0x6400 <__udivmodqi4_ep>
    63fe:	96 1b       	sub	r25, r22

00006400 <__udivmodqi4_ep>:
    6400:	88 1f       	adc	r24, r24
    6402:	7a 95       	dec	r23
    6404:	c9 f7       	brne	.-14     	; 0x63f8 <__udivmodqi4_loop>
    6406:	80 95       	com	r24
    6408:	08 95       	ret

0000640a <__udivmodhi4>:
    640a:	aa 1b       	sub	r26, r26
    640c:	bb 1b       	sub	r27, r27
    640e:	51 e1       	ldi	r21, 0x11	; 17
    6410:	07 c0       	rjmp	.+14     	; 0x6420 <__udivmodhi4_ep>

00006412 <__udivmodhi4_loop>:
    6412:	aa 1f       	adc	r26, r26
    6414:	bb 1f       	adc	r27, r27
    6416:	a6 17       	cp	r26, r22
    6418:	b7 07       	cpc	r27, r23
    641a:	10 f0       	brcs	.+4      	; 0x6420 <__udivmodhi4_ep>
    641c:	a6 1b       	sub	r26, r22
    641e:	b7 0b       	sbc	r27, r23

00006420 <__udivmodhi4_ep>:
    6420:	88 1f       	adc	r24, r24
    6422:	99 1f       	adc	r25, r25
    6424:	5a 95       	dec	r21
    6426:	a9 f7       	brne	.-22     	; 0x6412 <__udivmodhi4_loop>
    6428:	80 95       	com	r24
    642a:	90 95       	com	r25
    642c:	bc 01       	movw	r22, r24
    642e:	cd 01       	movw	r24, r26
    6430:	08 95       	ret

00006432 <__prologue_saves__>:
    6432:	2f 92       	push	r2
    6434:	3f 92       	push	r3
    6436:	4f 92       	push	r4
    6438:	5f 92       	push	r5
    643a:	6f 92       	push	r6
    643c:	7f 92       	push	r7
    643e:	8f 92       	push	r8
    6440:	9f 92       	push	r9
    6442:	af 92       	push	r10
    6444:	bf 92       	push	r11
    6446:	cf 92       	push	r12
    6448:	df 92       	push	r13
    644a:	ef 92       	push	r14
    644c:	ff 92       	push	r15
    644e:	0f 93       	push	r16
    6450:	1f 93       	push	r17
    6452:	cf 93       	push	r28
    6454:	df 93       	push	r29
    6456:	cd b7       	in	r28, 0x3d	; 61
    6458:	de b7       	in	r29, 0x3e	; 62
    645a:	ca 1b       	sub	r28, r26
    645c:	db 0b       	sbc	r29, r27
    645e:	0f b6       	in	r0, 0x3f	; 63
    6460:	f8 94       	cli
    6462:	de bf       	out	0x3e, r29	; 62
    6464:	0f be       	out	0x3f, r0	; 63
    6466:	cd bf       	out	0x3d, r28	; 61
    6468:	09 94       	ijmp

0000646a <__epilogue_restores__>:
    646a:	2a 88       	ldd	r2, Y+18	; 0x12
    646c:	39 88       	ldd	r3, Y+17	; 0x11
    646e:	48 88       	ldd	r4, Y+16	; 0x10
    6470:	5f 84       	ldd	r5, Y+15	; 0x0f
    6472:	6e 84       	ldd	r6, Y+14	; 0x0e
    6474:	7d 84       	ldd	r7, Y+13	; 0x0d
    6476:	8c 84       	ldd	r8, Y+12	; 0x0c
    6478:	9b 84       	ldd	r9, Y+11	; 0x0b
    647a:	aa 84       	ldd	r10, Y+10	; 0x0a
    647c:	b9 84       	ldd	r11, Y+9	; 0x09
    647e:	c8 84       	ldd	r12, Y+8	; 0x08
    6480:	df 80       	ldd	r13, Y+7	; 0x07
    6482:	ee 80       	ldd	r14, Y+6	; 0x06
    6484:	fd 80       	ldd	r15, Y+5	; 0x05
    6486:	0c 81       	ldd	r16, Y+4	; 0x04
    6488:	1b 81       	ldd	r17, Y+3	; 0x03
    648a:	aa 81       	ldd	r26, Y+2	; 0x02
    648c:	b9 81       	ldd	r27, Y+1	; 0x01
    648e:	ce 0f       	add	r28, r30
    6490:	d1 1d       	adc	r29, r1
    6492:	0f b6       	in	r0, 0x3f	; 63
    6494:	f8 94       	cli
    6496:	de bf       	out	0x3e, r29	; 62
    6498:	0f be       	out	0x3f, r0	; 63
    649a:	cd bf       	out	0x3d, r28	; 61
    649c:	ed 01       	movw	r28, r26
    649e:	08 95       	ret

000064a0 <memcpy>:
    64a0:	fb 01       	movw	r30, r22
    64a2:	dc 01       	movw	r26, r24
    64a4:	02 c0       	rjmp	.+4      	; 0x64aa <memcpy+0xa>
    64a6:	01 90       	ld	r0, Z+
    64a8:	0d 92       	st	X+, r0
    64aa:	41 50       	subi	r20, 0x01	; 1
    64ac:	50 40       	sbci	r21, 0x00	; 0
    64ae:	d8 f7       	brcc	.-10     	; 0x64a6 <memcpy+0x6>
    64b0:	08 95       	ret

000064b2 <memset>:
    64b2:	dc 01       	movw	r26, r24
    64b4:	01 c0       	rjmp	.+2      	; 0x64b8 <memset+0x6>
    64b6:	6d 93       	st	X+, r22
    64b8:	41 50       	subi	r20, 0x01	; 1
    64ba:	50 40       	sbci	r21, 0x00	; 0
    64bc:	e0 f7       	brcc	.-8      	; 0x64b6 <memset+0x4>
    64be:	08 95       	ret

000064c0 <strncpy>:
    64c0:	fb 01       	movw	r30, r22
    64c2:	dc 01       	movw	r26, r24
    64c4:	41 50       	subi	r20, 0x01	; 1
    64c6:	50 40       	sbci	r21, 0x00	; 0
    64c8:	48 f0       	brcs	.+18     	; 0x64dc <strncpy+0x1c>
    64ca:	01 90       	ld	r0, Z+
    64cc:	0d 92       	st	X+, r0
    64ce:	00 20       	and	r0, r0
    64d0:	c9 f7       	brne	.-14     	; 0x64c4 <strncpy+0x4>
    64d2:	01 c0       	rjmp	.+2      	; 0x64d6 <strncpy+0x16>
    64d4:	1d 92       	st	X+, r1
    64d6:	41 50       	subi	r20, 0x01	; 1
    64d8:	50 40       	sbci	r21, 0x00	; 0
    64da:	e0 f7       	brcc	.-8      	; 0x64d4 <strncpy+0x14>
    64dc:	08 95       	ret

000064de <_exit>:
    64de:	f8 94       	cli

000064e0 <__stop_program>:
    64e0:	ff cf       	rjmp	.-2      	; 0x64e0 <__stop_program>
